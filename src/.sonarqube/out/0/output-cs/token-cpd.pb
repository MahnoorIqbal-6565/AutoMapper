Õû
CC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\TypeMap.cs
	namespace 	

AutoMapper
 
; 
[ 
DebuggerDisplay 
( 
$str >
)> ?
]? @
[		 
EditorBrowsable		 
(		  
EditorBrowsableState		 %
.		% &
Never		& +
)		+ ,
]		, -
public

 
sealed

 
class

 
TypeMap

 
{ 
static 

readonly 
LambdaExpression $
EmptyLambda% 0
=1 2
Lambda3 9
(9 :
ExpressionBuilder: K
.K L
EmptyL Q
)Q R
;R S
static 

readonly 

MethodInfo 
CreateProxyMethod 0
=1 2
typeof3 9
(9 :
ObjectFactory: G
)G H
.H I
GetStaticMethodI X
(X Y
nameofY _
(_ `
ObjectFactory` m
.m n!
CreateInterfaceProxy	n Ç
)
Ç É
)
É Ñ
;
Ñ Ö
TypeMapDetails 
_details 
; 
List 
< 	
PropertyMap	 
> 
_propertyMaps #
;# $
bool 
_sealed	 
; 
public 

TypeMap 
( 
Type 

sourceType "
," #
Type$ (
destinationType) 8
,8 9

ProfileMap: D
profileE L
,L M 
TypeMapConfigurationN b 
typeMapConfigurationc w
,w x
Listy }
<} ~

MemberInfo	~ à
>
à â
sourceMembers
ä ó
=
ò ô
null
ö û
)
û ü
{ 
Types 
= 
new 
( 

sourceType 
, 
destinationType  /
)/ 0
;0 1
Profile 
= 
profile 
; 
if 

(  
typeMapConfiguration  
?  !
.! "
HasTypeConverter" 2
is3 5
true6 :
): ;
{ 	
return 
; 
} 	
SourceTypeDetails 
= 
profile #
.# $
CreateTypeDetails$ 5
(5 6

sourceType6 @
)@ A
;A B"
DestinationTypeDetails 
=  
profile! (
.( )
CreateTypeDetails) :
(: ;
destinationType; J
)J K
;K L
sourceMembers 
??= 
[ 
] 
; 
var 
isReverseMap 
=  
typeMapConfiguration /
?/ 0
.0 1
IsReverseMap1 =
is> @
trueA E
;E F
foreach 
( 
var 
destinationProperty (
in) +"
DestinationTypeDetails, B
.B C
WriteAccessorsC Q
)Q R
{ 	
var 
destinationName 
=  !
destinationProperty" 5
.5 6
Name6 :
;: ;
var   
memberConfig   
=    
typeMapConfiguration   3
?  3 4
.  4 5-
!GetDestinationMemberConfiguration  5 V
(  V W
destinationProperty  W j
)  j k
;  k l
if!! 
(!! 
memberConfig!! 
?!! 
.!! 
Ignored!! %
is!!& (
true!!) -
||!!. 0
profile!!1 8
.!!8 9
GlobalIgnores!!9 F
.!!F G
Contains!!G O
(!!O P
destinationName!!P _
)!!_ `
)!!` a
{"" 
continue## 
;## 
}$$ 
sourceMembers%% 
.%% 
Clear%% 
(%%  
)%%  !
;%%! "
var&& 
propertyType&& 
=&& 
destinationProperty&& 2
.&&2 3
GetMemberType&&3 @
(&&@ A
)&&A B
;&&B C
if'' 
('' 
profile'' 
.'' *
MapDestinationPropertyToSource'' 6
(''6 7
SourceTypeDetails''7 H
,''H I
destinationType''J Y
,''Y Z
propertyType''[ g
,''g h
destinationName''i x
,''x y
sourceMembers	''z á
,
''á à
isReverseMap
''â ï
)
''ï ñ
)
''ñ ó
{(( 
AddPropertyMap)) 
()) 
destinationProperty)) 2
,))2 3
propertyType))4 @
,))@ A
sourceMembers))B O
)))O P
;))P Q
}** 
}++ 	
},, 
public-- 

string-- 
CheckRecord-- 
(-- 
)-- 
=>--  "
ConstructorMap--# 1
?--1 2
.--2 3
Ctor--3 7
is--8 :
ConstructorInfo--; J
ctor--K O
&&--P R
ctor--S W
.--W X
IsFamily--X `
&&--a c
ctor--d h
.--h i
Has--i l
<--l m'
CompilerGeneratedAttribute	--m á
>
--á à
(
--à â
)
--â ä
?
--ã å
$str	.. â
:
..ä ã
null
..å ê
;
..ê ë
public// 

Features// 
<// 
IRuntimeFeature// #
>//# $
Features//% -
=>//. 0
Details//1 8
.//8 9
Features//9 A
;//A B
private00 
TypeMapDetails00 
Details00 "
=>00# %
_details00& .
??=00/ 2
new003 6
(006 7
)007 8
;008 9
public11 

bool11 

HasDetails11 
=>11 
_details11 &
!=11' )
null11* .
;11. /
public22 

void22 
CheckProjection22 
(22  
)22  !
{33 
if44 

(44 

Projection44 
)44 
{55 	
throw66 
new66 ,
 AutoMapperConfigurationException66 6
(666 7
$str667 m
,66m n 
MissingMapException	66o Ç
(
66Ç É
Types
66É à
)
66à â
)
66â ä
;
66ä ã
}77 	
}88 
public99 

static99 
	Exception99 
MissingMapException99 /
(99/ 0
TypePair990 8
types999 >
)99> ?
=>99@ B
MissingMapException99C V
(99V W
types99W \
.99\ ]

SourceType99] g
,99g h
types99i n
.99n o
DestinationType99o ~
)99~ 
;	99 Ä
public:: 

static:: 
	Exception:: 
MissingMapException:: /
(::/ 0
Type::0 4

sourceType::5 ?
,::? @
Type::A E
destinationType::F U
)::U V
=>;; 

new;; %
InvalidOperationException;; (
(;;( )
$";;) +
$str;;+ <
{;;< =

sourceType;;= G
};;G H
$str;;H L
{;;L M
destinationType;;M \
};;\ ]
$str;;] v
{;;v w

sourceType	;;w Å
.
;;Å Ç
Name
;;Ç Ü
}
;;Ü á
$str
;;á â
{
;;â ä
destinationType
;;ä ô
.
;;ô ö
Name
;;ö û
}
;;û ü
$str
;;ü °
"
;;° ¢
)
;;¢ £
;
;;£ §
public<< 

bool<< 

Projection<< 
{<< 
get<<  
;<<  !
set<<" %
;<<% &
}<<' (
public== 

LambdaExpression== 
MapExpression== )
{==* +
get==, /
;==/ 0
private==1 8
set==9 <
;==< =
}==> ?
public>> 


Expression>> 
Invoke>> 
(>> 

Expression>> '
source>>( .
,>>. /

Expression>>0 :
destination>>; F
)>>F G
=>>>H J

Expression?? 
.?? 
Invoke?? 
(?? 
MapExpression?? '
,??' (
ToType??) /
(??/ 0
source??0 6
,??6 7

SourceType??8 B
)??B C
,??C D
ToType??E K
(??K L
destination??L W
,??W X
DestinationType??Y h
)??h i
,??i j
ContextParameter??k {
)??{ |
;??| }
internal@@ 
bool@@ 
CanConstructorMap@@ #
(@@# $
)@@$ %
=>@@& (
Profile@@) 0
.@@0 1%
ConstructorMappingEnabled@@1 J
&&@@K M
!@@N O
DestinationType@@O ^
.@@^ _

IsAbstract@@_ i
&&@@j l
!AA 	
CustomConstructionAA	 
&&AA 
!AA  
HasTypeConverterAA  0
&&AA1 3#
DestinationConstructorsAA4 K
.AAK L
LengthAAL R
>AAS T
$numAAU V
;AAV W
publicBB 

TypePairBB 
TypesBB 
;BB 
publicCC 

ConstructorMapCC 
ConstructorMapCC (
{CC) *
getCC+ .
;CC. /
setCC0 3
;CC3 4
}CC5 6
publicDD 

TypeDetailsDD 
SourceTypeDetailsDD (
{DD) *
getDD+ .
;DD. /
privateDD0 7
setDD8 ;
;DD; <
}DD= >
publicEE 

TypeDetailsEE "
DestinationTypeDetailsEE -
{EE. /
getEE0 3
;EE3 4
privateEE5 <
setEE= @
;EE@ A
}EEB C
publicFF 

TypeFF 

SourceTypeFF 
=>FF 
TypesFF #
.FF# $

SourceTypeFF$ .
;FF. /
publicGG 

TypeGG 
DestinationTypeGG 
=>GG  "
TypesGG# (
.GG( )
DestinationTypeGG) 8
;GG8 9
publicHH 


ProfileMapHH 
ProfileHH 
{HH 
getHH  #
;HH# $
}HH% &
publicII 

LambdaExpressionII 
CustomMapExpressionII /
=>II0 2
TypeConverterII3 @
?II@ A
.IIA B
ProjectToExpressionIIB U
;IIU V
publicJJ 

LambdaExpressionJJ 
CustomCtorFunctionJJ .
{JJ/ 0
getJJ1 4
=>JJ5 7
_detailsJJ8 @
?JJ@ A
.JJA B
CustomCtorFunctionJJB T
;JJT U
setJJV Y
=>JJZ \
DetailsJJ] d
.JJd e
CustomCtorFunctionJJe w
=JJx y
valueJJz 
;	JJ Ä
}
JJÅ Ç
publicKK 

LambdaExpressionKK  
CustomCtorExpressionKK 0
=>KK1 3
CustomCtorFunctionKK4 F
isKKG I
{KKJ K

ParametersKKL V
:KKV W
[KKX Y
_KKY Z
]KKZ [
}KK\ ]
?KK^ _
CustomCtorFunctionKK` r
:KKs t
nullKKu y
;KKy z
publicLL 

boolLL "
IncludeAllDerivedTypesLL &
{LL' (
getLL) ,
=>LL- /
(LL0 1
_detailsLL1 9
?LL9 :
.LL: ;"
IncludeAllDerivedTypesLL; Q
)LLQ R
.LLR S
GetValueOrDefaultLLS d
(LLd e
)LLe f
;LLf g
setLLh k
=>LLl n
DetailsLLo v
.LLv w#
IncludeAllDerivedTypes	LLw ç
=
LLé è
value
LLê ï
;
LLï ñ
}
LLó ò
publicMM 


MemberListMM  
ConfiguredMemberListMM *
{NN 
getOO 
=>OO 
(OO 
_detailsOO 
?OO 
.OO  
ConfiguredMemberListOO .
)OO. /
.OO/ 0
GetValueOrDefaultOO0 A
(OOA B
)OOB C
;OOC D
setPP 
{QQ 	
ifRR 
(RR 
_detailsRR 
==RR 
nullRR  
&&RR! #
valueRR$ )
==RR* ,
defaultRR- 4
)RR4 5
{SS 
returnTT 
;TT 
}UU 
DetailsVV 
.VV  
ConfiguredMemberListVV (
=VV) *
valueVV+ 0
;VV0 1
}WW 	
}XX 
publicYY 

IReadOnlyCollectionYY 
<YY 
TypePairYY '
>YY' ( 
IncludedDerivedTypesYY) =
=>YY> @
(YYA B
_detailsYYB J
?YYJ K
.YYK L 
IncludedDerivedTypesYYL `
)YY` a
.YYa b
	NullCheckYYb k
(YYk l
)YYl m
;YYm n
publicZZ 

IReadOnlyCollectionZZ 
<ZZ 
TypePairZZ '
>ZZ' (
IncludedBaseTypesZZ) :
=>ZZ; =
(ZZ> ?
_detailsZZ? G
?ZZG H
.ZZH I
IncludedBaseTypesZZI Z
)ZZZ [
.ZZ[ \
	NullCheckZZ\ e
(ZZe f
)ZZf g
;ZZg h
public[[ 

IReadOnlyCollection[[ 
<[[ 
LambdaExpression[[ /
>[[/ 0
BeforeMapActions[[1 A
=>[[B D
([[E F
_details[[F N
?[[N O
.[[O P
BeforeMapActions[[P `
)[[` a
.[[a b
	NullCheck[[b k
([[k l
)[[l m
;[[m n
public\\ 

IReadOnlyCollection\\ 
<\\ 
LambdaExpression\\ /
>\\/ 0
AfterMapActions\\1 @
=>\\A C
(\\D E
_details\\E M
?\\M N
.\\N O
AfterMapActions\\O ^
)\\^ _
.\\_ `
	NullCheck\\` i
(\\i j
)\\j k
;\\k l
public]] 

IReadOnlyCollection]] 
<]] )
ValueTransformerConfiguration]] <
>]]< =
ValueTransformers]]> O
=>]]P R
(]]S T
_details]]T \
?]]\ ]
.]]] ^#
ValueTransformerConfigs]]^ u
)]]u v
.]]v w
	NullCheck	]]w Ä
(
]]Ä Å
)
]]Å Ç
;
]]Ç É
public^^ 

bool^^ 
PreserveReferences^^ "
{^^# $
get^^% (
=>^^) +
(^^, -
_details^^- 5
?^^5 6
.^^6 7
PreserveReferences^^7 I
)^^I J
.^^J K
GetValueOrDefault^^K \
(^^\ ]
)^^] ^
;^^^ _
set^^` c
=>^^d f
Details^^g n
.^^n o
PreserveReferences	^^o Å
=
^^Ç É
value
^^Ñ â
;
^^â ä
}
^^ã å
public__ 

int__ 
MaxDepth__ 
{__ 
get__ 
=>__  
(__! "
_details__" *
?__* +
.__+ ,
MaxDepth__, 4
)__4 5
.__5 6
GetValueOrDefault__6 G
(__G H
)__H I
;__I J
set__K N
=>__O Q
Details__R Y
.__Y Z
MaxDepth__Z b
=__c d
value__e j
;__j k
}__l m
public`` 

bool`` (
DisableConstructorValidation`` ,
{``- .
get``/ 2
=>``3 5
(``6 7
_details``7 ?
?``? @
.``@ A(
DisableConstructorValidation``A ]
)``] ^
.``^ _
GetValueOrDefault``_ p
(``p q
)``q r
;``r s
set``t w
=>``x z
Details	``{ Ç
.
``Ç É*
DisableConstructorValidation
``É ü
=
``† °
value
``¢ ß
;
``ß ®
}
``© ™
publicaa 

IReadOnlyCollectionaa 
<aa 
PropertyMapaa *
>aa* +
PropertyMapsaa, 8
=>aa9 ;
_propertyMapsaa< I
.aaI J
	NullCheckaaJ S
(aaS T
)aaT U
;aaU V
publicbb 

IReadOnlyCollectionbb 
<bb 
PathMapbb &
>bb& '
PathMapsbb( 0
=>bb1 3
(bb4 5
_detailsbb5 =
?bb= >
.bb> ?
PathMapsbb? G
)bbG H
.bbH I
	NullCheckbbI R
(bbR S
)bbS T
;bbT U
publiccc 

IEnumerablecc 
<cc 
	MemberMapcc  
>cc  !

MemberMapscc" ,
{dd 
getee 
{ff 	
vargg 
mapsgg 
=gg 
PropertyMapsgg #
.gg# $
Concatgg$ *
(gg* +
(gg+ ,
IReadOnlyCollectiongg, ?
<gg? @
	MemberMapgg@ I
>ggI J
)ggJ K
PathMapsggK S
)ggS T
;ggT U
ifhh 
(hh 
ConstructorMappinghh "
)hh" #
{ii 
mapsjj 
=jj 
mapsjj 
.jj 
Concatjj "
(jj" #
ConstructorMapjj# 1
.jj1 2

CtorParamsjj2 <
)jj< =
;jj= >
}kk 
returnll 
mapsll 
;ll 
}mm 	
}nn 
publicoo 

booloo  
PassesCtorValidationoo $
=>oo% '(
DisableConstructorValidationpp $
||qq 

CustomConstructionqq 
||rr 

ConstructorMappingrr 
||ss 

DestinationTypess 
.ss 

IsAbstractss %
||tt 

DestinationTypett 
.tt 
IsValueTypett &
||uu 

TypeDetailsuu 
.uu 
GetConstructorsuu &
(uu& '
DestinationTypeuu' 6
,uu6 7
Profileuu8 ?
)uu? @
.uu@ A
AnyuuA D
(uuD E
cuuE F
=>uuG I
cuuJ K
.uuK L!
AllParametersOptionaluuL a
(uua b
)uub c
)uuc d
;uud e
publicvv 


MemberInfovv 
[vv 
]vv 
DestinationSettersvv *
=>vv+ -"
DestinationTypeDetailsvv. D
.vvD E
WriteAccessorsvvE S
;vvS T
publicww 
!
ConstructorParametersww  
[ww  !
]ww! "#
DestinationConstructorsww# :
=>ww; ="
DestinationTypeDetailsww> T
.wwT U
ConstructorswwU a
;wwa b
publicxx 

boolxx 
ConstructorMappingxx "
=>xx# %
ConstructorMapxx& 4
isxx5 7
{xx8 9

CanResolvexx: D
:xxD E
truexxF J
}xxK L
;xxL M
publicyy 

boolyy 
CustomConstructionyy "
=>yy# %
CustomCtorFunctionyy& 8
!=yy9 ;
nullyy< @
;yy@ A
publiczz 

boolzz 
HasTypeConverterzz  
=>zz! #
TypeConverterzz$ 1
!=zz2 4
nullzz5 9
;zz9 :
public{{ 

	Execution{{ 
.{{ 
TypeConverter{{ "
TypeConverter{{# 0
{{{1 2
get{{3 6
;{{6 7
set{{8 ;
;{{; <
}{{= >
public|| 

bool|| 
ShouldCheckForValid|| #
=>||$ & 
ConfiguredMemberList||' ;
!=||< >

MemberList||? I
.||I J
None||J N
&&||O Q
!||R S
HasTypeConverter||S c
;||c d
public}} 

LambdaExpression}} 
[}} 
]}} 
IncludedMembers}} -
{}}. /
get}}0 3
=>}}4 6
_details}}7 ?
?}}? @
.}}@ A
IncludedMembers}}A P
??}}Q S
[}}T U
]}}U V
;}}V W
set}}X [
=>}}\ ^
Details}}_ f
.}}f g
IncludedMembers}}g v
=}}w x
value}}y ~
;}}~ 
}
}}Ä Å
public~~ 

string~~ 
[~~ 
]~~  
IncludedMembersNames~~ (
{~~) *
get~~+ .
=>~~/ 1
_details~~2 :
?~~: ;
.~~; < 
IncludedMembersNames~~< P
??~~Q S
[~~T U
]~~U V
;~~V W
set~~X [
=>~~\ ^
Details~~_ f
.~~f g 
IncludedMembersNames~~g {
=~~| }
value	~~~ É
;
~~É Ñ
}
~~Ö Ü
public 

IReadOnlyCollection 
< 
IncludedMember -
>- .#
IncludedMembersTypeMaps/ F
=>G I
(J K
_detailsK S
?S T
.T U#
IncludedMembersTypeMapsU l
)l m
.m n
	NullCheckn w
(w x
)x y
;y z
public
ÄÄ 

Type
ÄÄ 
MakeGenericType
ÄÄ 
(
ÄÄ  
Type
ÄÄ  $
type
ÄÄ% )
)
ÄÄ) *
=>
ÄÄ+ -
type
ÄÄ. 2
.
ÄÄ2 3%
IsGenericTypeDefinition
ÄÄ3 J
?
ÄÄK L
type
ÅÅ 
.
ÅÅ 
MakeGenericType
ÅÅ 
(
ÅÅ 

SourceType
ÅÅ '
.
ÅÅ' ("
GenericTypeArguments
ÅÅ( <
.
ÅÅ< =
Concat
ÅÅ= C
(
ÅÅC D
DestinationType
ÅÅD S
.
ÅÅS T"
GenericTypeArguments
ÅÅT h
)
ÅÅh i
.
ÅÅi j
Take
ÅÅj n
(
ÅÅn o
type
ÅÅo s
.
ÅÅs t%
GenericParametersCountÅÅt ä
(ÅÅä ã
)ÅÅã å
)ÅÅå ç
.ÅÅç é
ToArrayÅÅé ï
(ÅÅï ñ
)ÅÅñ ó
)ÅÅó ò
:ÅÅô ö
type
ÇÇ 
;
ÇÇ 
public
ÉÉ 

bool
ÉÉ  
HasIncludedMembers
ÉÉ "
=>
ÉÉ# %
IncludedMembers
ÉÉ& 5
.
ÉÉ5 6
Length
ÉÉ6 <
>
ÉÉ= >
$num
ÉÉ? @
||
ÉÉA C"
IncludedMembersNames
ÉÉD X
.
ÉÉX Y
Length
ÉÉY _
>
ÉÉ` a
$num
ÉÉb c
;
ÉÉc d
public
ÑÑ 

IEnumerable
ÑÑ 
<
ÑÑ 
LambdaExpression
ÑÑ '
>
ÑÑ' (#
GetAllIncludedMembers
ÑÑ) >
(
ÑÑ> ?
)
ÑÑ? @
=>
ÑÑA C"
IncludedMembersNames
ÑÑD X
.
ÑÑX Y
Length
ÑÑY _
==
ÑÑ` b
$num
ÑÑc d
||
ÑÑe g

SourceType
ÑÑh r
.
ÑÑr s(
ContainsGenericParametersÑÑs å
?ÑÑç é
IncludedMembers
ÖÖ 
:
ÖÖ 
IncludedMembers
ÖÖ )
.
ÖÖ) *
Concat
ÖÖ* 0
(
ÖÖ0 1"
IncludedMembersNames
ÖÖ1 E
.
ÖÖE F
Select
ÖÖF L
(
ÖÖL M
name
ÖÖM Q
=>
ÖÖR T 
MemberAccessLambda
ÖÖU g
(
ÖÖg h

SourceType
ÖÖh r
,
ÖÖr s
name
ÖÖt x
,
ÖÖx y
this
ÖÖz ~
)
ÖÖ~ 
)ÖÖ Ä
)ÖÖÄ Å
;ÖÖÅ Ç
public
ÜÜ 

bool
ÜÜ )
ConstructorParameterMatches
ÜÜ +
(
ÜÜ+ ,
string
ÜÜ, 2%
destinationPropertyName
ÜÜ3 J
)
ÜÜJ K
=>
ÜÜL N 
ConstructorMapping
ÜÜO a
&&
ÜÜb d
ConstructorMap
ÜÜe s
[
ÜÜs t&
destinationPropertyNameÜÜt ã
]ÜÜã å
!=ÜÜç è
nullÜÜê î
;ÜÜî ï
private
áá 
void
áá 
AddPropertyMap
áá 
(
áá  

MemberInfo
áá  *
destProperty
áá+ 7
,
áá7 8
Type
áá9 =%
destinationPropertyType
áá> U
,
ááU V
List
ááW [
<
áá[ \

MemberInfo
áá\ f
>
ááf g
sourceMembers
ááh u
)
ááu v
{
àà 
PropertyMap
ââ 
propertyMap
ââ 
=
ââ  !
new
ââ" %
(
ââ% &
destProperty
ââ& 2
,
ââ2 3%
destinationPropertyType
ââ4 K
,
ââK L
this
ââM Q
)
ââQ R
;
ââR S
propertyMap
ää 
.
ää 
MapByConvention
ää #
(
ää# $
[
ää$ %
..
ää% '
sourceMembers
ää' 4
]
ää4 5
)
ää5 6
;
ää6 7
AddPropertyMap
ãã 
(
ãã 
propertyMap
ãã "
)
ãã" #
;
ãã# $
}
åå 
private
çç 
void
çç 
AddPropertyMap
çç 
(
çç  
PropertyMap
çç  +
propertyMap
çç, 7
)
çç7 8
{
éé 
_propertyMaps
èè 
??=
èè 
[
èè 
]
èè 
;
èè 
_propertyMaps
êê 
.
êê 
Add
êê 
(
êê 
propertyMap
êê %
)
êê% &
;
êê& '
}
ëë 
public
íí 

string
íí 
[
íí 
]
íí &
GetUnmappedPropertyNames
íí ,
(
íí, -
)
íí- .
{
ìì 
IEnumerable
îî 
<
îî 
string
îî 
>
îî 

properties
îî &
;
îî& '
if
ïï 

(
ïï "
ConfiguredMemberList
ïï  
==
ïï! #

MemberList
ïï$ .
.
ïï. /
Destination
ïï/ :
)
ïï: ;
{
ññ 	

properties
óó 
=
óó 
Profile
óó  
.
óó  !
CreateTypeDetails
óó! 2
(
óó2 3
DestinationType
óó3 B
)
óóB C
.
óóC D
WriteAccessors
óóD R
.
òò 
Select
òò 
(
òò 
p
òò 
=>
òò 
p
òò 
.
òò 
Name
òò #
)
òò# $
.
ôô 
Where
ôô 
(
ôô 
p
ôô 
=>
ôô 
!
ôô )
ConstructorParameterMatches
ôô 8
(
ôô8 9
p
ôô9 :
)
ôô: ;
)
ôô; <
.
öö 
Except
öö 
(
öö 
MappedMembers
öö %
(
öö% &
)
öö& '
.
öö' (
Select
öö( .
(
öö. /
m
öö/ 0
=>
öö1 3
m
öö4 5
.
öö5 6
DestinationName
öö6 E
)
ööE F
)
ööF G
.
õõ 
Except
õõ 
(
õõ 
PathMaps
õõ  
.
õõ  !
Select
õõ! '
(
õõ' (
p
õõ( )
=>
õõ* ,
p
õõ- .
.
õõ. /

MemberPath
õõ/ 9
.
õõ9 :
First
õõ: ?
.
õõ? @
Name
õõ@ D
)
õõD E
)
õõE F
;
õõF G
}
úú 	
else
ùù 
{
ûû 	
var
üü "
ignoredSourceMembers
üü $
=
üü% &
_details
üü' /
?
üü/ 0
.
üü0 1!
SourceMemberConfigs
üü1 D
?
üüD E
.
†† 
Where
†† 
(
†† 
smc
†† 
=>
†† 
smc
†† !
.
††! "
Ignored
††" )
)
††) *
.
°° 
Select
°° 
(
°° 
pm
°° 
=>
°° 
pm
°°  
.
°°  !
SourceMember
°°! -
.
°°- .
Name
°°. 2
)
°°2 3
;
°°3 4

properties
¢¢ 
=
¢¢ 
Profile
¢¢  
.
¢¢  !
CreateTypeDetails
¢¢! 2
(
¢¢2 3

SourceType
¢¢3 =
)
¢¢= >
.
¢¢> ?
ReadAccessors
¢¢? L
.
££ 
Select
££ 
(
££ 
p
££ 
=>
££ 
p
££ 
.
££ 
Name
££ #
)
££# $
.
§§ 
Except
§§ 
(
§§ 
MappedMembers
§§ %
(
§§% &
)
§§& '
.
§§' (
Select
§§( .
(
§§. /
m
§§/ 0
=>
§§1 3
m
§§4 5
.
§§5 6!
GetSourceMemberName
§§6 I
(
§§I J
)
§§J K
)
§§K L
)
§§L M
.
•• 
Except
•• 
(
•• "
IncludedMembersNames
•• ,
)
••, -
.
¶¶ 
Except
¶¶ 
(
¶¶ 
IncludedMembers
¶¶ '
.
¶¶' (
Select
¶¶( .
(
¶¶. /
m
¶¶/ 0
=>
¶¶1 3
m
¶¶4 5
.
¶¶5 6
	GetMember
¶¶6 ?
(
¶¶? @
)
¶¶@ A
?
¶¶A B
.
¶¶B C
Name
¶¶C G
)
¶¶G H
)
¶¶H I
.
ßß 
Except
ßß 
(
ßß "
ignoredSourceMembers
ßß ,
??
ßß- /
[
ßß0 1
]
ßß1 2
)
ßß2 3
;
ßß3 4
}
®® 	
return
©© 

properties
©© 
.
©© 
Where
©© 
(
©©  

memberName
©©  *
=>
©©+ -
!
©©. /
Profile
©©/ 6
.
©©6 7
GlobalIgnores
©©7 D
.
©©D E
Any
©©E H
(
©©H I

memberName
©©I S
.
©©S T

StartsWith
©©T ^
)
©©^ _
)
©©_ `
.
©©` a
ToArray
©©a h
(
©©h i
)
©©i j
;
©©j k
IEnumerable
™™ 
<
™™ 
	MemberMap
™™ 
>
™™ 
MappedMembers
™™ ,
(
™™, -
)
™™- .
=>
™™/ 1

MemberMaps
™™2 <
.
™™< =
Where
™™= B
(
™™B C
pm
™™C E
=>
™™F H
pm
™™I K
.
™™K L
IsMapped
™™L T
)
™™T U
;
™™U V
}
´´ 
public
¨¨ 

PropertyMap
¨¨ (
FindOrCreatePropertyMapFor
¨¨ 1
(
¨¨1 2

MemberInfo
¨¨2 <!
destinationProperty
¨¨= P
,
¨¨P Q
Type
¨¨R V%
destinationPropertyType
¨¨W n
)
¨¨n o
{
≠≠ 
var
ÆÆ 
propertyMap
ÆÆ 
=
ÆÆ 
GetPropertyMap
ÆÆ (
(
ÆÆ( )!
destinationProperty
ÆÆ) <
.
ÆÆ< =
Name
ÆÆ= A
)
ÆÆA B
;
ÆÆB C
if
ØØ 

(
ØØ 
propertyMap
ØØ 
==
ØØ 
null
ØØ 
)
ØØ  
{
∞∞ 	
propertyMap
±± 
=
±± 
new
±± 
(
±± !
destinationProperty
±± 1
,
±±1 2%
destinationPropertyType
±±3 J
,
±±J K
this
±±L P
)
±±P Q
;
±±Q R
AddPropertyMap
≤≤ 
(
≤≤ 
propertyMap
≤≤ &
)
≤≤& '
;
≤≤' (
}
≥≥ 	
return
¥¥ 
propertyMap
¥¥ 
;
¥¥ 
}
µµ 
private
∂∂ 
void
∂∂ 
CheckDifferent
∂∂ 
(
∂∂  
TypePair
∂∂  (
types
∂∂) .
)
∂∂. /
{
∑∑ 
if
∏∏ 

(
∏∏ 
types
∏∏ 
==
∏∏ 
Types
∏∏ 
)
∏∏ 
{
ππ 	
throw
∫∫ 
new
∫∫ '
InvalidOperationException
∫∫ /
(
∫∫/ 0
$"
∫∫0 2
$str
∫∫2 \
{
∫∫\ ]
Environment
∫∫] h
.
∫∫h i
NewLine
∫∫i p
}
∫∫p q
$str
∫∫q ~
{
∫∫~ 
types∫∫ Ñ
.∫∫Ñ Ö

SourceType∫∫Ö è
.∫∫è ê
FullName∫∫ê ò
}∫∫ò ô
{∫∫ô ö
Environment∫∫ö •
.∫∫• ¶
NewLine∫∫¶ ≠
}∫∫≠ Æ
$str∫∫Æ ¿
{∫∫¿ ¡
types∫∫¡ ∆
.∫∫∆ «
DestinationType∫∫« ÷
.∫∫÷ ◊
FullName∫∫◊ ﬂ
}∫∫ﬂ ‡
"∫∫‡ ·
)∫∫· ‚
;∫∫‚ „
}
ªª 	
}
ºº 
internal
ΩΩ 
void
ΩΩ 
IgnorePaths
ΩΩ 
(
ΩΩ 

MemberInfo
ΩΩ (
destinationMember
ΩΩ) :
)
ΩΩ: ;
{
ææ 
foreach
øø 
(
øø 
var
øø 
pathMap
øø 
in
øø 
PathMaps
øø  (
)
øø( )
{
¿¿ 	
if
¡¡ 
(
¡¡ 
pathMap
¡¡ 
.
¡¡ 

MemberPath
¡¡ "
.
¡¡" #
First
¡¡# (
==
¡¡) +
destinationMember
¡¡, =
)
¡¡= >
{
¬¬ 
pathMap
√√ 
.
√√ 
Ignored
√√ 
=
√√  !
true
√√" &
;
√√& '
}
ƒƒ 
}
≈≈ 	
}
∆∆ 
public
«« 

bool
«« &
HasDerivedTypesToInclude
«« (
=>
««) +"
IncludedDerivedTypes
««, @
.
««@ A
Count
««A F
>
««G H
$num
««I J
;
««J K
public
»» 

void
»» 
Seal
»» 
(
»» "
IGlobalConfiguration
»» )
configuration
»»* 7
)
»»7 8
{
…… 
if
   

(
   
_sealed
   
)
   
{
ÀÀ 	
return
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
_sealed
ŒŒ 
=
ŒŒ 
true
ŒŒ 
;
ŒŒ 
_details
œœ 
?
œœ 
.
œœ 
Seal
œœ 
(
œœ 
configuration
œœ $
,
œœ$ %
this
œœ& *
)
œœ* +
;
œœ+ ,
MapExpression
–– 
=
–– 

Projection
–– "
?
––# $
EmptyLambda
––% 0
:
––1 2 
CreateMapperLambda
––3 E
(
––E F
configuration
––F S
)
––S T
;
––T U
SourceTypeDetails
—— 
=
—— 
null
——  
;
——  !$
DestinationTypeDetails
““ 
=
““  
null
““! %
;
““% &
}
”” 
public
‘‘ 

List
‘‘ 
<
‘‘ 
PropertyMap
‘‘ 
>
‘‘ !
OrderedPropertyMaps
‘‘ 0
(
‘‘0 1
)
‘‘1 2
{
’’ 
if
÷÷ 

(
÷÷ 
HasMappingOrder
÷÷ 
(
÷÷ 
)
÷÷ 
)
÷÷ 
{
◊◊ 	
_propertyMaps
ÿÿ 
.
ÿÿ 
Sort
ÿÿ 
(
ÿÿ 
(
ÿÿ  
left
ÿÿ  $
,
ÿÿ$ %
right
ÿÿ& +
)
ÿÿ+ ,
=>
ÿÿ- /
Comparer
ÿÿ0 8
<
ÿÿ8 9
int
ÿÿ9 <
?
ÿÿ< =
>
ÿÿ= >
.
ÿÿ> ?
Default
ÿÿ? F
.
ÿÿF G
Compare
ÿÿG N
(
ÿÿN O
left
ÿÿO S
.
ÿÿS T
MappingOrder
ÿÿT `
,
ÿÿ` a
right
ÿÿb g
.
ÿÿg h
MappingOrder
ÿÿh t
)
ÿÿt u
)
ÿÿu v
;
ÿÿv w
}
ŸŸ 	
return
⁄⁄ 
_propertyMaps
⁄⁄ 
;
⁄⁄ 
bool
€€ 
HasMappingOrder
€€ 
(
€€ 
)
€€ 
{
‹‹ 	
if
›› 
(
›› 
_propertyMaps
›› 
==
››  
null
››! %
)
››% &
{
ﬁﬁ 
return
ﬂﬂ 
false
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
foreach
·· 
(
·· 
var
·· 
propertyMap
·· $
in
··% '
_propertyMaps
··( 5
)
··5 6
{
‚‚ 
if
„„ 
(
„„ 
propertyMap
„„ 
.
„„  
MappingOrder
„„  ,
!=
„„- /
null
„„0 4
)
„„4 5
{
‰‰ 
return
ÂÂ 
true
ÂÂ 
;
ÂÂ  
}
ÊÊ 
}
ÁÁ 
return
ËË 
false
ËË 
;
ËË 
}
ÈÈ 	
}
ÍÍ 
public
ÎÎ 

void
ÎÎ !
IncludeDerivedTypes
ÎÎ #
(
ÎÎ# $
TypePair
ÎÎ$ ,
derivedTypes
ÎÎ- 9
)
ÎÎ9 :
{
ÏÏ 
CheckDifferent
ÌÌ 
(
ÌÌ 
derivedTypes
ÌÌ #
)
ÌÌ# $
;
ÌÌ$ %
Details
ÓÓ 
.
ÓÓ !
IncludeDerivedTypes
ÓÓ #
(
ÓÓ# $
derivedTypes
ÓÓ$ 0
)
ÓÓ0 1
;
ÓÓ1 2
}
ÔÔ 
public
 

void
 
IncludeBaseTypes
  
(
  !
TypePair
! )
	baseTypes
* 3
)
3 4
{
ÒÒ 
CheckDifferent
ÚÚ 
(
ÚÚ 
	baseTypes
ÚÚ  
)
ÚÚ  !
;
ÚÚ! "
Details
ÛÛ 
.
ÛÛ 
IncludeBaseTypes
ÛÛ  
(
ÛÛ  !
	baseTypes
ÛÛ! *
)
ÛÛ* +
;
ÛÛ+ ,
}
ÙÙ 
public
ıı 

void
ıı  
AddBeforeMapAction
ıı "
(
ıı" #
LambdaExpression
ıı# 3
	beforeMap
ıı4 =
)
ıı= >
=>
ıı? A
Details
ııB I
.
ııI J 
AddBeforeMapAction
ııJ \
(
ıı\ ]
	beforeMap
ıı] f
)
ııf g
;
ııg h
public
ˆˆ 

void
ˆˆ 
AddAfterMapAction
ˆˆ !
(
ˆˆ! "
LambdaExpression
ˆˆ" 2
afterMap
ˆˆ3 ;
)
ˆˆ; <
=>
ˆˆ= ?
Details
ˆˆ@ G
.
ˆˆG H
AddAfterMapAction
ˆˆH Y
(
ˆˆY Z
afterMap
ˆˆZ b
)
ˆˆb c
;
ˆˆc d
public
˜˜ 

void
˜˜ $
AddValueTransformation
˜˜ &
(
˜˜& '+
ValueTransformerConfiguration
˜˜' D
config
˜˜E K
)
˜˜K L
=>
˜˜M O
Details
˜˜P W
.
˜˜W X$
AddValueTransformation
˜˜X n
(
˜˜n o
config
˜˜o u
)
˜˜u v
;
˜˜v w
public
¯¯ 

void
¯¯ *
ConstructUsingServiceLocator
¯¯ ,
(
¯¯, -
)
¯¯- .
=>
¯¯/ 1 
CustomCtorFunction
¯¯2 D
=
¯¯E F
Lambda
¯¯G M
(
¯¯M N
ServiceLocator
¯¯N \
(
¯¯\ ]
DestinationType
¯¯] l
)
¯¯l m
)
¯¯m n
;
¯¯n o
internal
˘˘ 
LambdaExpression
˘˘  
CreateMapperLambda
˘˘ 0
(
˘˘0 1"
IGlobalConfiguration
˘˘1 E
configuration
˘˘F S
)
˘˘S T
=>
˘˘U W
Types
˙˙ 
.
˙˙ '
ContainsGenericParameters
˙˙ '
?
˙˙( )
null
˙˙* .
:
˙˙/ 0
new
˙˙1 4 
TypeMapPlanBuilder
˙˙5 G
(
˙˙G H
configuration
˙˙H U
,
˙˙U V
this
˙˙W [
)
˙˙[ \
.
˙˙\ ] 
CreateMapperLambda
˙˙] o
(
˙˙o p
)
˙˙p q
;
˙˙q r
private
˚˚ 
PropertyMap
˚˚ 
GetPropertyMap
˚˚ &
(
˚˚& '
string
˚˚' -
name
˚˚. 2
)
˚˚2 3
{
¸¸ 
if
˝˝ 

(
˝˝ 
_propertyMaps
˝˝ 
==
˝˝ 
null
˝˝ !
)
˝˝! "
{
˛˛ 	
return
ˇˇ 
null
ˇˇ 
;
ˇˇ 
}
ÄÄ 	
foreach
ÅÅ 
(
ÅÅ 
var
ÅÅ 
propertyMap
ÅÅ  
in
ÅÅ! #
_propertyMaps
ÅÅ$ 1
)
ÅÅ1 2
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
propertyMap
ÉÉ 
.
ÉÉ 
DestinationName
ÉÉ +
==
ÉÉ, .
name
ÉÉ/ 3
)
ÉÉ3 4
{
ÑÑ 
return
ÖÖ 
propertyMap
ÖÖ "
;
ÖÖ" #
}
ÜÜ 
}
áá 	
return
àà 
null
àà 
;
àà 
}
ââ 
private
ää 
PropertyMap
ää 
GetPropertyMap
ää &
(
ää& '
PropertyMap
ää' 2
propertyMap
ää3 >
)
ää> ?
=>
ää@ B
GetPropertyMap
ääC Q
(
ääQ R
propertyMap
ääR ]
.
ää] ^
DestinationName
ää^ m
)
ääm n
;
ään o
public
ãã 

void
ãã 
AsProxy
ãã 
(
ãã 
)
ãã 
=>
ãã  
CustomCtorFunction
ãã /
=
ãã0 1
Lambda
ãã2 8
(
ãã8 9
Call
ãã9 =
(
ãã= >
CreateProxyMethod
ãã> O
,
ããO P
Constant
ããQ Y
(
ããY Z
DestinationType
ããZ i
)
ããi j
)
ããj k
)
ããk l
;
ããl m
internal
åå 
void
åå !
CopyInheritedMapsTo
åå %
(
åå% &
TypeMap
åå& -
typeMap
åå. 5
)
åå5 6
{
çç 
if
éé 

(
éé 
_details
éé 
?
éé 
.
éé 
InheritedTypeMaps
éé '
==
éé( *
null
éé+ /
)
éé/ 0
{
èè 	
return
êê 
;
êê 
}
ëë 	
_details
íí 
.
íí !
CopyInheritedMapsTo
íí $
(
íí$ %
typeMap
íí% ,
)
íí, -
;
íí- .
}
ìì 
public
îî 

void
îî 
CloseGenerics
îî 
(
îî "
TypeMapConfiguration
îî 2
openMapConfig
îî3 @
,
îî@ A
TypePair
îîB J
closedTypes
îîK V
)
îîV W
=>
îîX Z
TypeConverter
îî[ h
?
îîh i
.
îîi j
CloseGenerics
îîj w
(
îîw x
openMapConfigîîx Ö
,îîÖ Ü
closedTypesîîá í
)îîí ì
;îîì î
public
ïï 

bool
ïï 
AddMemberMap
ïï 
(
ïï 
IncludedMember
ïï +
includedMember
ïï, :
)
ïï: ;
=>
ïï< >
Details
ïï? F
.
ïïF G
AddMemberMap
ïïG S
(
ïïS T
includedMember
ïïT b
)
ïïb c
;
ïïc d
public
ññ 

PathMap
ññ $
FindOrCreatePathMapFor
ññ )
(
ññ) *
LambdaExpression
ññ* :#
destinationExpression
ññ; P
,
ññP Q

MemberPath
ññR \
path
ññ] a
,
ñña b
TypeMap
ññc j
typeMap
ññk r
)
ññr s
=>
ññt v
Details
óó 
.
óó $
FindOrCreatePathMapFor
óó &
(
óó& '#
destinationExpression
óó' <
,
óó< =
path
óó> B
,
óóB C
typeMap
óóD K
)
óóK L
;
óóL M
public
òò 

void
òò 
AddInheritedMap
òò 
(
òò  
TypeMap
òò  '
inheritedTypeMap
òò( 8
)
òò8 9
=>
òò: <
Details
òò= D
.
òòD E
AddInheritedMap
òòE T
(
òòT U
inheritedTypeMap
òòU e
)
òòe f
;
òòf g
public
ôô 
 
SourceMemberConfig
ôô /
!FindOrCreateSourceMemberConfigFor
ôô ?
(
ôô? @

MemberInfo
ôô@ J
sourceMember
ôôK W
)
ôôW X
=>
ôôY [
Details
ôô\ c
.
ôôc d0
!FindOrCreateSourceMemberConfigForôôd Ö
(ôôÖ Ü
sourceMemberôôÜ í
)ôôí ì
;ôôì î
class
öö 	
TypeMapDetails
öö
 
{
õõ 
Features
úú 
<
úú 
IRuntimeFeature
úú  
>
úú  !
	_features
úú" +
;
úú+ ,
public
ùù 
bool
ùù  
PreserveReferences
ùù &
;
ùù& '
public
ûû 
LambdaExpression
ûû 
[
ûû  
]
ûû  !
IncludedMembers
ûû" 1
;
ûû1 2
public
üü 
string
üü 
[
üü 
]
üü "
IncludedMembersNames
üü ,
;
üü, -
public
†† 
bool
†† *
DisableConstructorValidation
†† 0
;
††0 1
public
°° 
int
°° 
MaxDepth
°° 
;
°° 
public
¢¢ 
bool
¢¢ $
IncludeAllDerivedTypes
¢¢ *
;
¢¢* +
public
££ 
LambdaExpression
££  
CustomCtorFunction
££  2
;
££2 3
public
§§ 

MemberList
§§ "
ConfiguredMemberList
§§ .
;
§§. /
public
•• 
List
•• 
<
•• 
LambdaExpression
•• $
>
••$ %
AfterMapActions
••& 5
{
••6 7
get
••8 ;
;
••; <
private
••= D
set
••E H
;
••H I
}
••J K
public
¶¶ 
List
¶¶ 
<
¶¶ 
LambdaExpression
¶¶ $
>
¶¶$ %
BeforeMapActions
¶¶& 6
{
¶¶7 8
get
¶¶9 <
;
¶¶< =
private
¶¶> E
set
¶¶F I
;
¶¶I J
}
¶¶K L
public
ßß 
List
ßß 
<
ßß 
TypePair
ßß 
>
ßß "
IncludedDerivedTypes
ßß 2
{
ßß3 4
get
ßß5 8
;
ßß8 9
private
ßß: A
set
ßßB E
;
ßßE F
}
ßßG H
public
®® 
List
®® 
<
®® 
TypePair
®® 
>
®® 
IncludedBaseTypes
®® /
{
®®0 1
get
®®2 5
;
®®5 6
private
®®7 >
set
®®? B
;
®®B C
}
®®D E
public
©© 
List
©© 
<
©© 
TypeMap
©© 
>
©© 
InheritedTypeMaps
©© .
{
©©/ 0
get
©©1 4
;
©©4 5
private
©©6 =
set
©©> A
;
©©A B
}
©©C D
public
™™ 
List
™™ 
<
™™ 
IncludedMember
™™ "
>
™™" #%
IncludedMembersTypeMaps
™™$ ;
{
™™< =
get
™™> A
;
™™A B
private
™™C J
set
™™K N
;
™™N O
}
™™P Q
public
´´ 
List
´´ 
<
´´ 
PathMap
´´ 
>
´´ 
PathMaps
´´ %
{
´´& '
get
´´( +
;
´´+ ,
private
´´- 4
set
´´5 8
;
´´8 9
}
´´: ;
public
¨¨ 
List
¨¨ 
<
¨¨  
SourceMemberConfig
¨¨ &
>
¨¨& '!
SourceMemberConfigs
¨¨( ;
{
¨¨< =
get
¨¨> A
;
¨¨A B
private
¨¨C J
set
¨¨K N
;
¨¨N O
}
¨¨P Q
public
≠≠ 
List
≠≠ 
<
≠≠ +
ValueTransformerConfiguration
≠≠ 1
>
≠≠1 2%
ValueTransformerConfigs
≠≠3 J
{
≠≠K L
get
≠≠M P
;
≠≠P Q
private
≠≠R Y
set
≠≠Z ]
;
≠≠] ^
}
≠≠_ `
public
ÆÆ 
Features
ÆÆ 
<
ÆÆ 
IRuntimeFeature
ÆÆ '
>
ÆÆ' (
Features
ÆÆ) 1
=>
ÆÆ2 4
	_features
ÆÆ5 >
??=
ÆÆ? B
new
ÆÆC F
(
ÆÆF G
)
ÆÆG H
;
ÆÆH I
public
ØØ 
void
ØØ 
Seal
ØØ 
(
ØØ "
IGlobalConfiguration
ØØ -
configuration
ØØ. ;
,
ØØ; <
TypeMap
ØØ= D
thisMap
ØØE L
)
ØØL M
{
∞∞ 	
if
±± 
(
±± 
InheritedTypeMaps
±± !
!=
±±" $
null
±±% )
)
±±) *
{
≤≤ 
foreach
≥≥ 
(
≥≥ 
var
≥≥ 
inheritedTypeMap
≥≥ -
in
≥≥. 0
InheritedTypeMaps
≥≥1 B
)
≥≥B C
{
¥¥ 
inheritedTypeMap
µµ $
.
µµ$ %
Seal
µµ% )
(
µµ) *
configuration
µµ* 7
)
µµ7 8
;
µµ8 9
var
∂∂ 
includedMaps
∂∂ $
=
∂∂% &
inheritedTypeMap
∂∂' 7
.
∂∂7 8
_details
∂∂8 @
?
∂∂@ A
.
∂∂A B%
IncludedMembersTypeMaps
∂∂B Y
;
∂∂Y Z
if
∑∑ 
(
∑∑ 
includedMaps
∑∑ $
!=
∑∑% '
null
∑∑( ,
)
∑∑, -
{
∏∏ %
IncludedMembersTypeMaps
ππ /
??=
ππ0 3
[
ππ4 5
]
ππ5 6
;
ππ6 7%
IncludedMembersTypeMaps
∫∫ /
.
∫∫/ 0
TryAdd
∫∫0 6
(
∫∫6 7
includedMaps
∫∫7 C
)
∫∫C D
;
∫∫D E
}
ªª 
}
ºº 
}
ΩΩ 
if
ææ 
(
ææ %
IncludedMembersTypeMaps
ææ '
!=
ææ( *
null
ææ+ /
)
ææ/ 0
{
øø 
foreach
¿¿ 
(
¿¿ 
var
¿¿ #
includedMemberTypeMap
¿¿ 2
in
¿¿3 5%
IncludedMembersTypeMaps
¿¿6 M
)
¿¿M N
{
¡¡ #
includedMemberTypeMap
¬¬ )
.
¬¬) *
TypeMap
¬¬* 1
.
¬¬1 2
Seal
¬¬2 6
(
¬¬6 7
configuration
¬¬7 D
)
¬¬D E
;
¬¬E F(
ApplyIncludedMemberTypeMap
√√ .
(
√√. /#
includedMemberTypeMap
√√/ D
,
√√D E
thisMap
√√F M
)
√√M N
;
√√N O
}
ƒƒ 
}
≈≈ 
if
∆∆ 
(
∆∆ 
InheritedTypeMaps
∆∆ !
!=
∆∆" $
null
∆∆% )
)
∆∆) *
{
«« 
foreach
»» 
(
»» 
var
»» 
inheritedTypeMap
»» -
in
»». 0
InheritedTypeMaps
»»1 B
)
»»B C
{
…… #
ApplyInheritedTypeMap
   )
(
  ) *
inheritedTypeMap
  * :
,
  : ;
thisMap
  < C
)
  C D
;
  D E
}
ÀÀ 
}
ÃÃ 
	_features
ÕÕ 
?
ÕÕ 
.
ÕÕ 
Seal
ÕÕ 
(
ÕÕ 
configuration
ÕÕ )
)
ÕÕ) *
;
ÕÕ* +
}
ŒŒ 	
public
œœ 
void
œœ !
IncludeDerivedTypes
œœ '
(
œœ' (
TypePair
œœ( 0
derivedTypes
œœ1 =
)
œœ= >
{
–– 	"
IncludedDerivedTypes
——  
??=
——! $
[
——% &
]
——& '
;
——' ("
IncludedDerivedTypes
““  
.
““  !
TryAdd
““! '
(
““' (
derivedTypes
““( 4
)
““4 5
;
““5 6
}
”” 	
public
‘‘ 
void
‘‘  
AddBeforeMapAction
‘‘ &
(
‘‘& '
LambdaExpression
‘‘' 7
	beforeMap
‘‘8 A
)
‘‘A B
{
’’ 	
BeforeMapActions
÷÷ 
??=
÷÷  
[
÷÷! "
]
÷÷" #
;
÷÷# $
BeforeMapActions
◊◊ 
.
◊◊ 
TryAdd
◊◊ #
(
◊◊# $
	beforeMap
◊◊$ -
)
◊◊- .
;
◊◊. /
}
ÿÿ 	
public
ŸŸ 
void
ŸŸ 
AddAfterMapAction
ŸŸ %
(
ŸŸ% &
LambdaExpression
ŸŸ& 6
afterMap
ŸŸ7 ?
)
ŸŸ? @
{
⁄⁄ 	
AfterMapActions
€€ 
??=
€€ 
[
€€  !
]
€€! "
;
€€" #
AfterMapActions
‹‹ 
.
‹‹ 
TryAdd
‹‹ "
(
‹‹" #
afterMap
‹‹# +
)
‹‹+ ,
;
‹‹, -
}
›› 	
public
ﬁﬁ 
void
ﬁﬁ $
AddValueTransformation
ﬁﬁ *
(
ﬁﬁ* ++
ValueTransformerConfiguration
ﬁﬁ+ H+
valueTransformerConfiguration
ﬁﬁI f
)
ﬁﬁf g
{
ﬂﬂ 	%
ValueTransformerConfigs
‡‡ #
??=
‡‡$ '
[
‡‡( )
]
‡‡) *
;
‡‡* +%
ValueTransformerConfigs
·· #
.
··# $
Add
··$ '
(
··' (+
valueTransformerConfiguration
··( E
)
··E F
;
··F G
}
‚‚ 	
public
„„ 
PathMap
„„ $
FindOrCreatePathMapFor
„„ -
(
„„- .
LambdaExpression
„„. >#
destinationExpression
„„? T
,
„„T U

MemberPath
„„V `
path
„„a e
,
„„e f
TypeMap
„„g n
typeMap
„„o v
)
„„v w
{
‰‰ 	
PathMaps
ÂÂ 
??=
ÂÂ 
[
ÂÂ 
]
ÂÂ 
;
ÂÂ 
var
ÊÊ 
pathMap
ÊÊ 
=
ÊÊ 

GetPathMap
ÊÊ $
(
ÊÊ$ %
path
ÊÊ% )
)
ÊÊ) *
;
ÊÊ* +
if
ÁÁ 
(
ÁÁ 
pathMap
ÁÁ 
==
ÁÁ 
null
ÁÁ 
)
ÁÁ  
{
ËË 
pathMap
ÈÈ 
=
ÈÈ 
new
ÈÈ 
(
ÈÈ #
destinationExpression
ÈÈ 3
,
ÈÈ3 4
path
ÈÈ5 9
,
ÈÈ9 :
typeMap
ÈÈ; B
)
ÈÈB C
;
ÈÈC D

AddPathMap
ÍÍ 
(
ÍÍ 
pathMap
ÍÍ "
)
ÍÍ" #
;
ÍÍ# $
}
ÎÎ 
return
ÏÏ 
pathMap
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
private
ÓÓ 
PathMap
ÓÓ 

GetPathMap
ÓÓ "
(
ÓÓ" #

MemberPath
ÓÓ# -

memberPath
ÓÓ. 8
)
ÓÓ8 9
{
ÔÔ 	
if
 
(
 
PathMaps
 
==
 
null
  
)
  !
{
ÒÒ 
return
ÚÚ 
null
ÚÚ 
;
ÚÚ 
}
ÛÛ 
foreach
ÙÙ 
(
ÙÙ 
var
ÙÙ 
pathMap
ÙÙ  
in
ÙÙ! #
PathMaps
ÙÙ$ ,
)
ÙÙ, -
{
ıı 
if
ˆˆ 
(
ˆˆ 
pathMap
ˆˆ 
.
ˆˆ 

MemberPath
ˆˆ &
==
ˆˆ' )

memberPath
ˆˆ* 4
)
ˆˆ4 5
{
˜˜ 
return
¯¯ 
pathMap
¯¯ "
;
¯¯" #
}
˘˘ 
}
˙˙ 
return
˚˚ 
null
˚˚ 
;
˚˚ 
}
¸¸ 	
private
˝˝ 
void
˝˝ 

AddPathMap
˝˝ 
(
˝˝  
PathMap
˝˝  '
pathMap
˝˝( /
)
˝˝/ 0
=>
˝˝1 3
PathMaps
˝˝4 <
.
˝˝< =
Add
˝˝= @
(
˝˝@ A
pathMap
˝˝A H
)
˝˝H I
;
˝˝I J
public
˛˛ 
void
˛˛ 
IncludeBaseTypes
˛˛ $
(
˛˛$ %
TypePair
˛˛% -
	baseTypes
˛˛. 7
)
˛˛7 8
{
ˇˇ 	
IncludedBaseTypes
ÄÄ 
??=
ÄÄ !
[
ÄÄ" #
]
ÄÄ# $
;
ÄÄ$ %
IncludedBaseTypes
ÅÅ 
.
ÅÅ 
TryAdd
ÅÅ $
(
ÅÅ$ %
	baseTypes
ÅÅ% .
)
ÅÅ. /
;
ÅÅ/ 0
}
ÇÇ 	
internal
ÉÉ 
void
ÉÉ !
CopyInheritedMapsTo
ÉÉ )
(
ÉÉ) *
TypeMap
ÉÉ* 1
typeMap
ÉÉ2 9
)
ÉÉ9 :
{
ÑÑ 	
typeMap
ÖÖ 
.
ÖÖ 
Details
ÖÖ 
.
ÖÖ 
InheritedTypeMaps
ÖÖ -
??=
ÖÖ. 1
[
ÖÖ2 3
]
ÖÖ3 4
;
ÖÖ4 5
typeMap
ÜÜ 
.
ÜÜ 
_details
ÜÜ 
.
ÜÜ 
InheritedTypeMaps
ÜÜ .
.
ÜÜ. /
TryAdd
ÜÜ/ 5
(
ÜÜ5 6
InheritedTypeMaps
ÜÜ6 G
)
ÜÜG H
;
ÜÜH I
}
áá 	
public
àà 
bool
àà 
AddMemberMap
àà  
(
àà  !
IncludedMember
àà! /
includedMember
àà0 >
)
àà> ?
{
ââ 	%
IncludedMembersTypeMaps
ää #
??=
ää$ '
[
ää( )
]
ää) *
;
ää* +
return
ãã %
IncludedMembersTypeMaps
ãã *
.
ãã* +
TryAdd
ãã+ 1
(
ãã1 2
includedMember
ãã2 @
)
ãã@ A
;
ããA B
}
åå 	
public
çç  
SourceMemberConfig
çç !/
!FindOrCreateSourceMemberConfigFor
çç" C
(
ççC D

MemberInfo
ççD N
sourceMember
ççO [
)
çç[ \
{
éé 	!
SourceMemberConfigs
èè 
??=
èè  #
[
èè$ %
]
èè% &
;
èè& '
var
êê 
config
êê 
=
êê #
GetSourceMemberConfig
êê .
(
êê. /
sourceMember
êê/ ;
)
êê; <
;
êê< =
if
ëë 
(
ëë 
config
ëë 
==
ëë 
null
ëë 
)
ëë 
{
íí 
config
ìì 
=
ìì 
new
ìì 
(
ìì 
sourceMember
ìì )
)
ìì) *
;
ìì* +!
SourceMemberConfigs
îî #
.
îî# $
Add
îî$ '
(
îî' (
config
îî( .
)
îî. /
;
îî/ 0
}
ïï 
return
ññ 
config
ññ 
;
ññ 
}
óó 	
private
òò  
SourceMemberConfig
òò "#
GetSourceMemberConfig
òò# 8
(
òò8 9

MemberInfo
òò9 C
sourceMember
òòD P
)
òòP Q
{
ôô 	
foreach
öö 
(
öö 
var
öö 
sourceConfig
öö %
in
öö& (!
SourceMemberConfigs
öö) <
)
öö< =
{
õõ 
if
úú 
(
úú 
sourceConfig
úú  
.
úú  !
SourceMember
úú! -
==
úú. 0
sourceMember
úú1 =
)
úú= >
{
ùù 
return
ûû 
sourceConfig
ûû '
;
ûû' (
}
üü 
}
†† 
return
°° 
null
°° 
;
°° 
}
¢¢ 	
public
££ 
void
££ 
AddInheritedMap
££ #
(
££# $
TypeMap
££$ +
inheritedTypeMap
££, <
)
££< =
{
§§ 	
InheritedTypeMaps
•• 
??=
•• !
[
••" #
]
••# $
;
••$ %
InheritedTypeMaps
¶¶ 
.
¶¶ 
TryAdd
¶¶ $
(
¶¶$ %
inheritedTypeMap
¶¶% 5
)
¶¶5 6
;
¶¶6 7
}
ßß 	
private
®® 
void
®® (
ApplyIncludedMemberTypeMap
®® /
(
®®/ 0
IncludedMember
®®0 >
includedMember
®®? M
,
®®M N
TypeMap
®®O V
thisMap
®®W ^
)
®®^ _
{
©© 	
var
™™ 
typeMap
™™ 
=
™™ 
includedMember
™™ (
.
™™( )
TypeMap
™™) 0
;
™™0 1
var
´´  
includedMemberMaps
´´ "
=
´´# $
typeMap
´´% ,
.
´´, -
PropertyMaps
´´- 9
.
´´9 :
Where
¨¨ 
(
¨¨ 
m
¨¨ 
=>
¨¨ 
m
¨¨ 
.
¨¨ 
CanResolveValue
¨¨ ,
&&
¨¨- /
thisMap
¨¨0 7
.
¨¨7 8
GetPropertyMap
¨¨8 F
(
¨¨F G
m
¨¨G H
)
¨¨H I
==
¨¨J L
null
¨¨M Q
)
¨¨Q R
.
≠≠ 
Select
≠≠ 
(
≠≠ 
p
≠≠ 
=>
≠≠ 
new
≠≠  
PropertyMap
≠≠! ,
(
≠≠, -
p
≠≠- .
,
≠≠. /
thisMap
≠≠0 7
,
≠≠7 8
includedMember
≠≠9 G
)
≠≠G H
)
≠≠H I
.
ÆÆ 
ToArray
ÆÆ 
(
ÆÆ 
)
ÆÆ 
;
ÆÆ 
var
ØØ "
notOverridenPathMaps
ØØ $
=
ØØ% &"
NotOverridenPathMaps
ØØ' ;
(
ØØ; <
typeMap
ØØ< C
)
ØØC D
;
ØØD E
var
∞∞ #
appliedConstructorMap
∞∞ %
=
∞∞& '
thisMap
∞∞( /
.
∞∞/ 0
ConstructorMap
∞∞0 >
?
∞∞> ?
.
∞∞? @
ApplyMap
∞∞@ H
(
∞∞H I
typeMap
∞∞I P
,
∞∞P Q
includedMember
∞∞R `
)
∞∞` a
;
∞∞a b
if
±± 
(
±±  
includedMemberMaps
±± "
.
±±" #
Length
±±# )
==
±±* ,
$num
±±- .
&&
±±/ 1"
notOverridenPathMaps
±±2 F
.
±±F G
Length
±±G M
==
±±N P
$num
±±Q R
&&
±±S U#
appliedConstructorMap
±±V k
is
±±l n
not
±±o r
true
±±s w
)
±±w x
{
≤≤ 
return
≥≥ 
;
≥≥ 
}
¥¥ 
foreach
µµ 
(
µµ 
var
µµ 
includedMemberMap
µµ *
in
µµ+ - 
includedMemberMaps
µµ. @
)
µµ@ A
{
∂∂ 
thisMap
∑∑ 
.
∑∑ 
AddPropertyMap
∑∑ &
(
∑∑& '
includedMemberMap
∑∑' 8
)
∑∑8 9
;
∑∑9 :
foreach
∏∏ 
(
∏∏ 
var
∏∏ 
transformer
∏∏ (
in
∏∏) +
typeMap
∏∏, 3
.
∏∏3 4
ValueTransformers
∏∏4 E
)
∏∏E F
{
ππ 
includedMemberMap
∫∫ %
.
∫∫% &$
AddValueTransformation
∫∫& <
(
∫∫< =
transformer
∫∫= H
)
∫∫H I
;
∫∫I J
}
ªª 
}
ºº 
var
ΩΩ 
details
ΩΩ 
=
ΩΩ 
typeMap
ΩΩ !
.
ΩΩ! "
_details
ΩΩ" *
;
ΩΩ* +
if
ææ 
(
ææ 
details
ææ 
!=
ææ 
null
ææ 
)
ææ  
{
øø &
ApplyInheritedMapActions
¿¿ (
(
¿¿( )
details
¿¿) 0
.
¿¿0 1
BeforeMapActions
¿¿1 A
?
¿¿A B
.
¿¿B C
Select
¿¿C I
(
¿¿I J
includedMember
¿¿J X
.
¿¿X Y
Chain
¿¿Y ^
)
¿¿^ _
,
¿¿_ `
details
¿¿a h
.
¿¿h i
AfterMapActions
¿¿i x
?
¿¿x y
.
¿¿y z
Select¿¿z Ä
(¿¿Ä Å
includedMember¿¿Å è
.¿¿è ê
Chain¿¿ê ï
)¿¿ï ñ
)¿¿ñ ó
;¿¿ó ò
}
¡¡ 
foreach
¬¬ 
(
¬¬ 
var
¬¬ !
notOverridenPathMap
¬¬ ,
in
¬¬- /"
notOverridenPathMaps
¬¬0 D
)
¬¬D E
{
√√ 

AddPathMap
ƒƒ 
(
ƒƒ 
new
ƒƒ 
(
ƒƒ !
notOverridenPathMap
ƒƒ 2
,
ƒƒ2 3
thisMap
ƒƒ4 ;
,
ƒƒ; <
includedMember
ƒƒ= K
)
ƒƒK L
)
ƒƒL M
;
ƒƒM N
}
≈≈ 
}
∆∆ 	
private
«« 
void
«« #
ApplyInheritedTypeMap
«« *
(
««* +
TypeMap
««+ 2
inheritedTypeMap
««3 C
,
««C D
TypeMap
««E L
thisMap
««M T
)
««T U
{
»» 	
if
…… 
(
…… 
inheritedTypeMap
……  
.
……  !
_propertyMaps
……! .
!=
……/ 1
null
……2 6
)
……6 7
{
   (
ApplyInheritedPropertyMaps
ÀÀ *
(
ÀÀ* +
inheritedTypeMap
ÀÀ+ ;
,
ÀÀ; <
thisMap
ÀÀ= D
)
ÀÀD E
;
ÀÀE F
}
ÃÃ 
thisMap
ÕÕ 
.
ÕÕ 
ConstructorMap
ÕÕ "
?
ÕÕ" #
.
ÕÕ# $
ApplyMap
ÕÕ$ ,
(
ÕÕ, -
inheritedTypeMap
ÕÕ- =
)
ÕÕ= >
;
ÕÕ> ?
var
ŒŒ 
inheritedDetails
ŒŒ  
=
ŒŒ! "
inheritedTypeMap
ŒŒ# 3
.
ŒŒ3 4
_details
ŒŒ4 <
;
ŒŒ< =
if
œœ 
(
œœ 
inheritedDetails
œœ  
==
œœ! #
null
œœ$ (
)
œœ( )
{
–– 
return
—— 
;
—— 
}
““ &
ApplyInheritedMapActions
”” $
(
””$ %
inheritedDetails
””% 5
.
””5 6
BeforeMapActions
””6 F
,
””F G
inheritedDetails
””H X
.
””X Y
AfterMapActions
””Y h
)
””h i
;
””i j
if
‘‘ 
(
‘‘ 
inheritedDetails
‘‘  
.
‘‘  !!
SourceMemberConfigs
‘‘! 4
!=
‘‘5 7
null
‘‘8 <
)
‘‘< =
{
’’ )
ApplyInheritedSourceMembers
÷÷ +
(
÷÷+ ,
inheritedTypeMap
÷÷, <
.
÷÷< =
_details
÷÷= E
)
÷÷E F
;
÷÷F G
}
◊◊ 
var
ÿÿ "
notOverridenPathMaps
ÿÿ $
=
ÿÿ% &"
NotOverridenPathMaps
ÿÿ' ;
(
ÿÿ; <
inheritedTypeMap
ÿÿ< L
)
ÿÿL M
;
ÿÿM N
foreach
ŸŸ 
(
ŸŸ 
var
ŸŸ !
notOverridenPathMap
ŸŸ ,
in
ŸŸ- /"
notOverridenPathMaps
ŸŸ0 D
)
ŸŸD E
{
⁄⁄ 

AddPathMap
€€ 
(
€€ !
notOverridenPathMap
€€ .
)
€€. /
;
€€/ 0
}
‹‹ 
if
›› 
(
›› 
inheritedDetails
››  
.
››  !%
ValueTransformerConfigs
››! 8
!=
››9 ;
null
››< @
)
››@ A
{
ﬁﬁ %
ValueTransformerConfigs
ﬂﬂ '
??=
ﬂﬂ( +
[
ﬂﬂ, -
]
ﬂﬂ- .
;
ﬂﬂ. /%
ValueTransformerConfigs
‡‡ '
.
‡‡' (
InsertRange
‡‡( 3
(
‡‡3 4
$num
‡‡4 5
,
‡‡5 6
inheritedDetails
‡‡7 G
.
‡‡G H%
ValueTransformerConfigs
‡‡H _
)
‡‡_ `
;
‡‡` a
}
·· 
return
‚‚ 
;
‚‚ 
void
„„ (
ApplyInheritedPropertyMaps
„„ +
(
„„+ ,
TypeMap
„„, 3
inheritedTypeMap
„„4 D
,
„„D E
TypeMap
„„F M
thisMap
„„N U
)
„„U V
{
‰‰ 
foreach
ÂÂ 
(
ÂÂ 
var
ÂÂ %
inheritedMappedProperty
ÂÂ 4
in
ÂÂ5 7
inheritedTypeMap
ÂÂ8 H
.
ÂÂH I
_propertyMaps
ÂÂI V
)
ÂÂV W
{
ÊÊ 
if
ÁÁ 
(
ÁÁ 
!
ÁÁ %
inheritedMappedProperty
ÁÁ 0
.
ÁÁ0 1
IsMapped
ÁÁ1 9
)
ÁÁ9 :
{
ËË 
continue
ÈÈ  
;
ÈÈ  !
}
ÍÍ 
var
ÎÎ #
conventionPropertyMap
ÎÎ -
=
ÎÎ. /
thisMap
ÎÎ0 7
.
ÎÎ7 8
GetPropertyMap
ÎÎ8 F
(
ÎÎF G%
inheritedMappedProperty
ÎÎG ^
)
ÎÎ^ _
;
ÎÎ_ `
if
ÏÏ 
(
ÏÏ #
conventionPropertyMap
ÏÏ -
!=
ÏÏ. 0
null
ÏÏ1 5
)
ÏÏ5 6
{
ÌÌ #
conventionPropertyMap
ÓÓ -
.
ÓÓ- .'
ApplyInheritedPropertyMap
ÓÓ. G
(
ÓÓG H%
inheritedMappedProperty
ÓÓH _
)
ÓÓ_ `
;
ÓÓ` a
}
ÔÔ 
else
 
{
ÒÒ 
thisMap
ÚÚ 
.
ÚÚ  
AddPropertyMap
ÚÚ  .
(
ÚÚ. /
new
ÚÚ/ 2
(
ÚÚ2 3%
inheritedMappedProperty
ÚÚ3 J
,
ÚÚJ K
thisMap
ÚÚL S
)
ÚÚS T
)
ÚÚT U
;
ÚÚU V
}
ÛÛ 
}
ÙÙ 
}
ıı 
void
ˆˆ )
ApplyInheritedSourceMembers
ˆˆ ,
(
ˆˆ, -
TypeMapDetails
ˆˆ- ;
inheritedTypeMap
ˆˆ< L
)
ˆˆL M
{
˜˜ !
SourceMemberConfigs
¯¯ #
??=
¯¯$ '
[
¯¯( )
]
¯¯) *
;
¯¯* +
foreach
˘˘ 
(
˘˘ 
var
˘˘ #
inheritedSourceConfig
˘˘ 2
in
˘˘3 5
inheritedTypeMap
˘˘6 F
.
˘˘F G!
SourceMemberConfigs
˘˘G Z
)
˘˘Z [
{
˙˙ 
if
˚˚ 
(
˚˚ #
GetSourceMemberConfig
˚˚ -
(
˚˚- .#
inheritedSourceConfig
˚˚. C
.
˚˚C D
SourceMember
˚˚D P
)
˚˚P Q
==
˚˚R T
null
˚˚U Y
)
˚˚Y Z
{
¸¸ !
SourceMemberConfigs
˝˝ +
.
˝˝+ ,
Add
˝˝, /
(
˝˝/ 0#
inheritedSourceConfig
˝˝0 E
)
˝˝E F
;
˝˝F G
}
˛˛ 
}
ˇˇ 
}
ÄÄ 
}
ÅÅ 	
void
ÇÇ &
ApplyInheritedMapActions
ÇÇ %
(
ÇÇ% &
IEnumerable
ÇÇ& 1
<
ÇÇ1 2
LambdaExpression
ÇÇ2 B
>
ÇÇB C
	beforeMap
ÇÇD M
,
ÇÇM N
IEnumerable
ÇÇO Z
<
ÇÇZ [
LambdaExpression
ÇÇ[ k
>
ÇÇk l
afterMap
ÇÇm u
)
ÇÇu v
{
ÉÉ 	
if
ÑÑ 
(
ÑÑ 
	beforeMap
ÑÑ 
!=
ÑÑ 
null
ÑÑ !
)
ÑÑ! "
{
ÖÖ 
BeforeMapActions
ÜÜ  
??=
ÜÜ! $
[
ÜÜ% &
]
ÜÜ& '
;
ÜÜ' (
BeforeMapActions
áá  
.
áá  !
TryAdd
áá! '
(
áá' (
	beforeMap
áá( 1
)
áá1 2
;
áá2 3
}
àà 
if
ââ 
(
ââ 
afterMap
ââ 
!=
ââ 
null
ââ  
)
ââ  !
{
ää 
AfterMapActions
ãã 
??=
ãã  #
[
ãã$ %
]
ãã% &
;
ãã& '
AfterMapActions
åå 
.
åå  
TryAdd
åå  &
(
åå& '
afterMap
åå' /
)
åå/ 0
;
åå0 1
}
çç 
}
éé 	
private
èè 
PathMap
èè 
[
èè 
]
èè "
NotOverridenPathMaps
èè .
(
èè. /
TypeMap
èè/ 6
inheritedTypeMap
èè7 G
)
èèG H
{
êê 	
if
ëë 
(
ëë 
inheritedTypeMap
ëë  
.
ëë  !
PathMaps
ëë! )
.
ëë) *
Count
ëë* /
==
ëë0 2
$num
ëë3 4
)
ëë4 5
{
íí 
return
ìì 
[
ìì 
]
ìì 
;
ìì 
}
îî 
PathMaps
ïï 
??=
ïï 
[
ïï 
]
ïï 
;
ïï 
return
ññ 
inheritedTypeMap
ññ #
.
ññ# $
PathMaps
ññ$ ,
.
ññ, -
Where
ññ- 2
(
ññ2 3

baseConfig
ññ3 =
=>
ññ> @

GetPathMap
ññA K
(
ññK L

baseConfig
ññL V
.
ññV W

MemberPath
ññW a
)
ñña b
==
ññc e
null
ññf j
)
ññj k
.
ññk l
ToArray
ññl s
(
ññs t
)
ññt u
;
ññu v
}
óó 	
}
òò 
}ôô …á
WC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\ServiceCollectionExtensions.cs
	namespace 	
	Microsoft
 
. 

Extensions 
. 
DependencyInjection 2
;2 3
public 
static 
class '
ServiceCollectionExtensions /
{ 
static 

readonly 
Type 
[ 
] 
AmTypes "
=# $
[% &
typeof& ,
(, -
IValueResolver- ;
<; <
,< =
,= >
>> ?
)? @
,@ A
typeofB H
(H I 
IMemberValueResolverI ]
<] ^
,^ _
,_ `
,` a
>a b
)b c
,c d
typeofe k
(k l
ITypeConverterl z
<z {
,{ |
>| }
)} ~
,~ 
typeof
Ä Ü
(
Ü á
IValueConverter
á ñ
<
ñ ó
,
ó ò
>
ò ô
)
ô ö
,
ö õ
typeof
ú ¢
(
¢ £
IMappingAction
£ ±
<
± ≤
,
≤ ≥
>
≥ ¥
)
¥ µ
]
µ ∂
;
∂ ∑
public 

static 
IServiceCollection $
AddAutoMapper% 2
(2 3
this3 7
IServiceCollection8 J
servicesK S
,S T
ActionU [
<[ \*
IMapperConfigurationExpression\ z
>z {
configAction	| à
)
à â
=> 
 
AddAutoMapperClasses 
(  
services  (
,( )
(* +
sp+ -
,- .
cfg/ 2
)2 3
=>4 6
configAction7 C
?C D
.D E
InvokeE K
(K L
cfgL O
)O P
,P Q
nullR V
)V W
;W X
public 

static 
IServiceCollection $
AddAutoMapper% 2
(2 3
this3 7
IServiceCollection8 J
servicesK S
,S T
paramsU [
Assembly\ d
[d e
]e f

assembliesg q
)q r
=> 
 
AddAutoMapperClasses 
(  
services  (
,( )
null* .
,. /

assemblies0 :
): ;
;; <
public 

static 
IServiceCollection $
AddAutoMapper% 2
(2 3
this3 7
IServiceCollection8 J
servicesK S
,S T
ActionU [
<[ \*
IMapperConfigurationExpression\ z
>z {
configAction	| à
,
à â
params
ä ê
Assembly
ë ô
[
ô ö
]
ö õ

assemblies
ú ¶
)
¶ ß
=>   
 
AddAutoMapperClasses   
(    
services    (
,  ( )
(  * +
sp  + -
,  - .
cfg  / 2
)  2 3
=>  4 6
configAction  7 C
?  C D
.  D E
Invoke  E K
(  K L
cfg  L O
)  O P
,  P Q

assemblies  R \
)  \ ]
;  ] ^
public"" 

static"" 
IServiceCollection"" $
AddAutoMapper""% 2
(""2 3
this""3 7
IServiceCollection""8 J
services""K S
,""S T
Action""U [
<""[ \
IServiceProvider""\ l
,""l m+
IMapperConfigurationExpression	""n å
>
""å ç
configAction
""é ö
,
""ö õ
params
""ú ¢
Assembly
""£ ´
[
""´ ¨
]
""¨ ≠

assemblies
""Æ ∏
)
""∏ π
=>## 
 
AddAutoMapperClasses## 
(##  
services##  (
,##( )
configAction##* 6
,##6 7

assemblies##8 B
)##B C
;##C D
public%% 

static%% 
IServiceCollection%% $
AddAutoMapper%%% 2
(%%2 3
this%%3 7
IServiceCollection%%8 J
services%%K S
,%%S T
Action%%U [
<%%[ \*
IMapperConfigurationExpression%%\ z
>%%z {
configAction	%%| à
,
%%à â
IEnumerable
%%ä ï
<
%%ï ñ
Assembly
%%ñ û
>
%%û ü

assemblies
%%† ™
,
%%™ ´
ServiceLifetime
%%¨ ª
serviceLifetime
%%º À
=
%%Ã Õ
ServiceLifetime
%%Œ ›
.
%%› ﬁ
	Transient
%%ﬁ Á
)
%%Á Ë
=>&& 
 
AddAutoMapperClasses&& 
(&&  
services&&  (
,&&( )
(&&* +
sp&&+ -
,&&- .
cfg&&/ 2
)&&2 3
=>&&4 6
configAction&&7 C
?&&C D
.&&D E
Invoke&&E K
(&&K L
cfg&&L O
)&&O P
,&&P Q

assemblies&&R \
,&&\ ]
serviceLifetime&&^ m
)&&m n
;&&n o
public(( 

static(( 
IServiceCollection(( $
AddAutoMapper((% 2
(((2 3
this((3 7
IServiceCollection((8 J
services((K S
,((S T
Action((U [
<(([ \
IServiceProvider((\ l
,((l m+
IMapperConfigurationExpression	((n å
>
((å ç
configAction
((é ö
,
((ö õ
IEnumerable
((ú ß
<
((ß ®
Assembly
((® ∞
>
((∞ ±

assemblies
((≤ º
,
((º Ω
ServiceLifetime
((æ Õ
serviceLifetime
((Œ ›
=
((ﬁ ﬂ
ServiceLifetime
((‡ Ô
.
((Ô 
	Transient
(( ˘
)
((˘ ˙
=>)) 
 
AddAutoMapperClasses)) 
())  
services))  (
,))( )
configAction))* 6
,))6 7

assemblies))8 B
,))B C
serviceLifetime))D S
)))S T
;))T U
public++ 

static++ 
IServiceCollection++ $
AddAutoMapper++% 2
(++2 3
this++3 7
IServiceCollection++8 J
services++K S
,++S T
IEnumerable++U `
<++` a
Assembly++a i
>++i j

assemblies++k u
,++u v
ServiceLifetime	++w Ü
serviceLifetime
++á ñ
=
++ó ò
ServiceLifetime
++ô ®
.
++® ©
	Transient
++© ≤
)
++≤ ≥
=>,, 
 
AddAutoMapperClasses,, 
(,,  
services,,  (
,,,( )
null,,* .
,,,. /

assemblies,,0 :
,,,: ;
serviceLifetime,,< K
),,K L
;,,L M
public.. 

static.. 
IServiceCollection.. $
AddAutoMapper..% 2
(..2 3
this..3 7
IServiceCollection..8 J
services..K S
,..S T
params..U [
Type..\ `
[..` a
]..a b&
profileAssemblyMarkerTypes..c }
)..} ~
=>// 
 
AddAutoMapperClasses// 
(//  
services//  (
,//( )
null//* .
,//. /&
profileAssemblyMarkerTypes//0 J
.//J K
Select//K Q
(//Q R
t//R S
=>//T V
t//W X
.//X Y
GetTypeInfo//Y d
(//d e
)//e f
.//f g
Assembly//g o
)//o p
)//p q
;//q r
public11 

static11 
IServiceCollection11 $
AddAutoMapper11% 2
(112 3
this113 7
IServiceCollection118 J
services11K S
,11S T
Action11U [
<11[ \*
IMapperConfigurationExpression11\ z
>11z {
configAction	11| à
,
11à â
params
11ä ê
Type
11ë ï
[
11ï ñ
]
11ñ ó(
profileAssemblyMarkerTypes
11ò ≤
)
11≤ ≥
=>22 
 
AddAutoMapperClasses22 
(22  
services22  (
,22( )
(22* +
sp22+ -
,22- .
cfg22/ 2
)222 3
=>224 6
configAction227 C
?22C D
.22D E
Invoke22E K
(22K L
cfg22L O
)22O P
,22P Q&
profileAssemblyMarkerTypes22R l
.22l m
Select22m s
(22s t
t22t u
=>22v x
t22y z
.22z {
GetTypeInfo	22{ Ü
(
22Ü á
)
22á à
.
22à â
Assembly
22â ë
)
22ë í
)
22í ì
;
22ì î
public44 

static44 
IServiceCollection44 $
AddAutoMapper44% 2
(442 3
this443 7
IServiceCollection448 J
services44K S
,44S T
Action44U [
<44[ \
IServiceProvider44\ l
,44l m+
IMapperConfigurationExpression	44n å
>
44å ç
configAction
44é ö
,
44ö õ
params
44ú ¢
Type
44£ ß
[
44ß ®
]
44® ©(
profileAssemblyMarkerTypes
44™ ƒ
)
44ƒ ≈
=>55 
 
AddAutoMapperClasses55 
(55  
services55  (
,55( )
configAction55* 6
,556 7&
profileAssemblyMarkerTypes558 R
.55R S
Select55S Y
(55Y Z
t55Z [
=>55\ ^
t55_ `
.55` a
GetTypeInfo55a l
(55l m
)55m n
.55n o
Assembly55o w
)55w x
)55x y
;55y z
public77 

static77 
IServiceCollection77 $
AddAutoMapper77% 2
(772 3
this773 7
IServiceCollection778 J
services77K S
,77S T
Action77U [
<77[ \*
IMapperConfigurationExpression77\ z
>77z {
configAction	77| à
,
77à â
IEnumerable88 
<88 
Type88 
>88 &
profileAssemblyMarkerTypes88 4
,884 5
ServiceLifetime886 E
serviceLifetime88F U
=88V W
ServiceLifetime88X g
.88g h
	Transient88h q
)88q r
=>99 
 
AddAutoMapperClasses99 
(99  
services99  (
,99( )
(99* +
sp99+ -
,99- .
cfg99/ 2
)992 3
=>994 6
configAction997 C
?99C D
.99D E
Invoke99E K
(99K L
cfg99L O
)99O P
,99P Q&
profileAssemblyMarkerTypes99R l
.99l m
Select99m s
(99s t
t99t u
=>99v x
t99y z
.99z {
GetTypeInfo	99{ Ü
(
99Ü á
)
99á à
.
99à â
Assembly
99â ë
)
99ë í
,
99í ì
serviceLifetime
99î £
)
99£ §
;
99§ •
public;; 

static;; 
IServiceCollection;; $
AddAutoMapper;;% 2
(;;2 3
this;;3 7
IServiceCollection;;8 J
services;;K S
,;;S T
Action;;U [
<;;[ \
IServiceProvider;;\ l
,;;l m+
IMapperConfigurationExpression	;;n å
>
;;å ç
configAction
;;é ö
,
;;ö õ
IEnumerable<< 
<<< 
Type<< 
><< &
profileAssemblyMarkerTypes<< 4
,<<4 5
ServiceLifetime<<6 E
serviceLifetime<<F U
=<<V W
ServiceLifetime<<X g
.<<g h
	Transient<<h q
)<<q r
=>== 
 
AddAutoMapperClasses== 
(==  
services==  (
,==( )
configAction==* 6
,==6 7&
profileAssemblyMarkerTypes==8 R
.==R S
Select==S Y
(==Y Z
t==Z [
=>==\ ^
t==_ `
.==` a
GetTypeInfo==a l
(==l m
)==m n
.==n o
Assembly==o w
)==w x
,==x y
serviceLifetime	==z â
)
==â ä
;
==ä ã
private?? 
static?? 
IServiceCollection?? % 
AddAutoMapperClasses??& :
(??: ;
IServiceCollection??; M
services??N V
,??V W
Action??X ^
<??^ _
IServiceProvider??_ o
,??o p+
IMapperConfigurationExpression	??q è
>
??è ê
configAction
??ë ù
,
??ù û
IEnumerable@@ 
<@@ 
Assembly@@ 
>@@ 
assembliesToScan@@ .
,@@. /
ServiceLifetime@@0 ?
serviceLifetime@@@ O
=@@P Q
ServiceLifetime@@R a
.@@a b
	Transient@@b k
)@@k l
{AA 
ifBB 

(BB 
configActionBB 
!=BB 
nullBB  
)BB  !
{CC 	
servicesDD 
.DD 

AddOptionsDD 
<DD  )
MapperConfigurationExpressionDD  =
>DD= >
(DD> ?
)DD? @
.DD@ A
	ConfigureDDA J
<DDJ K
IServiceProviderDDK [
>DD[ \
(DD\ ]
(DD] ^
optionsDD^ e
,DDe f
spDDg i
)DDi j
=>DDk m
configActionDDn z
(DDz {
spDD{ }
,DD} ~
options	DD Ü
)
DDÜ á
)
DDá à
;
DDà â
}EE 	
ifFF 

(FF 
assembliesToScanFF 
!=FF 
nullFF  $
)FF$ %
{GG 	
assembliesToScanHH 
=HH 
assembliesToScanHH /
.HH/ 0
WhereHH0 5
(HH5 6
aHH6 7
=>HH8 :
!HH; <
aHH< =
.HH= >
	IsDynamicHH> G
&&HHH J
aHHK L
!=HHM O
typeofHHP V
(HHV W
MapperHHW ]
)HH] ^
.HH^ _
AssemblyHH_ g
)HHg h
.HHh i
DistinctHHi q
(HHq r
)HHr s
;HHs t
servicesII 
.II 
	ConfigureII 
<II )
MapperConfigurationExpressionII <
>II< =
(II= >
optionsII> E
=>IIF H
optionsIII P
.IIP Q
AddMapsIIQ X
(IIX Y
assembliesToScanIIY i
)IIi j
)IIj k
;IIk l
foreachJJ 
(JJ 
varJJ 
typeJJ 
inJJ  
assembliesToScanJJ! 1
.JJ1 2

SelectManyJJ2 <
(JJ< =
aJJ= >
=>JJ? A
aJJB C
.JJC D
GetTypesJJD L
(JJL M
)JJM N
.JJN O
WhereJJO T
(JJT U
typeJJU Y
=>JJZ \
typeJJ] a
.JJa b
IsClassJJb i
&&JJj l
!JJm n
typeJJn r
.JJr s

IsAbstractJJs }
&&	JJ~ Ä
IsAmType
JJÅ â
(
JJâ ä
type
JJä é
)
JJé è
)
JJè ê
)
JJê ë
)
JJë í
{KK 
servicesMM 
.MM 
TryAddTransientMM (
(MM( )
typeMM) -
)MM- .
;MM. /
}NN 
}OO 	
ifQQ 

(QQ 
servicesQQ 
.QQ 
AnyQQ 
(QQ 
sdQQ 
=>QQ 
sdQQ !
.QQ! "
ServiceTypeQQ" -
==QQ. 0
typeofQQ1 7
(QQ7 8
IMapperQQ8 ?
)QQ? @
)QQ@ A
)QQA B
{RR 	
returnSS 
servicesSS 
;SS 
}TT 	
servicesUU 
.UU 
AddSingletonUU 
<UU "
IConfigurationProviderUU 4
>UU4 5
(UU5 6
spUU6 8
=>UU9 ;
{VV 	
varXX 
optionsXX 
=XX 
spXX 
.XX 
GetRequiredServiceXX /
<XX/ 0
IOptionsXX0 8
<XX8 9)
MapperConfigurationExpressionXX9 V
>XXV W
>XXW X
(XXX Y
)XXY Z
;XXZ [
returnYY 
newYY 
MapperConfigurationYY *
(YY* +
optionsYY+ 2
.YY2 3
ValueYY3 8
)YY8 9
;YY9 :
}ZZ 	
)ZZ	 

;ZZ
 
services[[ 
.[[ 
Add[[ 
([[ 
new[[ 
([[ 
typeof[[ 
([[  
IMapper[[  '
)[[' (
,[[( )
sp[[* ,
=>[[- /
new[[0 3
Mapper[[4 :
([[: ;
sp[[; =
.[[= >
GetRequiredService[[> P
<[[P Q"
IConfigurationProvider[[Q g
>[[g h
([[h i
)[[i j
,[[j k
sp[[l n
.[[n o

GetService[[o y
)[[y z
,[[z {
serviceLifetime	[[| ã
)
[[ã å
)
[[å ç
;
[[ç é
return\\ 
services\\ 
;\\ 
bool]] 
IsAmType]] 
(]] 
Type]] 
type]] 
)]]  
=>]]! #
Array]]$ )
.]]) *
Exists]]* 0
(]]0 1
AmTypes]]1 8
,]]8 9
openType]]: B
=>]]C E
type]]F J
.]]J K
GetGenericInterface]]K ^
(]]^ _
openType]]_ g
)]]g h
!=]]i k
null]]l p
)]]p q
;]]q r
}^^ 
}__ p
MC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\ResolutionContext.cs
	namespace 	

AutoMapper
 
; 
public 
sealed 
class 
ResolutionContext %
:& '"
IInternalRuntimeMapper( >
{ 
private 

Dictionary 
< 
ContextCacheKey &
,& '
object( .
>. /
_instanceCache0 >
;> ?
private		 

Dictionary		 
<		 
TypePair		 
,		  
int		! $
>		$ %

_typeDepth		& 0
;		0 1
private

 
readonly

 "
IInternalRuntimeMapper

 +
_mapper

, 3
;

3 4
private 
readonly $
IMappingOperationOptions -
_options. 6
;6 7
internal 
ResolutionContext 
( "
IInternalRuntimeMapper 5
mapper6 <
,< =$
IMappingOperationOptions> V
optionsW ^
=_ `
nulla e
)e f
{ 
_mapper 
= 
mapper 
; 
_options 
= 
options 
; 
} 
public 

object 
State 
=> 
_options #
?# $
.$ %
State% *
;* +
public 


Dictionary 
< 
string 
, 
object $
>$ %
Items& +
{ 
get 
{ 	
if 
( 
_options 
== 
null  
)  !
{ 
ThrowInvalidMap   
(    
)    !
;  ! "
}!! 
return"" 
_options"" 
."" 
Items"" !
;""! "
}## 	
}$$ 
public(( 

bool(( 
TryGetItems(( 
((( 
out(( 

Dictionary((  *
<((* +
string((+ 1
,((1 2
object((3 9
>((9 :
items((; @
)((@ A
=>((B D
(((E F
items((F K
=((L M
_options((N V
?((V W
.((W X
Items((X ]
)((] ^
!=((_ a
null((b f
;((f g
public,, 

IRuntimeMapper,, 
Mapper,,  
=>,,! #
this,,$ (
;,,( )
ResolutionContext-- "
IInternalRuntimeMapper-- ,
.--, -
DefaultContext--- ;
=>--< >
_mapper--? F
.--F G
DefaultContext--G U
;--U V
public11 


Dictionary11 
<11 
ContextCacheKey11 %
,11% &
object11' -
>11- .
InstanceCache11/ <
{22 
get33 
{44 	
CheckDefault55 
(55 
)55 
;55 
return66 
_instanceCache66 !
??=66" %
[66& '
]66' (
;66( )
}77 	
}88 
private<< 

Dictionary<< 
<<< 
TypePair<< 
,<<  
int<<! $
><<$ %
	TypeDepth<<& /
{== 
get>> 
{?? 	
CheckDefault@@ 
(@@ 
)@@ 
;@@ 
returnAA 

_typeDepthAA 
??=AA !
[AA" #
]AA# $
;AA$ %
}BB 	
}CC 
TDestinationDD 
IMapperBaseDD 
.DD 
MapDD  
<DD  !
TDestinationDD! -
>DD- .
(DD. /
objectDD/ 5
sourceDD6 <
)DD< =
=>DD> @
(DDA B
(DDB C
IMapperBaseDDC N
)DDN O
thisDDO S
)DDS T
.DDT U
MapDDU X
(DDX Y
sourceDDY _
,DD_ `
defaultDDa h
(DDh i
TDestinationDDi u
)DDu v
)DDv w
;DDw x
TDestinationEE 
IMapperBaseEE 
.EE 
MapEE  
<EE  !
TSourceEE! (
,EE( )
TDestinationEE* 6
>EE6 7
(EE7 8
TSourceEE8 ?
sourceEE@ F
)EEF G
=>EEH J
_mapperEEK R
.EER S
MapEES V
(EEV W
sourceEEW ]
,EE] ^
defaultEE_ f
(EEf g
TDestinationEEg s
)EEs t
,EEt u
thisEEv z
)EEz {
;EE{ |
TDestinationFF 
IMapperBaseFF 
.FF 
MapFF  
<FF  !
TSourceFF! (
,FF( )
TDestinationFF* 6
>FF6 7
(FF7 8
TSourceFF8 ?
sourceFF@ F
,FFF G
TDestinationFFH T
destinationFFU `
)FF` a
=>FFb d
_mapperFFe l
.FFl m
MapFFm p
(FFp q
sourceFFq w
,FFw x
destination	FFy Ñ
,
FFÑ Ö
this
FFÜ ä
)
FFä ã
;
FFã å
objectGG 

IMapperBaseGG 
.GG 
MapGG 
(GG 
objectGG !
sourceGG" (
,GG( )
TypeGG* .

sourceTypeGG/ 9
,GG9 :
TypeGG; ?
destinationTypeGG@ O
)GGO P
=>GGQ S
_mapperGGT [
.GG[ \
MapGG\ _
(GG_ `
sourceGG` f
,GGf g
(GGh i
objectGGi o
)GGo p
nullGGp t
,GGt u
thisGGv z
,GGz {

sourceType	GG| Ü
,
GGÜ á
destinationType
GGà ó
)
GGó ò
;
GGò ô
objectHH 

IMapperBaseHH 
.HH 
MapHH 
(HH 
objectHH !
sourceHH" (
,HH( )
objectHH* 0
destinationHH1 <
,HH< =
TypeHH> B

sourceTypeHHC M
,HHM N
TypeHHO S
destinationTypeHHT c
)HHc d
=>HHe g
_mapperHHh o
.HHo p
MapHHp s
(HHs t
sourceHHt z
,HHz {
destination	HH| á
,
HHá à
this
HHâ ç
,
HHç é

sourceType
HHè ô
,
HHô ö
destinationType
HHõ ™
)
HH™ ´
;
HH´ ¨
TDestinationII "
IInternalRuntimeMapperII '
.II' (
MapII( +
<II+ ,
TSourceII, 3
,II3 4
TDestinationII5 A
>IIA B
(IIB C
TSourceIIC J
sourceIIK Q
,IIQ R
TDestinationIIS _
destinationII` k
,IIk l
ResolutionContextIIm ~
context	II Ü
,
IIÜ á
TypeJJ 

sourceTypeJJ 
,JJ 
TypeJJ 
destinationTypeJJ -
,JJ- .
	MemberMapJJ/ 8
	memberMapJJ9 B
)JJB C
=>JJD F
_mapperJJG N
.JJN O
MapJJO R
(JJR S
sourceJJS Y
,JJY Z
destinationJJ[ f
,JJf g
contextJJh o
,JJo p

sourceTypeJJq {
,JJ{ |
destinationType	JJ} å
,
JJå ç
	memberMap
JJé ó
)
JJó ò
;
JJò ô
internalKK 
objectKK 
CreateInstanceKK "
(KK" #
TypeKK# '
typeKK( ,
)KK, -
=>KK. 0
ServiceCtorKK1 <
(KK< =
)KK= >
(KK> ?
typeKK? C
)KKC D
??KKE G
throwKKH M
newKKN Q&
AutoMapperMappingExceptionKKR l
(KKl m
$str	KKm ë
+
KKí ì
type
KKî ò
)
KKò ô
;
KKô ö
privateLL 
FuncLL 
<LL 
TypeLL 
,LL 
objectLL 
>LL 
ServiceCtorLL *
(LL* +
)LL+ ,
=>LL- /
_optionsLL0 8
?LL8 9
.LL9 :
ServiceCtorLL: E
??LLF H
_mapperLLI P
.LLP Q
ServiceCtorLLQ \
;LL\ ]
internalMM 
objectMM 
GetDestinationMM "
(MM" #
objectMM# )
sourceMM* 0
,MM0 1
TypeMM2 6
destinationTypeMM7 F
)MMF G
=>MMH J
InstanceCacheMMK X
.MMX Y
GetValueOrDefaultMMY j
(MMj k
newMMk n
(MMn o
sourceMMo u
,MMu v
destinationType	MMw Ü
)
MMÜ á
)
MMá à
;
MMà â
internalNN 
voidNN 
CacheDestinationNN "
(NN" #
objectNN# )
sourceNN* 0
,NN0 1
TypeNN2 6
destinationTypeNN7 F
,NNF G
objectNNH N
destinationNNO Z
)NNZ [
=>NN\ ^
InstanceCacheNN_ l
[NNl m
newNNm p
(NNp q
sourceNNq w
,NNw x
destinationType	NNy à
)
NNà â
]
NNâ ä
=
NNã å
destination
NNç ò
;
NNò ô
internalOO 
voidOO 
IncrementTypeDepthOO $
(OO$ %
TypeMapOO% ,
typeMapOO- 4
)OO4 5
=>OO6 8
	TypeDepthOO9 B
[OOB C
typeMapOOC J
.OOJ K
TypesOOK P
]OOP Q
++OOQ S
;OOS T
internalPP 
voidPP 
DecrementTypeDepthPP $
(PP$ %
TypeMapPP% ,
typeMapPP- 4
)PP4 5
=>PP6 8
	TypeDepthPP9 B
[PPB C
typeMapPPC J
.PPJ K
TypesPPK P
]PPP Q
--PPQ S
;PPS T
internalQQ 
boolQQ 
OverTypeDepthQQ 
(QQ  
TypeMapQQ  '
typeMapQQ( /
)QQ/ 0
{RR 
ifSS 

(SS 
!SS 
	TypeDepthSS 
.SS 
TryGetValueSS "
(SS" #
typeMapSS# *
.SS* +
TypesSS+ 0
,SS0 1
outSS2 5
intSS6 9
depthSS: ?
)SS? @
)SS@ A
{TT 	
	TypeDepthUU 
[UU 
typeMapUU 
.UU 
TypesUU #
]UU# $
=UU% &
$numUU' (
;UU( )
depthVV 
=VV 
$numVV 
;VV 
}WW 	
returnXX 
depthXX 
>XX 
typeMapXX 
.XX 
MaxDepthXX '
;XX' (
}YY 
internalZZ 
boolZZ 
	IsDefaultZZ 
=>ZZ 
thisZZ #
==ZZ$ &
_mapperZZ' .
.ZZ. /
DefaultContextZZ/ =
;ZZ= >
Func[[ 
<[[ 	
Type[[	 
,[[ 
object[[ 
>[[ "
IInternalRuntimeMapper[[ -
.[[- .
ServiceCtor[[. 9
=>[[: <
ServiceCtor[[= H
([[H I
)[[I J
;[[J K
internal\\ 
static\\ 
void\\ 
CheckContext\\ %
(\\% &
ref\\& )
ResolutionContext\\* ;
resolutionContext\\< M
)\\M N
{]] 
if^^ 

(^^ 
resolutionContext^^ 
.^^ 
	IsDefault^^ '
)^^' (
{__ 	
resolutionContext`` 
=`` 
new``  #
(``# $
resolutionContext``$ 5
.``5 6
_mapper``6 =
)``= >
;``> ?
}aa 	
}bb 
internalcc 
TDestinationcc 
MapInternalcc %
<cc% &
TSourcecc& -
,cc- .
TDestinationcc/ ;
>cc; <
(cc< =
TSourcecc= D
sourceccE K
,ccK L
TDestinationccM Y
destinationccZ e
,cce f
	MemberMapccg p
	memberMapccq z
)ccz {
=>cc| ~
_mapperdd 
.dd 
Mapdd 
(dd 
sourcedd 
,dd 
destinationdd '
,dd' (
thisdd) -
,dd- .
	memberMapdd/ 8
:dd8 9
	memberMapdd: C
)ddC D
;ddD E
internalee 
objectee 
Mapee 
(ee 
objectee 
sourceee %
,ee% &
objectee' -
destinationee. 9
,ee9 :
Typeee; ?

sourceTypeee@ J
,eeJ K
TypeeeL P
destinationTypeeeQ `
,ee` a
	MemberMapeeb k
	memberMapeel u
)eeu v
=>eew y
_mapperff 
.ff 
Mapff 
(ff 
sourceff 
,ff 
destinationff '
,ff' (
thisff) -
,ff- .

sourceTypeff/ 9
,ff9 :
destinationTypeff; J
,ffJ K
	memberMapffL U
)ffU V
;ffV W
privategg 
voidgg 
CheckDefaultgg 
(gg 
)gg 
{hh 
ifii 

(ii 
	IsDefaultii 
)ii 
{jj 	
ThrowInvalidMapkk 
(kk 
)kk 
;kk 
}ll 	
}mm 
privatenn 
staticnn 
voidnn 
ThrowInvalidMapnn '
(nn' (
)nn( )
=>nn* ,
thrownn- 2
newnn3 6%
InvalidOperationExceptionnn7 P
(nnP Q
$str	nnQ Ê
)
nnÊ Á
;
nnÁ Ë
}oo 
publicpp 
readonlypp 
recordpp 
structpp 
ContextCacheKeypp -
(pp- .
objectpp. 4
Sourcepp5 ;
,pp; <
Typepp= A
DestinationTypeppB Q
)ppQ R
{qq 
publicrr 

overriderr 
intrr 
GetHashCoderr #
(rr# $
)rr$ %
=>rr& (
HashCoderr) 1
.rr1 2
Combinerr2 9
(rr9 :
DestinationTyperr: I
,rrI J
RuntimeHelpersrrK Y
.rrY Z
GetHashCoderrZ e
(rre f
Sourcerrf l
)rrl m
)rrm n
;rrn o
publicss 

boolss 
Equalsss 
(ss 
ContextCacheKeyss &
otherss' ,
)ss, -
=>ss. 0
DestinationTypess1 @
==ssA C
otherssD I
.ssI J
DestinationTypessJ Y
&&ssZ \
Sourcess] c
==ssd f
otherssg l
.ssl m
Sourcessm s
;sss t
}tt ó
xC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\ProjectionMappers\StringProjectionMapper.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
.( )
Impl) -
;- .
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class "
StringProjectionMapper *
:+ ,
IProjectionMapper- >
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
DestinationType5 D
==E G
typeofH N
(N O
stringO U
)U V
;V W
public 


Expression 
Project 
(  
IGlobalConfiguration 2
configuration3 @
,@ A
inB D
ProjectionRequestE V
requestW ^
,^ _

Expression` j
resolvedSourcek y
,y z
LetPropertyMaps	{ ä
letPropertyMaps
ã ö
)
ö õ
=> 

Call 
( 
resolvedSource 
, 
ObjectToString  .
). /
;/ 0
}		 ¯
ÄC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\ProjectionMappers\NullableSourceProjectionMapper.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
.( )
Impl) -
;- .
public 
sealed 
class *
NullableSourceProjectionMapper 2
:3 4
IProjectionMapper5 F
{ 
public 


Expression 
Project 
(  
IGlobalConfiguration 2
configuration3 @
,@ A
inB D
ProjectionRequestE V
requestW ^
,^ _

Expression` j
resolvedSourcek y
,y z
LetPropertyMaps	{ ä
letPropertyMaps
ã ö
)
ö õ
=>
ú û
Coalesce 
( 
resolvedSource 
,  
New! $
($ %
request% ,
., -
DestinationType- <
)< =
)= >
;> ?
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context 
. 
DestinationType 
.  
IsValueType  +
&&, .
!/ 0
context0 7
.7 8
DestinationType8 G
.G H
IsNullableTypeH V
(V W
)W X
&&Y [
context\ c
.c d

SourceTyped n
.n o
IsNullableTypeo }
(} ~
)~ 
;	 Ä
} Û
vC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\ProjectionMappers\EnumProjectionMapper.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
.( )
Impl) -
;- .
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class  
EnumProjectionMapper (
:) *
IProjectionMapper+ <
{ 
public 


Expression 
Project 
(  
IGlobalConfiguration 2
configuration3 @
,@ A
inB D
ProjectionRequestE V
requestW ^
,^ _

Expression` j
resolvedSourcek y
,y z
LetPropertyMaps	{ ä
letPropertyMaps
ã ö
)
ö õ
=> 

Convert 
( 
resolvedSource !
,! "
request# *
.* +
DestinationType+ :
): ;
;; <
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
IsEnumToEnum5 A
(A B
)B C
||D F
contextG N
.N O"
IsUnderlyingTypeToEnumO e
(e f
)f g
||h j
contextk r
.r s#
IsEnumToUnderlyingType	s â
(
â ä
)
ä ã
;
ã å
} ò3
|C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\ProjectionMappers\EnumerableProjectionMapper.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
.( )
Impl) -
;- .
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class &
EnumerableProjectionMapper .
:/ 0
IProjectionMapper1 B
{ 
private 
static 
readonly 

MethodInfo &
SelectMethod' 3
=4 5
typeof6 <
(< =

Enumerable= G
)G H
.H I
StaticGenericMethodI \
(\ ]
$str] e
,e f
parametersCountg v
:v w
$numx y
)y z
;z {
private 
static 
readonly 

MethodInfo &
ToArrayMethod' 4
=5 6
typeof7 =
(= >

Enumerable> H
)H I
.I J
GetStaticMethodJ Y
(Y Z
$strZ c
)c d
;d e
private 
static 
readonly 

MethodInfo &
ToListMethod' 3
=4 5
typeof6 <
(< =

Enumerable= G
)G H
.H I
GetStaticMethodI X
(X Y
$strY a
)a b
;b c
public		 

bool		 
IsMatch		 
(		 
TypePair		  
context		! (
)		( )
=>		* ,
context		- 4
.		4 5
IsCollection		5 A
(		A B
)		B C
;		C D
public

 


Expression

 
Project

 
(

  
IGlobalConfiguration

 2
configuration

3 @
,

@ A
in

B D
ProjectionRequest

E V
request

W ^
,

^ _

Expression

` j
resolvedSource

k y
,

y z
LetPropertyMaps	

{ ä
letPropertyMaps


ã ö
)


ö õ
{ 
var 
destinationType 
= 
request %
.% &
DestinationType& 5
;5 6
var 
destinationListType 
=  !
GetElementType" 0
(0 1
destinationType1 @
)@ A
;A B
var 
sourceListType 
= 
GetElementType +
(+ ,
request, 3
.3 4

SourceType4 >
)> ?
;? @
var 
sourceExpression 
= 
resolvedSource -
;- .
if 

( 
sourceListType 
!= 
destinationListType 1
)1 2
{ 	
var 
itemRequest 
= 
request %
.% &
InnerRequest& 2
(2 3
sourceListType3 A
,A B
destinationListTypeC V
)V W
;W X
var "
transformedExpressions &
=' (
configuration) 6
.6 7
ProjectionBuilder7 H
.H I
CreateProjectionI Y
(Y Z
itemRequestZ e
,e f
letPropertyMapsg v
.v w
Neww z
(z {
){ |
)| }
;} ~
if 
( "
transformedExpressions %
.% &
Empty& +
)+ ,
{ 
return 
null 
; 
} 
sourceExpression 
= "
transformedExpressions 5
.5 6
Chain6 ;
(; <
sourceExpression< L
,L M
SelectN T
)T U
;U V
} 	
if 

( 
! 
destinationType 
. 
IsAssignableFrom -
(- .
sourceExpression. >
.> ?
Type? C
)C D
)D E
{ 	
var 
convertFunction 
=  !
destinationType" 1
.1 2
IsArray2 9
?: ;
ToArrayMethod< I
:J K
ToListMethodL X
;X Y
convertFunction 
= 
convertFunction -
.- .
MakeGenericMethod. ?
(? @
destinationListType@ S
)S T
;T U
if 
( 
destinationType 
.  
IsAssignableFrom  0
(0 1
convertFunction1 @
.@ A

ReturnTypeA K
)K L
)L M
{ 
sourceExpression    
=  ! "
Call  # '
(  ' (
convertFunction  ( 7
,  7 8
sourceExpression  9 I
)  I J
;  J K
}!! 
else"" 
{## 
var$$ 
ctorInfo$$ 
=$$ 
destinationType$$ .
.$$. /
GetConstructor$$/ =
($$= >
[$$> ?
sourceExpression$$? O
.$$O P
Type$$P T
]$$T U
)$$U V
;$$V W
if%% 
(%% 
ctorInfo%% 
is%% 
not%%  #
null%%$ (
)%%( )
{&& 
sourceExpression'' $
=''% &
New''' *
(''* +
ctorInfo''+ 3
,''3 4
sourceExpression''5 E
)''E F
;''F G
}(( 
})) 
}** 	
return++ 
sourceExpression++ 
;++  
},, 
private-- 
static-- 

Expression-- 
Select-- $
(--$ %

Expression--% /
source--0 6
,--6 7
LambdaExpression--8 H
lambda--I O
)--O P
=>--Q S
Call.. 
(.. 
SelectMethod.. 
... 
MakeGenericMethod.. +
(..+ ,
lambda.., 2
...2 3

Parameters..3 =
[..= >
$num..> ?
]..? @
...@ A
Type..A E
,..E F
lambda..G M
...M N

ReturnType..N X
)..X Y
,..Y Z
source..[ a
,..a b
lambda..c i
)..i j
;..j k
}// ˜
|C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\ProjectionMappers\AssignableProjectionMapper.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
.( )
Impl) -
;- .
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class &
AssignableProjectionMapper .
:/ 0
IProjectionMapper1 B
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
DestinationType5 D
.D E
IsAssignableFromE U
(U V
contextV ]
.] ^

SourceType^ h
)h i
;i j
public 


Expression 
Project 
(  
IGlobalConfiguration 2
configuration3 @
,@ A
inB D
ProjectionRequestE V
requestW ^
,^ _

Expression` j
resolvedSourcek y
,y z
LetPropertyMaps	{ ä
letPropertyMaps
ã ö
)
ö õ
=> 

ToType 
( 
resolvedSource  
,  !
request" )
.) *
DestinationType* 9
)9 :
;: ;
} ≈†
aC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\ProjectionBuilder.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
.( )
Impl) -
;- .
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
	interface 
IProjectionBuilder #
{ 
QueryExpressions 
GetProjection "
(" #
Type# '

sourceType( 2
,2 3
Type4 8
destinationType9 H
,H I
objectJ P

parametersQ [
,[ \

MemberPath] g
[g h
]h i
membersToExpandj y
)y z
;z {
QueryExpressions		 
CreateProjection		 %
(		% &
in		& (
ProjectionRequest		) :
request		; B
,		B C
LetPropertyMaps		D S
letPropertyMaps		T c
)		c d
;		d e
}

 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
	interface 
IProjectionMapper "
{ 
bool 
IsMatch	 
( 
TypePair 
context !
)! "
;" #

Expression 
Project 
(  
IGlobalConfiguration +
configuration, 9
,9 :
in; =
ProjectionRequest> O
requestP W
,W X

ExpressionY c
resolvedSourced r
,r s
LetPropertyMaps	t É
letPropertyMaps
Ñ ì
)
ì î
;
î ï
} 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 
ProjectionBuilder %
:& '
IProjectionBuilder( :
{ 
internal 
static 
List 
< 
IProjectionMapper *
>* +$
DefaultProjectionMappers, D
(D E
)E F
=>G I
[ 	
new	 &
AssignableProjectionMapper '
(' (
)( )
,) *
new+ .&
EnumerableProjectionMapper/ I
(I J
)J K
,K L
newM P*
NullableSourceProjectionMapperQ o
(o p
)p q
,q r
news v#
StringProjectionMapper	w ç
(
ç é
)
é è
,
è ê
new
ë î"
EnumProjectionMapper
ï ©
(
© ™
)
™ ´
]
´ ¨
;
¨ ≠
readonly '
LockingConcurrentDictionary (
<( )
ProjectionRequest) :
,: ;
QueryExpressions< L
>L M
_projectionCacheN ^
;^ _
readonly  
IGlobalConfiguration !
_configuration" 0
;0 1
readonly 
IProjectionMapper 
[ 
]  
_projectionMappers! 3
;3 4
public 

ProjectionBuilder 
(  
IGlobalConfiguration 1
configuration2 ?
,? @
IProjectionMapperA R
[R S
]S T
projectionMappersU f
)f g
{ 
_configuration 
= 
configuration &
;& '
_projectionMappers 
= 
projectionMappers .
;. /
_projectionCache 
= 
new 
( 
CreateProjection /
)/ 0
;0 1
} 
public 

QueryExpressions 
GetProjection )
() *
Type* .

sourceType/ 9
,9 :
Type; ?
destinationType@ O
,O P
objectQ W

parametersX b
,b c

MemberPathd n
[n o
]o p
membersToExpand	q Ä
)
Ä Å
{   
ProjectionRequest!! 
projectionRequest!! +
=!!, -
new!!. 1
(!!1 2

sourceType!!2 <
,!!< =
destinationType!!> M
,!!M N
membersToExpand!!O ^
,!!^ _
[!!` a
]!!a b
)!!b c
;!!c d
var"" 
cachedExpressions"" 
="" 
_projectionCache""  0
.""0 1
GetOrAdd""1 9
(""9 :
projectionRequest"": K
)""K L
;""L M
if## 

(## 

parameters## 
==## 
null## 
&&## !
!##" #
_configuration### 1
.##1 20
$EnableNullPropagationForQueryMapping##2 V
)##V W
{$$ 	
return%% 
cachedExpressions%% $
;%%$ %
}&& 	
return'' 
cachedExpressions''  
.''  !
Prepare''! (
(''( )
_configuration'') 7
.''7 80
$EnableNullPropagationForQueryMapping''8 \
,''\ ]

parameters''^ h
)''h i
;''i j
}(( 
QueryExpressions)) 
CreateProjection)) %
())% &
ProjectionRequest))& 7
request))8 ?
)))? @
{** 
var++ 
(++ 
typeMap++ 
,++ 
polymorphicMaps++ %
)++% &
=++' (
PolymorphicMaps++) 8
(++8 9
request++9 @
)++@ A
;++A B
var,, 
letPropertyMaps,, 
=,, 
polymorphicMaps,, -
.,,- .
Length,,. 4
>,,5 6
$num,,7 8
?,,9 :
new,,; >
LetPropertyMaps,,? N
(,,N O
_configuration,,O ]
,,,] ^

MemberPath,,_ i
.,,i j
Empty,,j o
,,,o p
[,,q r
],,r s
),,s t
:,,u v
new,,w z%
FirstPassLetPropertyMaps	,,{ ì
(
,,ì î
_configuration
,,î ¢
,
,,¢ £

MemberPath
,,§ Æ
.
,,Æ Ø
Empty
,,Ø ¥
,
,,¥ µ
[
,,∂ ∑
]
,,∑ ∏
)
,,∏ π
;
,,π ∫
return-- 
CreateProjection-- 
(--  
request--  '
,--' (
letPropertyMaps--) 8
,--8 9
typeMap--: A
,--A B
polymorphicMaps--C R
)--R S
;--S T
}.. 
(// 
TypeMap// 
,// 
TypeMap// 
[// 
]// 
)// 
PolymorphicMaps// (
(//( )
in//) +
ProjectionRequest//, =
request//> E
)//E F
{00 
var11 
typeMap11 
=11 
_configuration11 $
.11$ %
ResolveTypeMap11% 3
(113 4
request114 ;
.11; <

SourceType11< F
,11F G
request11H O
.11O P
DestinationType11P _
)11_ `
??11a c
throw11d i
TypeMap11j q
.11q r 
MissingMapException	11r Ö
(
11Ö Ü
request
11Ü ç
.
11ç é

SourceType
11é ò
,
11ò ô
request
11ö °
.
11° ¢
DestinationType
11¢ ±
)
11± ≤
;
11≤ ≥
return22 
(22 
typeMap22 
,22 
PolymorphicMaps22 (
(22( )
typeMap22) 0
)220 1
)221 2
;222 3
}33 
TypeMap44 
[44 
]44 
PolymorphicMaps44 
(44 
TypeMap44 %
typeMap44& -
)44- .
=>44/ 1
_configuration442 @
.44@ A
GetIncludedTypeMaps44A T
(44T U
typeMap44U \
.44\ ] 
IncludedDerivedTypes44] q
.55 	
Where55	 
(55 
tp55 
=>55 
tp55 
.55 

SourceType55 "
!=55# %
typeMap55& -
.55- .

SourceType55. 8
&&559 ;
!55< =
tp55= ?
.55? @
DestinationType55@ O
.55O P

IsAbstract55P Z
)55Z [
.55[ \

DistinctBy55\ f
(55f g
tp55g i
=>55j l
tp55m o
.55o p

SourceType55p z
)55z {
.55{ |
ToArray	55| É
(
55É Ñ
)
55Ñ Ö
)
55Ö Ü
;
55Ü á
public66 

QueryExpressions66 
CreateProjection66 ,
(66, -
in66- /
ProjectionRequest660 A
request66B I
,66I J
LetPropertyMaps66K Z
letPropertyMaps66[ j
)66j k
{77 
var88 
(88 
typeMap88 
,88 
polymorphicMaps88 %
)88% &
=88' (
PolymorphicMaps88) 8
(888 9
request889 @
)88@ A
;88A B
return99 
CreateProjection99 
(99  
request99  '
,99' (
letPropertyMaps99) 8
,998 9
typeMap99: A
,99A B
polymorphicMaps99C R
)99R S
;99S T
}:: 
QueryExpressions;; 
CreateProjection;; %
(;;% &
in;;& (
ProjectionRequest;;) :
request;;; B
,;;B C
LetPropertyMaps;;D S
letPropertyMaps;;T c
,;;c d
TypeMap;;e l
typeMap;;m t
,;;t u
TypeMap;;v }
[;;} ~
];;~ 
polymorphicMaps
;;Ä è
)
;;è ê
{<< 
var== 
instanceParameter== 
=== 
	Parameter==  )
(==) *
request==* 1
.==1 2

SourceType==2 <
,==< =
$str==> C
+==D E
request==F M
.==M N

SourceType==N X
.==X Y
Name==Y ]
)==] ^
;==^ _
var>> 

projection>> 
=>> 
CreateProjection>> )
(>>) *
request>>* 1
,>>1 2
letPropertyMaps>>3 B
,>>B C
typeMap>>D K
,>>K L
polymorphicMaps>>M \
,>>\ ]
instanceParameter>>^ o
)>>o p
;>>p q
return?? 
letPropertyMaps?? 
.?? 
Count?? $
>??% &
$num??' (
???) *
letPropertyMaps??+ :
.??: ;!
GetSubQueryExpression??; P
(??P Q
this??Q U
,??U V

projection??W a
,??a b
typeMap??c j
,??j k
request??l s
,??s t
instanceParameter	??u Ü
)
??Ü á
:
??à â
new
??ä ç
(
??ç é

projection
??é ò
,
??ò ô
instanceParameter
??ö ´
)
??´ ¨
;
??¨ ≠
}@@ 

ExpressionAA 
CreateProjectionAA 
(AA  
inAA  "
ProjectionRequestAA# 4
requestAA5 <
,AA< =
LetPropertyMapsAA> M
letPropertyMapsAAN ]
,AA] ^
TypeMapAA_ f
typeMapAAg n
,AAn o
TypeMapAAp w
[AAw x
]AAx y
polymorphicMaps	AAz â
,
AAâ ä

Expression
AAã ï
source
AAñ ú
)
AAú ù
{BB 
varCC 
destinationTypeCC 
=CC 
typeMapCC %
.CC% &
DestinationTypeCC& 5
;CC5 6
varDD 

projectionDD 
=DD 
(DD 
polymorphicMapsDD )
.DD) *
LengthDD* 0
>DD1 2
$numDD3 4
&&DD5 7
destinationTypeDD8 G
.DDG H

IsAbstractDDH R
)DDR S
?DDT U
DefaultDDV ]
(DD] ^
destinationTypeDD^ m
)DDm n
:DDo p!
CreateProjectionCore	DDq Ö
(
DDÖ Ü
request
DDÜ ç
,
DDç é
letPropertyMaps
DDè û
,
DDû ü
typeMap
DD† ß
,
DDß ®
source
DD© Ø
)
DDØ ∞
;
DD∞ ±
foreachEE 
(EE 
varEE 

derivedMapEE 
inEE !
polymorphicMapsEE" 1
)EE1 2
{FF 	
varGG 

sourceTypeGG 
=GG 

derivedMapGG '
.GG' (

SourceTypeGG( 2
;GG2 3
varHH 
derivedRequestHH 
=HH  
requestHH! (
.HH( )
InnerRequestHH) 5
(HH5 6

sourceTypeHH6 @
,HH@ A

derivedMapHHB L
.HHL M
DestinationTypeHHM \
)HH\ ]
;HH] ^
varII 
derivedProjectionII !
=II" # 
CreateProjectionCoreII$ 8
(II8 9
derivedRequestII9 G
,IIG H
letPropertyMapsIII X
,IIX Y

derivedMapIIZ d
,IId e
TypeAsIIf l
(IIl m
sourceIIm s
,IIs t

sourceTypeIIu 
)	II Ä
)
IIÄ Å
;
IIÅ Ç

projectionJJ 
=JJ 
	ConditionJJ "
(JJ" #
TypeIsJJ# )
(JJ) *
sourceJJ* 0
,JJ0 1

sourceTypeJJ2 <
)JJ< =
,JJ= >
derivedProjectionJJ? P
,JJP Q

projectionJJR \
,JJ\ ]

projectionJJ^ h
.JJh i
TypeJJi m
)JJm n
;JJn o
}KK 	
returnLL 

projectionLL 
;LL 

ExpressionMM  
CreateProjectionCoreMM '
(MM' (
ProjectionRequestMM( 9
requestMM: A
,MMA B
LetPropertyMapsMMC R
letPropertyMapsMMS b
,MMb c
TypeMapMMd k
typeMapMMl s
,MMs t

ExpressionMMu 
instanceParameter
MMÄ ë
)
MMë í
{NN 	
varOO 
customProjectionOO  
=OO! "
typeMapOO# *
.OO* +
CustomMapExpressionOO+ >
?OO> ?
.OO? @
ReplaceParametersOO@ Q
(OOQ R
instanceParameterOOR c
)OOc d
;OOd e
ifPP 
(PP 
customProjectionPP 
!=PP  "
nullPP# '
)PP' (
{QQ 
returnRR 
customProjectionRR '
;RR' (
}SS 
ListTT 
<TT 
MemberBindingTT 
>TT !
propertiesProjectionsTT  5
=TT6 7
[TT8 9
]TT9 :
;TT: ;
intUU 
depthUU 
;UU 
ifVV 
(VV 
OverMaxDepthVV 
(VV 
)VV 
)VV 
{WW 
ifXX 
(XX 
typeMapXX 
.XX 
ProfileXX "
.XX" #&
AllowNullDestinationValuesXX# =
)XX= >
{YY 
returnZZ 
nullZZ 
;ZZ  
}[[ 
}\\ 
else]] 
{^^ 
ProjectProperties__ !
(__! "
)__" #
;__# $
}`` 
varaa !
constructorExpressionaa %
=aa& '
CreateDestinationaa( 9
(aa9 :
)aa: ;
;aa; <
varbb 

expressionbb 
=bb 

MemberInitbb '
(bb' (!
constructorExpressionbb( =
,bb= >!
propertiesProjectionsbb? T
)bbT U
;bbU V
returncc 

expressioncc 
;cc 
booldd 
OverMaxDepthdd 
(dd 
)dd 
{ee 
depthff 
=ff 
letPropertyMapsff '
.ff' (
IncrementDepthff( 6
(ff6 7
requestff7 >
)ff> ?
;ff? @
returngg 
typeMapgg 
.gg 
MaxDepthgg '
>gg( )
$numgg* +
&&gg, .
depthgg/ 4
>=gg5 7
typeMapgg8 ?
.gg? @
MaxDepthgg@ H
;ggH I
}hh 
voidii 
ProjectPropertiesii "
(ii" #
)ii# $
{jj 
foreachkk 
(kk 
varkk 
propertyMapkk '
inkk( *
typeMapkk+ 2
.kk2 3
PropertyMapskk3 ?
)kk? @
{ll 
ifmm 
(mm 
!mm 
propertyMapmm #
.mm# $
CanResolveValuemm$ 3
||mm4 6
!mm7 8
propertyMapmm8 C
.mmC D
CanBeSetmmD L
||mmM O
typeMapmmP W
.mmW X'
ConstructorParameterMatchesmmX s
(mms t
propertyMapmmt 
.	mm Ä
DestinationName
mmÄ è
)
mmè ê
)
mmê ë
{nn 
continueoo  
;oo  !
}pp 
varqq 
propertyProjectionqq *
=qq+ ,
TryProjectMemberqq- =
(qq= >
propertyMapqq> I
)qqI J
;qqJ K
ifrr 
(rr 
propertyProjectionrr )
!=rr* ,
nullrr- 1
)rr1 2
{ss !
propertiesProjectionstt -
.tt- .
Addtt. 1
(tt1 2
Bindtt2 6
(tt6 7
propertyMaptt7 B
.ttB C
DestinationMemberttC T
,ttT U
propertyProjectionttV h
)tth i
)tti j
;ttj k
}uu 
}vv 
}ww 

Expressionxx 
TryProjectMemberxx '
(xx' (
	MemberMapxx( 1
	memberMapxx2 ;
,xx; <

Expressionxx= G
defaultSourcexxH U
=xxV W
nullxxX \
)xx\ ]
{yy 
MemberProjectionzz  
memberProjectionzz! 1
=zz2 3
newzz4 7
(zz7 8
	memberMapzz8 A
)zzA B
;zzB C
letPropertyMaps{{ 
.{{  
Push{{  $
({{$ %
memberProjection{{% 5
){{5 6
;{{6 7
var|| 
memberExpression|| $
=||% &
ShouldExpand||' 3
(||3 4
)||4 5
?||6 7
ProjectMemberCore||8 I
(||I J
)||J K
:||L M
null||N R
;||R S
letPropertyMaps}} 
.}}  
Pop}}  #
(}}# $
)}}$ %
;}}% &
return~~ 
memberExpression~~ '
;~~' (
bool 
ShouldExpand !
(! "
)" #
=>$ &
	memberMap' 0
.0 1
ExplicitExpansion1 B
!=C E
trueF J
||K M
requestN U
.U V
ShouldExpandV b
(b c
letPropertyMapsc r
.r s
GetCurrentPath	s Å
(
Å Ç
)
Ç É
)
É Ñ
;
Ñ Ö

Expression
ÄÄ 
ProjectMemberCore
ÄÄ ,
(
ÄÄ, -
)
ÄÄ- .
{
ÅÅ 
var
ÇÇ 
memberTypeMap
ÇÇ %
=
ÇÇ& '
_configuration
ÇÇ( 6
.
ÇÇ6 7
ResolveTypeMap
ÇÇ7 E
(
ÇÇE F
	memberMap
ÇÇF O
.
ÇÇO P

SourceType
ÇÇP Z
,
ÇÇZ [
	memberMap
ÇÇ\ e
.
ÇÇe f
DestinationType
ÇÇf u
)
ÇÇu v
;
ÇÇv w
var
ÉÉ 
resolvedSource
ÉÉ &
=
ÉÉ' (
ResolveSource
ÉÉ) 6
(
ÉÉ6 7
)
ÉÉ7 8
;
ÉÉ8 9
memberProjection
ÑÑ $
.
ÑÑ$ %

Expression
ÑÑ% /
??=
ÑÑ0 3
resolvedSource
ÑÑ4 B
;
ÑÑB C
var
ÖÖ 
memberRequest
ÖÖ %
=
ÖÖ& '
request
ÖÖ( /
.
ÖÖ/ 0
InnerRequest
ÖÖ0 <
(
ÖÖ< =
resolvedSource
ÖÖ= K
.
ÖÖK L
Type
ÖÖL P
,
ÖÖP Q
	memberMap
ÖÖR [
.
ÖÖ[ \
DestinationType
ÖÖ\ k
)
ÖÖk l
;
ÖÖl m
if
ÜÜ 
(
ÜÜ 
memberRequest
ÜÜ $
.
ÜÜ$ %
AlreadyExists
ÜÜ% 2
&&
ÜÜ3 5
depth
ÜÜ6 ;
>=
ÜÜ< >
_configuration
ÜÜ? M
.
ÜÜM N&
RecursiveQueriesMaxDepth
ÜÜN f
)
ÜÜf g
{
áá 
return
àà 
null
àà #
;
àà# $
}
ââ 

Expression
ää 
mappedExpression
ää /
;
ää/ 0
if
ãã 
(
ãã 
memberTypeMap
ãã $
!=
ãã% '
null
ãã( ,
)
ãã, -
{
åå 
mappedExpression
çç (
=
çç) *
CreateProjection
çç+ ;
(
çç; <
memberRequest
çç< I
,
ççI J
letPropertyMaps
ççK Z
,
ççZ [
memberTypeMap
çç\ i
,
ççi j
PolymorphicMaps
ççk z
(
ççz {
memberTypeMapçç{ à
)ççà â
,ççâ ä
resolvedSourceççã ô
)ççô ö
;ççö õ
if
éé 
(
éé 
mappedExpression
éé +
!=
éé, .
null
éé/ 3
&&
éé4 6
memberTypeMap
éé7 D
.
ééD E!
CustomMapExpression
ééE X
==
ééY [
null
éé\ `
&&
ééa c
	memberMap
ééd m
.
éém n*
AllowsNullDestinationValueséén â
&&ééä å
resolvedSource
èè *
is
èè+ -
not
èè. 1!
ParameterExpression
èè2 E
&&
èèF H
!
èèI J
resolvedSource
èèJ X
.
èèX Y
Type
èèY ]
.
èè] ^
IsCollection
èè^ j
(
èèj k
)
èèk l
)
èèl m
{
êê 
mappedExpression
íí ,
=
íí- .
resolvedSource
íí/ =
.
íí= >

IfNullElse
íí> H
(
ííH I
Default
ííI P
(
ííP Q
mappedExpression
ííQ a
.
íía b
Type
ííb f
)
ííf g
,
ííg h
mappedExpression
ííi y
)
ííy z
;
ííz {
}
ìì 
}
îî 
else
ïï 
{
ññ 
var
óó 
projectionMapper
óó ,
=
óó- .!
GetProjectionMapper
óó/ B
(
óóB C
)
óóC D
;
óóD E
mappedExpression
òò (
=
òò) *
projectionMapper
òò+ ;
.
òò; <
Project
òò< C
(
òòC D
_configuration
òòD R
,
òòR S
memberRequest
òòT a
,
òòa b
resolvedSource
òòc q
,
òòq r
letPropertyMapsòòs Ç
)òòÇ É
;òòÉ Ñ
}
ôô 
return
öö 
mappedExpression
öö +
==
öö, .
null
öö/ 3
?
öö4 5
null
öö6 :
:
öö; <
	memberMap
öö= F
.
ööF G
ApplyTransformers
ööG X
(
ööX Y
mappedExpression
ööY i
,
ööi j
_configuration
öök y
)
ööy z
;
ööz {

Expression
õõ 
ResolveSource
õõ ,
(
õõ, -
)
õõ- .
{
úú 
var
ùù 
customSource
ùù (
=
ùù) *
	memberMap
ùù+ 4
.
ùù4 5
IncludedMember
ùù5 C
?
ùùC D
.
ùùD E#
ProjectToCustomSource
ùùE Z
;
ùùZ [
var
ûû 
resolvedSource
ûû *
=
ûû+ ,
	memberMap
ûû- 6
switch
ûû7 =
{
üü 
{
†† !
CustomMapExpression
†† 1
:
††1 2
LambdaExpression
††3 C
mapFrom
††D K
}
††L M
=>
††N P
MapFromExpression
††Q b
(
††b c
mapFrom
††c j
)
††j k
,
††k l
{
°° 
SourceMembers
°° +
.
°°+ ,
Length
°°, 2
:
°°2 3
>
°°4 5
$num
°°6 7
}
°°8 9
=>
°°: <
	memberMap
°°= F
.
°°F G 
ChainSourceMembers
°°G Y
(
°°Y Z
CheckCustomSource
°°Z k
(
°°k l
)
°°l m
)
°°m n
,
°°n o
_
¢¢ 
=>
¢¢  
defaultSource
¢¢! .
??
¢¢/ 1
throw
¢¢2 7
	CannotMap
¢¢8 A
(
¢¢A B
	memberMap
¢¢B K
,
¢¢K L
request
¢¢M T
.
¢¢T U

SourceType
¢¢U _
)
¢¢_ `
}
££ 
;
££ 
if
§§ 
(
§§ 
NullSubstitute
§§ )
(
§§) *
)
§§* +
)
§§+ ,
{
•• 
return
¶¶ "
	memberMap
¶¶# ,
.
¶¶, -
NullSubstitute
¶¶- ;
(
¶¶; <
resolvedSource
¶¶< J
)
¶¶J K
;
¶¶K L
}
ßß 
return
®® 
resolvedSource
®® -
;
®®- .

Expression
©© "
MapFromExpression
©©# 4
(
©©4 5
LambdaExpression
©©5 E
mapFrom
©©F M
)
©©M N
{
™™ 
if
´´ 
(
´´ 
memberTypeMap
´´ ,
==
´´- /
null
´´0 4
||
´´5 7
letPropertyMaps
´´8 G
.
´´G H
	IsDefault
´´H Q
||
´´R T
mapFrom
´´U \
.
´´\ ]
IsMemberPath
´´] i
(
´´i j
out
´´j m
_
´´n o
)
´´o p
||
´´q s
mapFrom
´´t {
.
´´{ |
Body´´| Ä
is´´Å É#
ParameterExpression´´Ñ ó
)´´ó ò
{
¨¨ 
return
≠≠  &
mapFrom
≠≠' .
.
≠≠. /
ReplaceParameters
≠≠/ @
(
≠≠@ A
CheckCustomSource
≠≠A R
(
≠≠R S
)
≠≠S T
)
≠≠T U
;
≠≠U V
}
ÆÆ 
if
ØØ 
(
ØØ 
customSource
ØØ +
==
ØØ, .
null
ØØ/ 3
)
ØØ3 4
{
∞∞ 
memberProjection
±±  0
.
±±0 1

Expression
±±1 ;
=
±±< =
mapFrom
±±> E
;
±±E F
return
≤≤  &
letPropertyMaps
≤≤' 6
.
≤≤6 7
GetSubQueryMarker
≤≤7 H
(
≤≤H I
mapFrom
≤≤I P
)
≤≤P Q
;
≤≤Q R
}
≥≥ 
var
¥¥ 

newMapFrom
¥¥  *
=
¥¥+ ,
IncludedMember
¥¥- ;
.
¥¥; <
Chain
¥¥< A
(
¥¥A B
customSource
¥¥B N
,
¥¥N O
mapFrom
¥¥P W
)
¥¥W X
;
¥¥X Y
memberProjection
µµ ,
.
µµ, -

Expression
µµ- 7
=
µµ8 9

newMapFrom
µµ: D
;
µµD E
return
∂∂ "
letPropertyMaps
∂∂# 2
.
∂∂2 3
GetSubQueryMarker
∂∂3 D
(
∂∂D E

newMapFrom
∂∂E O
)
∂∂O P
;
∂∂P Q
}
∑∑ 
bool
∏∏ 
NullSubstitute
∏∏ +
(
∏∏+ ,
)
∏∏, -
=>
∏∏. 0
	memberMap
∏∏1 :
.
∏∏: ;
NullSubstitute
∏∏; I
!=
∏∏J L
null
∏∏M Q
&&
∏∏R T
resolvedSource
∏∏U c
is
∏∏d f
MemberExpression
∏∏g w
&&
∏∏x z
(
∏∏{ |
resolvedSource∏∏| ä
.∏∏ä ã
Type∏∏ã è
.∏∏è ê
IsNullableType∏∏ê û
(∏∏û ü
)∏∏ü †
||∏∏° £
resolvedSource∏∏§ ≤
.∏∏≤ ≥
Type∏∏≥ ∑
==∏∏∏ ∫
typeof∏∏ª ¡
(∏∏¡ ¬
string∏∏¬ »
)∏∏» …
)∏∏…  
;∏∏  À

Expression
ππ "
CheckCustomSource
ππ# 4
(
ππ4 5
)
ππ5 6
{
∫∫ 
if
ªª 
(
ªª 
customSource
ªª +
==
ªª, .
null
ªª/ 3
)
ªª3 4
{
ºº 
return
ΩΩ  &
instanceParameter
ΩΩ' 8
;
ΩΩ8 9
}
ææ 
return
øø "
customSource
øø# /
.
øø/ 0
IsMemberPath
øø0 <
(
øø< =
out
øø= @
_
øøA B
)
øøB C
||
øøD F
letPropertyMaps
øøG V
.
øøV W
	IsDefault
øøW `
?
øøa b
customSource
øøc o
.
øøo p 
ReplaceParametersøøp Å
(øøÅ Ç!
instanceParameterøøÇ ì
)øøì î
:øøï ñ
letPropertyMapsøøó ¶
.øø¶ ß!
GetSubQueryMarkerøøß ∏
(øø∏ π
customSourceøøπ ≈
)øø≈ ∆
;øø∆ «
}
¿¿ 
}
¡¡ 
IProjectionMapper
¬¬ %!
GetProjectionMapper
¬¬& 9
(
¬¬9 :
)
¬¬: ;
{
√√ 
var
ƒƒ 
context
ƒƒ #
=
ƒƒ$ %
	memberMap
ƒƒ& /
.
ƒƒ/ 0
Types
ƒƒ0 5
(
ƒƒ5 6
)
ƒƒ6 7
;
ƒƒ7 8
foreach
≈≈ 
(
≈≈  
var
≈≈  #
mapper
≈≈$ *
in
≈≈+ - 
_projectionMappers
≈≈. @
)
≈≈@ A
{
∆∆ 
if
«« 
(
«« 
mapper
«« %
.
««% &
IsMatch
««& -
(
««- .
context
««. 5
)
««5 6
)
««6 7
{
»» 
return
……  &
mapper
……' -
;
……- .
}
   
}
ÀÀ 
throw
ÃÃ 
	CannotMap
ÃÃ '
(
ÃÃ' (
	memberMap
ÃÃ( 1
,
ÃÃ1 2
resolvedSource
ÃÃ3 A
.
ÃÃA B
Type
ÃÃB F
)
ÃÃF G
;
ÃÃG H
}
ÕÕ 
}
ŒŒ 
}
œœ 
NewExpression
–– 
CreateDestination
–– +
(
––+ ,
)
––, -
=>
––. 0
typeMap
––1 8
switch
––9 ?
{
—— 
{
““ "
CustomCtorExpression
““ &
:
““& '
LambdaExpression
““( 8
ctorExpression
““9 G
}
““H I
=>
““J L
(
““M N
NewExpression
““N [
)
““[ \
ctorExpression
““\ j
.
““j k
ReplaceParameters
““k |
(
““| } 
instanceParameter““} é
)““é è
,““è ê
{
”” 
ConstructorMap
””  
:
””  !
{
””" #

CanResolve
””$ .
:
””. /
true
””0 4
}
””5 6
constructorMap
””7 E
}
””F G
=>
””H J
New
‘‘ 
(
‘‘ 
constructorMap
‘‘ &
.
‘‘& '
Ctor
‘‘' +
,
‘‘+ ,
constructorMap
‘‘- ;
.
‘‘; <

CtorParams
‘‘< F
.
‘‘F G
Select
‘‘G M
(
‘‘M N
map
‘‘N Q
=>
‘‘R T
TryProjectMember
‘‘U e
(
‘‘e f
map
‘‘f i
,
‘‘i j
map
‘‘k n
.
‘‘n o
DefaultValue
‘‘o {
(
‘‘{ |
null‘‘| Ä
)‘‘Ä Å
)‘‘Å Ç
??‘‘É Ö
Default‘‘Ü ç
(‘‘ç é
map‘‘é ë
.‘‘ë í
DestinationType‘‘í °
)‘‘° ¢
)‘‘¢ £
)‘‘£ §
,‘‘§ •
_
’’ 
=>
’’ 
New
’’ 
(
’’ 
typeMap
’’  
.
’’  !
DestinationType
’’! 0
)
’’0 1
}
÷÷ 
;
÷÷ 
}
◊◊ 	
}
ÿÿ 
static
ŸŸ 
(
AutoMapperMappingException
ŸŸ %
	CannotMap
ŸŸ& /
(
ŸŸ/ 0
	MemberMap
ŸŸ0 9
	memberMap
ŸŸ: C
,
ŸŸC D
Type
ŸŸE I

sourceType
ŸŸJ T
)
ŸŸT U
=>
ŸŸV X
new
ŸŸY \
(
ŸŸ\ ]
$"
⁄⁄ 

$str
⁄⁄
 1
{
⁄⁄1 2
	memberMap
⁄⁄2 ;
.
⁄⁄; <
SourceMember
⁄⁄< H
?
⁄⁄H I
.
⁄⁄I J
DeclaringType
⁄⁄J W
?
⁄⁄W X
.
⁄⁄X Y
Name
⁄⁄Y ]
}
⁄⁄] ^
$str
⁄⁄^ _
{
⁄⁄_ `
	memberMap
⁄⁄` i
.
⁄⁄i j
SourceMember
⁄⁄j v
?
⁄⁄v w
.
⁄⁄w x
Name
⁄⁄x |
}
⁄⁄| }
$str
⁄⁄} 
{⁄⁄ Ä

sourceType⁄⁄Ä ä
}⁄⁄ä ã
$str⁄⁄ã ê
{⁄⁄ê ë
	memberMap⁄⁄ë ö
.⁄⁄ö õ
DestinationType⁄⁄õ ™
.⁄⁄™ ´
Name⁄⁄´ Ø
}⁄⁄Ø ∞
$str⁄⁄∞ ±
{⁄⁄± ≤
	memberMap⁄⁄≤ ª
.⁄⁄ª º
DestinationName⁄⁄º À
}⁄⁄À Ã
$str⁄⁄Ã Œ
{⁄⁄Œ œ
	memberMap⁄⁄œ ÿ
.⁄⁄ÿ Ÿ
DestinationType⁄⁄Ÿ Ë
}⁄⁄Ë È
$str⁄⁄È Í
"⁄⁄Í Î
,⁄⁄Î Ï
null
€€ 
,
€€ 
	memberMap
€€ 
)
€€ 
;
€€ 
[
‹‹ 
EditorBrowsable
‹‹ 
(
‹‹ "
EditorBrowsableState
‹‹ )
.
‹‹) *
Never
‹‹* /
)
‹‹/ 0
]
‹‹0 1
sealed
›› 

class
›› &
FirstPassLetPropertyMaps
›› )
(
››) *"
IGlobalConfiguration
››* >
configuration
››? L
,
››L M

MemberPath
››N X

parentPath
››Y c
,
››c d
TypePairCount
››e r
builtProjections››s É
)››É Ñ
:››Ö Ü
LetPropertyMaps››á ñ
(››ñ ó
configuration››ó §
,››§ •

parentPath››¶ ∞
,››∞ ± 
builtProjections››≤ ¬
)››¬ √
{
ﬁﬁ 
readonly
ﬂﬂ 
List
ﬂﬂ 
<
ﬂﬂ 
SubQueryPath
ﬂﬂ "
>
ﬂﬂ" #
_savedPaths
ﬂﬂ$ /
=
ﬂﬂ0 1
[
ﬂﬂ2 3
]
ﬂﬂ3 4
;
ﬂﬂ4 5
public
‡‡ 
override
‡‡ 

Expression
‡‡ "
GetSubQueryMarker
‡‡# 4
(
‡‡4 5
LambdaExpression
‡‡5 E
letExpression
‡‡F S
)
‡‡S T
{
·· 	
SubQueryPath
‚‚ 
subQueryPath
‚‚ %
=
‚‚& '
new
‚‚( +
(
‚‚+ ,
[
‚‚, -
..
‚‚- /
_currentPath
‚‚/ ;
.
‚‚; <
Reverse
‚‚< C
(
‚‚C D
)
‚‚D E
]
‚‚E F
,
‚‚F G
letExpression
‚‚H U
)
‚‚U V
;
‚‚V W
var
„„ 
existingPath
„„ 
=
„„ 
_savedPaths
„„ *
.
„„* +
SingleOrDefault
„„+ :
(
„„: ;
s
„„; <
=>
„„= ?
s
„„@ A
.
„„A B
IsEquivalentTo
„„B P
(
„„P Q
subQueryPath
„„Q ]
)
„„] ^
)
„„^ _
;
„„_ `
if
‰‰ 
(
‰‰ 
existingPath
‰‰ 
.
‰‰ 
Marker
‰‰ #
!=
‰‰$ &
null
‰‰' +
)
‰‰+ ,
{
ÂÂ 
return
ÊÊ 
existingPath
ÊÊ #
.
ÊÊ# $
Marker
ÊÊ$ *
;
ÊÊ* +
}
ÁÁ 
_savedPaths
ËË 
.
ËË 
Add
ËË 
(
ËË 
subQueryPath
ËË (
)
ËË( )
;
ËË) *
return
ÈÈ 
subQueryPath
ÈÈ 
.
ÈÈ  
Marker
ÈÈ  &
;
ÈÈ& '
}
ÍÍ 	
public
ÎÎ 
override
ÎÎ 
int
ÎÎ 
Count
ÎÎ !
=>
ÎÎ" $
_savedPaths
ÎÎ% 0
.
ÎÎ0 1
Count
ÎÎ1 6
;
ÎÎ6 7
public
ÏÏ 
override
ÏÏ 
bool
ÏÏ 
	IsDefault
ÏÏ &
=>
ÏÏ' )
false
ÏÏ* /
;
ÏÏ/ 0
public
ÌÌ 
override
ÌÌ 
LetPropertyMaps
ÌÌ '
New
ÌÌ( +
(
ÌÌ+ ,
)
ÌÌ, -
=>
ÌÌ. 0
new
ÌÌ1 4&
FirstPassLetPropertyMaps
ÌÌ5 M
(
ÌÌM N
Configuration
ÌÌN [
,
ÌÌ[ \
GetCurrentPath
ÌÌ] k
(
ÌÌk l
)
ÌÌl m
,
ÌÌm n
BuiltProjections
ÌÌo 
)ÌÌ Ä
;ÌÌÄ Å
public
ÓÓ 
override
ÓÓ 
QueryExpressions
ÓÓ (#
GetSubQueryExpression
ÓÓ) >
(
ÓÓ> ?
ProjectionBuilder
ÓÓ? P
builder
ÓÓQ X
,
ÓÓX Y

Expression
ÓÓZ d

projection
ÓÓe o
,
ÓÓo p
TypeMap
ÓÓq x
typeMapÓÓy Ä
,ÓÓÄ Å
inÓÓÇ Ñ!
ProjectionRequestÓÓÖ ñ
requestÓÓó û
,ÓÓû ü#
ParameterExpressionÓÓ† ≥!
instanceParameterÓÓ¥ ≈
)ÓÓ≈ ∆
{
ÔÔ 	
var
 
letMapInfos
 
=
 
_savedPaths
 )
.
) *
Select
* 0
(
0 1
path
1 5
=>
6 8
(
ÒÒ 
path
ÒÒ 
.
ÒÒ 
LetExpression
ÒÒ #
,
ÒÒ# $
MapFromSource
ÚÚ 
:
ÚÚ 
path
ÚÚ  $
.
ÚÚ$ %!
GetSourceExpression
ÚÚ% 8
(
ÚÚ8 9
instanceParameter
ÚÚ9 J
)
ÚÚJ K
,
ÚÚK L
Property
ÛÛ 
:
ÛÛ 
path
ÛÛ 
.
ÛÛ  $
GetPropertyDescription
ÛÛ  6
(
ÛÛ6 7
)
ÛÛ7 8
,
ÛÛ8 9
path
ÙÙ 
.
ÙÙ 
Marker
ÙÙ 
)
ÙÙ 
)
ÙÙ 
.
ÙÙ 
ToArray
ÙÙ %
(
ÙÙ% &
)
ÙÙ& '
;
ÙÙ' (
var
ıı 

properties
ıı 
=
ıı 
letMapInfos
ıı (
.
ıı( )
Select
ıı) /
(
ıı/ 0
m
ıı0 1
=>
ıı2 4
m
ıı5 6
.
ıı6 7
Property
ıı7 ?
)
ıı? @
.
ıı@ A
Concat
ııA G
(
ııG H!
GePropertiesVisitor
ııH [
.
ıı[ \
Retrieve
ıı\ d
(
ııd e

projection
ııe o
,
ııo p 
instanceParameterııq Ç
)ııÇ É
)ııÉ Ñ
;ııÑ Ö
var
ˆˆ 
letType
ˆˆ 
=
ˆˆ 
ProxyGenerator
ˆˆ (
.
ˆˆ( )
GetSimilarType
ˆˆ) 7
(
ˆˆ7 8
typeof
ˆˆ8 >
(
ˆˆ> ?
object
ˆˆ? E
)
ˆˆE F
,
ˆˆF G

properties
ˆˆH R
)
ˆˆR S
;
ˆˆS T
TypeMap
˜˜ 

letTypeMap
˜˜ 
;
˜˜ 
lock
¯¯ 
(
¯¯ 
Configuration
¯¯ 
)
¯¯ 
{
˘˘ 

letTypeMap
˙˙ 
=
˙˙ 
new
˙˙  
(
˙˙  !
request
˙˙! (
.
˙˙( )

SourceType
˙˙) 3
,
˙˙3 4
letType
˙˙5 <
,
˙˙< =
typeMap
˙˙> E
.
˙˙E F
Profile
˙˙F M
,
˙˙M N
null
˙˙O S
)
˙˙S T
;
˙˙T U
}
˚˚ 
var
¸¸ 
secondParameter
¸¸ 
=
¸¸  !
	Parameter
¸¸" +
(
¸¸+ ,
letType
¸¸, 3
,
¸¸3 4
$str
¸¸5 =
)
¸¸= >
;
¸¸> ?
ReplaceSubQueries
˝˝ 
(
˝˝ 
)
˝˝ 
;
˝˝  
var
˛˛ 
	letClause
˛˛ 
=
˛˛ 
builder
˛˛ #
.
˛˛# $
CreateProjection
˛˛$ 4
(
˛˛4 5
request
˛˛5 <
,
˛˛< =
base
˛˛> B
.
˛˛B C
New
˛˛C F
(
˛˛F G
)
˛˛G H
,
˛˛H I

letTypeMap
˛˛J T
,
˛˛T U
[
˛˛V W
]
˛˛W X
,
˛˛X Y
instanceParameter
˛˛Z k
)
˛˛k l
;
˛˛l m
return
ˇˇ 
new
ˇˇ 
(
ˇˇ 
Lambda
ˇˇ 
(
ˇˇ 

projection
ˇˇ (
,
ˇˇ( )
secondParameter
ˇˇ* 9
)
ˇˇ9 :
,
ˇˇ: ;
Lambda
ˇˇ< B
(
ˇˇB C
	letClause
ˇˇC L
,
ˇˇL M
instanceParameter
ˇˇN _
)
ˇˇ_ `
)
ˇˇ` a
;
ˇˇa b
void
ÄÄ 
ReplaceSubQueries
ÄÄ "
(
ÄÄ" #
)
ÄÄ# $
{
ÅÅ 
foreach
ÇÇ 
(
ÇÇ 
var
ÇÇ 

letMapInfo
ÇÇ &
in
ÇÇ' )
letMapInfos
ÇÇ* 5
)
ÇÇ5 6
{
ÉÉ 
var
ÑÑ 
letProperty
ÑÑ #
=
ÑÑ$ %
letType
ÑÑ& -
.
ÑÑ- .
GetProperty
ÑÑ. 9
(
ÑÑ9 :

letMapInfo
ÑÑ: D
.
ÑÑD E
Property
ÑÑE M
.
ÑÑM N
Name
ÑÑN R
)
ÑÑR S
;
ÑÑS T
var
ÖÖ 
letPropertyMap
ÖÖ &
=
ÖÖ' (

letTypeMap
ÖÖ) 3
.
ÖÖ3 4(
FindOrCreatePropertyMapFor
ÖÖ4 N
(
ÖÖN O
letProperty
ÖÖO Z
,
ÖÖZ [

letMapInfo
ÖÖ\ f
.
ÖÖf g
Property
ÖÖg o
.
ÖÖo p
Type
ÖÖp t
)
ÖÖt u
;
ÖÖu v
letPropertyMap
ÜÜ "
.
ÜÜ" #
MapFrom
ÜÜ# *
(
ÜÜ* +
Lambda
ÜÜ+ 1
(
ÜÜ1 2

letMapInfo
ÜÜ2 <
.
ÜÜ< =
LetExpression
ÜÜ= J
.
ÜÜJ K
ReplaceParameters
ÜÜK \
(
ÜÜ\ ]

letMapInfo
ÜÜ] g
.
ÜÜg h
MapFromSource
ÜÜh u
)
ÜÜu v
,
ÜÜv w
secondParameterÜÜx á
)ÜÜá à
)ÜÜà â
;ÜÜâ ä

projection
áá 
=
áá  

projection
áá! +
.
áá+ ,
Replace
áá, 3
(
áá3 4

letMapInfo
áá4 >
.
áá> ?
Marker
áá? E
,
ááE F
Property
ááG O
(
ááO P
secondParameter
ááP _
,
áá_ `
letProperty
ááa l
)
áál m
)
áám n
;
áán o
}
àà 

projection
ââ 
=
ââ 
new
ââ  *
ReplaceMemberAccessesVisitor
ââ! =
(
ââ= >
instanceParameter
ââ> O
,
ââO P
secondParameter
ââQ `
)
ââ` a
.
ââa b
Visit
ââb g
(
ââg h

projection
ââh r
)
ââr s
;
ââs t
}
ää 
}
ãã 	
readonly
åå 
record
åå 
struct
åå 
SubQueryPath
åå +
(
åå+ ,
MemberProjection
åå, <
[
åå< =
]
åå= >
Members
åå? F
,
ååF G
LambdaExpression
ååH X
LetExpression
ååY f
,
ååf g

Expression
ååh r
Marker
åås y
)
ååy z
{
çç 	
public
éé 
SubQueryPath
éé 
(
éé  
MemberProjection
éé  0
[
éé0 1
]
éé1 2
members
éé3 :
,
éé: ;
LambdaExpression
éé< L
letExpression
ééM Z
)
ééZ [
:
éé\ ]
this
éé^ b
(
ééb c
members
ééc j
,
ééj k
letExpression
éél y
,
ééy z
Defaultéé{ Ç
(ééÇ É
letExpressionééÉ ê
.ééê ë
Bodyééë ï
.ééï ñ
Typeééñ ö
)ééö õ
)ééõ ú
{ééú ù
}ééû ü
public
èè 

Expression
èè !
GetSourceExpression
èè 1
(
èè1 2

Expression
èè2 <
	parameter
èè= F
)
èèF G
{
êê 

Expression
ëë 
sourceExpression
ëë +
=
ëë, -
	parameter
ëë. 7
;
ëë7 8
for
íí 
(
íí 
int
íí 
index
íí 
=
íí  
$num
íí! "
;
íí" #
index
íí$ )
<
íí* +
Members
íí, 3
.
íí3 4
Length
íí4 :
-
íí; <
$num
íí= >
;
íí> ?
index
íí@ E
++
ííE G
)
ííG H
{
ìì 
var
îî 
sourceMember
îî $
=
îî% &
Members
îî' .
[
îî. /
index
îî/ 4
]
îî4 5
.
îî5 6

Expression
îî6 @
;
îî@ A
sourceExpression
ïï $
=
ïï% &
sourceMember
ïï' 3
is
ïï4 6
LambdaExpression
ïï7 G
lambda
ïïH N
?
ïïO P
lambda
ïïQ W
.
ïïW X
ReplaceParameters
ïïX i
(
ïïi j
sourceExpression
ïïj z
)
ïïz {
:
ïï| }
sourceMemberïï~ ä
;ïïä ã
}
ññ 
return
óó 
sourceExpression
óó '
;
óó' (
}
òò 
public
ôô !
PropertyDescription
ôô &$
GetPropertyDescription
ôô' =
(
ôô= >
)
ôô> ?
=>
ôô@ B
new
ôôC F
(
ôôF G
$str
ôôG K
+
ôôL M
string
ôôN T
.
ôôT U
Join
ôôU Y
(
ôôY Z
$str
ôôZ ]
,
ôô] ^
Members
ôô_ f
.
ôôf g
Select
ôôg m
(
ôôm n
p
ôôn o
=>
ôôp r
p
ôôs t
.
ôôt u
	MemberMap
ôôu ~
.
ôô~ 
DestinationNameôô é
)ôôé è
)ôôè ê
,ôôê ë
LetExpressionôôí ü
.ôôü †
Bodyôô† §
.ôô§ •
Typeôô• ©
)ôô© ™
;ôô™ ´
internal
öö 
bool
öö 
IsEquivalentTo
öö (
(
öö( )
SubQueryPath
öö) 5
other
öö6 ;
)
öö; <
=>
öö= ?
LetExpression
öö@ M
==
ööN P
other
ööQ V
.
ööV W
LetExpression
ööW d
&&
ööe g
Members
ööh o
.
ööo p
Length
ööp v
==
ööw y
other
ööz 
.öö Ä
MembersööÄ á
.ööá à
Lengthööà é
&&ööè ë
Members
õõ 
.
õõ 
Take
õõ 
(
õõ 
Members
õõ $
.
õõ$ %
Length
õõ% +
-
õõ, -
$num
õõ. /
)
õõ/ 0
.
õõ0 1
Zip
õõ1 4
(
õõ4 5
other
õõ5 :
.
õõ: ;
Members
õõ; B
,
õõB C
(
õõD E
left
õõE I
,
õõI J
right
õõK P
)
õõP Q
=>
õõR T
left
õõU Y
.
õõY Z
	MemberMap
õõZ c
==
õõd f
right
õõg l
.
õõl m
	MemberMap
õõm v
)
õõv w
.
õõw x
All
õõx {
(
õõ{ |
itemõõ| Ä
=>õõÅ É
itemõõÑ à
)õõà â
;õõâ ä
}
úú 	
sealed
ùù 
class
ùù !
GePropertiesVisitor
ùù (
(
ùù( )

Expression
ùù) 3
target
ùù4 :
)
ùù: ;
:
ùù< =
ExpressionVisitor
ùù> O
{
ûû 	
readonly
üü 

Expression
üü 
_target
üü  '
=
üü( )
target
üü* 0
;
üü0 1
public
†† 
List
†† 
<
†† 

MemberInfo
†† "
>
††" #
Members
††$ +
{
††, -
get
††. 1
;
††1 2
}
††3 4
=
††5 6
[
††7 8
]
††8 9
;
††9 :
	protected
°° 
override
°° 

Expression
°° )
VisitMember
°°* 5
(
°°5 6
MemberExpression
°°6 F
node
°°G K
)
°°K L
{
¢¢ 
if
££ 
(
££ 
node
££ 
.
££ 

Expression
££ "
==
££# %
_target
££& -
)
££- .
{
§§ 
Members
•• 
.
•• 
TryAdd
•• "
(
••" #
node
••# '
.
••' (
Member
••( .
)
••. /
;
••/ 0
}
¶¶ 
return
ßß 
base
ßß 
.
ßß 
VisitMember
ßß '
(
ßß' (
node
ßß( ,
)
ßß, -
;
ßß- .
}
®® 
public
©© 
static
©© 
IEnumerable
©© %
<
©©% &!
PropertyDescription
©©& 9
>
©©9 :
Retrieve
©©; C
(
©©C D

Expression
©©D N

expression
©©O Y
,
©©Y Z

Expression
©©[ e
target
©©f l
)
©©l m
{
™™ !
GePropertiesVisitor
´´ #
visitor
´´$ +
=
´´, -
new
´´. 1
(
´´1 2
target
´´2 8
)
´´8 9
;
´´9 :
visitor
¨¨ 
.
¨¨ 
Visit
¨¨ 
(
¨¨ 

expression
¨¨ (
)
¨¨( )
;
¨¨) *
return
≠≠ 
visitor
≠≠ 
.
≠≠ 
Members
≠≠ &
.
≠≠& '
Select
≠≠' -
(
≠≠- .
member
≠≠. 4
=>
≠≠5 7
new
≠≠8 ;!
PropertyDescription
≠≠< O
(
≠≠O P
member
≠≠P V
.
≠≠V W
Name
≠≠W [
,
≠≠[ \
member
≠≠] c
.
≠≠c d
GetMemberType
≠≠d q
(
≠≠q r
)
≠≠r s
)
≠≠s t
)
≠≠t u
;
≠≠u v
}
ÆÆ 
}
ØØ 	
sealed
∞∞ 
class
∞∞ *
ReplaceMemberAccessesVisitor
∞∞ 1
(
∞∞1 2

Expression
∞∞2 <
	oldObject
∞∞= F
,
∞∞F G

Expression
∞∞H R
	newObject
∞∞S \
)
∞∞\ ]
:
∞∞^ _
ExpressionVisitor
∞∞` q
{
±± 	
readonly
≤≤ 

Expression
≤≤ 

_oldObject
≤≤  *
=
≤≤+ ,
	oldObject
≤≤- 6
,
≤≤6 7

_newObject
≤≤8 B
=
≤≤C D
	newObject
≤≤E N
;
≤≤N O
	protected
≥≥ 
override
≥≥ 

Expression
≥≥ )
VisitMember
≥≥* 5
(
≥≥5 6
MemberExpression
≥≥6 F
node
≥≥G K
)
≥≥K L
{
¥¥ 
if
µµ 
(
µµ 
node
µµ 
.
µµ 

Expression
µµ "
!=
µµ# %

_oldObject
µµ& 0
)
µµ0 1
{
∂∂ 
return
∑∑ 
base
∑∑ 
.
∑∑  
VisitMember
∑∑  +
(
∑∑+ ,
node
∑∑, 0
)
∑∑0 1
;
∑∑1 2
}
∏∏ 
return
ππ 
PropertyOrField
ππ &
(
ππ& '

_newObject
ππ' 1
,
ππ1 2
node
ππ3 7
.
ππ7 8
Member
ππ8 >
.
ππ> ?
Name
ππ? C
)
ππC D
;
ππD E
}
∫∫ 
}
ªª 	
}
ºº 
}ΩΩ 
[ææ 
EditorBrowsable
ææ 
(
ææ "
EditorBrowsableState
ææ %
.
ææ% &
Never
ææ& +
)
ææ+ ,
]
ææ, -
publicøø 
class
øø 
LetPropertyMaps
øø 
{¿¿ 
	protected
¡¡ 
private
¡¡ 
readonly
¡¡ 
Stack
¡¡ $
<
¡¡$ %
MemberProjection
¡¡% 5
>
¡¡5 6
_currentPath
¡¡7 C
=
¡¡D E
[
¡¡F G
]
¡¡G H
;
¡¡H I
readonly
¬¬ 

MemberPath
¬¬ 
_parentPath
¬¬ #
;
¬¬# $
	protected
√√ 
internal
√√ 
LetPropertyMaps
√√ &
(
√√& '"
IGlobalConfiguration
√√' ;
configuration
√√< I
,
√√I J

MemberPath
√√K U

parentPath
√√V `
,
√√` a
TypePairCount
√√b o
builtProjections√√p Ä
)√√Ä Å
{
ƒƒ 
Configuration
≈≈ 
=
≈≈ 
configuration
≈≈ %
;
≈≈% &
BuiltProjections
∆∆ 
=
∆∆ 
builtProjections
∆∆ +
;
∆∆+ ,
_parentPath
«« 
=
«« 

parentPath
««  
;
««  !
}
»» 
	protected
…… 
TypePairCount
…… 
BuiltProjections
…… ,
{
……- .
get
……/ 2
;
……2 3
}
……4 5
public
   

int
   
IncrementDepth
   
(
   
in
    
ProjectionRequest
  ! 2
request
  3 :
)
  : ;
{
ÀÀ 
if
ÃÃ 

(
ÃÃ 
BuiltProjections
ÃÃ 
.
ÃÃ 
TryGetValue
ÃÃ (
(
ÃÃ( )
request
ÃÃ) 0
,
ÃÃ0 1
out
ÃÃ2 5
var
ÃÃ6 9
depth
ÃÃ: ?
)
ÃÃ? @
)
ÃÃ@ A
{
ÕÕ 	
depth
ŒŒ 
++
ŒŒ 
;
ŒŒ 
}
œœ 	
BuiltProjections
–– 
[
–– 
request
––  
]
––  !
=
––" #
depth
––$ )
;
––) *
return
—— 
depth
—— 
;
—— 
}
““ 
public
”” 

virtual
”” 

Expression
”” 
GetSubQueryMarker
”” /
(
””/ 0
LambdaExpression
””0 @
letExpression
””A N
)
””N O
=>
””P R
letExpression
””S `
.
””` a
Body
””a e
;
””e f
public
‘‘ 

void
‘‘ 
Push
‘‘ 
(
‘‘ 
MemberProjection
‘‘ %
memberProjection
‘‘& 6
)
‘‘6 7
=>
‘‘8 :
_currentPath
‘‘; G
.
‘‘G H
Push
‘‘H L
(
‘‘L M
memberProjection
‘‘M ]
)
‘‘] ^
;
‘‘^ _
public
’’ 


MemberPath
’’ 
GetCurrentPath
’’ $
(
’’$ %
)
’’% &
=>
’’' )
_parentPath
’’* 5
.
’’5 6
Concat
’’6 <
(
’’< =
_currentPath
÷÷ 
.
÷÷ 
Reverse
÷÷ 
(
÷÷ 
)
÷÷ 
.
÷÷ 
Select
÷÷ %
(
÷÷% &
p
÷÷& '
=>
÷÷( *
(
÷÷+ ,
p
÷÷, -
.
÷÷- .
	MemberMap
÷÷. 7
as
÷÷8 :
PropertyMap
÷÷; F
)
÷÷F G
?
÷÷G H
.
÷÷H I
DestinationMember
÷÷I Z
)
÷÷Z [
.
÷÷[ \
Where
÷÷\ a
(
÷÷a b
p
÷÷b c
=>
÷÷d f
p
÷÷g h
!=
÷÷i k
null
÷÷l p
)
÷÷p q
)
÷÷q r
;
÷÷r s
public
◊◊ 

void
◊◊ 
Pop
◊◊ 
(
◊◊ 
)
◊◊ 
=>
◊◊ 
_currentPath
◊◊ %
.
◊◊% &
Pop
◊◊& )
(
◊◊) *
)
◊◊* +
;
◊◊+ ,
public
ÿÿ 

virtual
ÿÿ 
int
ÿÿ 
Count
ÿÿ 
=>
ÿÿ 
$num
ÿÿ  !
;
ÿÿ! "
public
ŸŸ 
"
IGlobalConfiguration
ŸŸ 
Configuration
ŸŸ  -
{
ŸŸ. /
get
ŸŸ0 3
;
ŸŸ3 4
}
ŸŸ5 6
public
⁄⁄ 

virtual
⁄⁄ 
LetPropertyMaps
⁄⁄ "
New
⁄⁄# &
(
⁄⁄& '
)
⁄⁄' (
=>
⁄⁄) +
new
⁄⁄, /
(
⁄⁄/ 0
Configuration
⁄⁄0 =
,
⁄⁄= >
GetCurrentPath
⁄⁄? M
(
⁄⁄M N
)
⁄⁄N O
,
⁄⁄O P
BuiltProjections
⁄⁄Q a
)
⁄⁄a b
;
⁄⁄b c
public
€€ 

virtual
€€ 
QueryExpressions
€€ ##
GetSubQueryExpression
€€$ 9
(
€€9 :
ProjectionBuilder
€€: K
builder
€€L S
,
€€S T

Expression
€€U _

projection
€€` j
,
€€j k
TypeMap
€€l s
typeMap
€€t {
,
€€{ |
in
€€} !
ProjectionRequest€€Ä ë
request€€í ô
,€€ô ö#
ParameterExpression€€õ Æ!
instanceParameter€€Ø ¿
)€€¿ ¡
=>
‹‹ 

default
‹‹ 
;
‹‹ 
public
›› 

virtual
›› 
bool
›› 
	IsDefault
›› !
=>
››" $
true
››% )
;
››) *
}ﬁﬁ 
[ﬂﬂ 
EditorBrowsable
ﬂﬂ 
(
ﬂﬂ "
EditorBrowsableState
ﬂﬂ %
.
ﬂﬂ% &
Never
ﬂﬂ& +
)
ﬂﬂ+ ,
]
ﬂﬂ, -
public‡‡ 
readonly
‡‡ 
record
‡‡ 
struct
‡‡ 
QueryExpressions
‡‡ .
(
‡‡. /
LambdaExpression
‡‡/ ?

Projection
‡‡@ J
,
‡‡J K
LambdaExpression
‡‡L \
	LetClause
‡‡] f
=
‡‡g h
null
‡‡i m
)
‡‡m n
{·· 
public
‚‚ 

QueryExpressions
‚‚ 
(
‚‚ 

Expression
‚‚ &

projection
‚‚' 1
,
‚‚1 2!
ParameterExpression
‚‚3 F
	parameter
‚‚G P
)
‚‚P Q
:
‚‚R S
this
‚‚T X
(
‚‚X Y

projection
‚‚Y c
==
‚‚d f
null
‚‚g k
?
‚‚l m
null
‚‚n r
:
‚‚s t
Lambda
‚‚u {
(
‚‚{ |

projection‚‚| Ü
,‚‚Ü á
	parameter‚‚à ë
)‚‚ë í
)‚‚í ì
{‚‚î ï
}‚‚ñ ó
public
„„ 

bool
„„ 
Empty
„„ 
=>
„„ 

Projection
„„ #
==
„„$ &
null
„„' +
;
„„+ ,
public
‰‰ 

T
‰‰ 
Chain
‰‰ 
<
‰‰ 
T
‰‰ 
>
‰‰ 
(
‰‰ 
T
‰‰ 
source
‰‰ 
,
‰‰ 
Func
‰‰  $
<
‰‰$ %
T
‰‰% &
,
‰‰& '
LambdaExpression
‰‰( 8
,
‰‰8 9
T
‰‰: ;
>
‰‰; <
select
‰‰= C
)
‰‰C D
=>
‰‰E G
	LetClause
‰‰H Q
==
‰‰R T
null
‰‰U Y
?
‰‰Z [
select
‰‰\ b
(
‰‰b c
source
‰‰c i
,
‰‰i j

Projection
‰‰k u
)
‰‰u v
:
‰‰w x
select
‰‰y 
(‰‰ Ä
select‰‰Ä Ü
(‰‰Ü á
source‰‰á ç
,‰‰ç é
	LetClause‰‰è ò
)‰‰ò ô
,‰‰ô ö

Projection‰‰õ •
)‰‰• ¶
;‰‰¶ ß
internal
ÂÂ 
QueryExpressions
ÂÂ 
Prepare
ÂÂ %
(
ÂÂ% &
bool
ÂÂ& *2
$enableNullPropagationForQueryMapping
ÂÂ+ O
,
ÂÂO P
object
ÂÂQ W

parameters
ÂÂX b
)
ÂÂb c
{
ÊÊ 
return
ÁÁ 
new
ÁÁ 
(
ÁÁ 
Prepare
ÁÁ 
(
ÁÁ 

Projection
ÁÁ %
)
ÁÁ% &
,
ÁÁ& '
Prepare
ÁÁ( /
(
ÁÁ/ 0
	LetClause
ÁÁ0 9
)
ÁÁ9 :
)
ÁÁ: ;
;
ÁÁ; <
LambdaExpression
ËË 
Prepare
ËË  
(
ËË  !

Expression
ËË! +
cachedExpression
ËË, <
)
ËË< =
{
ÈÈ 	
var
ÍÍ 
result
ÍÍ 
=
ÍÍ 

parameters
ÍÍ #
==
ÍÍ$ &
null
ÍÍ' +
?
ÍÍ, -
cachedExpression
ÍÍ. >
:
ÍÍ? @
ParameterVisitor
ÍÍA Q
.
ÍÍQ R
SetParameters
ÍÍR _
(
ÍÍ_ `

parameters
ÍÍ` j
,
ÍÍj k
cachedExpression
ÍÍl |
)
ÍÍ| }
;
ÍÍ} ~
return
ÎÎ 
(
ÎÎ 
LambdaExpression
ÎÎ $
)
ÎÎ$ %
(
ÎÎ% &2
$enableNullPropagationForQueryMapping
ÎÎ& J
?
ÎÎK L#
NullsafeQueryRewriter
ÎÎM b
.
ÎÎb c
	NullCheck
ÎÎc l
(
ÎÎl m
result
ÎÎm s
)
ÎÎs t
:
ÎÎu v
result
ÎÎw }
)
ÎÎ} ~
;
ÎÎ~ 
}
ÏÏ 	
}
ÌÌ 
}ÓÓ 
publicÔÔ 
sealed
ÔÔ 
record
ÔÔ 
MemberProjection
ÔÔ %
(
ÔÔ% &
	MemberMap
ÔÔ& /
	MemberMap
ÔÔ0 9
)
ÔÔ9 :
{ 
public
ÒÒ 


Expression
ÒÒ 

Expression
ÒÒ  
{
ÒÒ! "
get
ÒÒ# &
;
ÒÒ& '
set
ÒÒ( +
;
ÒÒ+ ,
}
ÒÒ- .
}ÚÚ 
abstractÛÛ 
class
ÛÛ	 
ParameterVisitor
ÛÛ 
:
ÛÛ  !
ExpressionVisitor
ÛÛ" 3
{ÙÙ 
public
ıı 

static
ıı 

Expression
ıı 
SetParameters
ıı *
(
ıı* +
object
ıı+ 1

parameters
ıı2 <
,
ıı< =

Expression
ıı> H

expression
ııI S
)
ııS T
{
ˆˆ 
ParameterVisitor
˜˜ 
visitor
˜˜  
=
˜˜! "

parameters
˜˜# -
is
˜˜. 0
ParameterBag
˜˜1 =

dictionary
˜˜> H
?
˜˜I J
new
˜˜K N
ConstantVisitor
˜˜O ^
(
˜˜^ _

dictionary
˜˜_ i
)
˜˜i j
:
˜˜k l
new
˜˜m p
PropertyVisitor˜˜q Ä
(˜˜Ä Å

parameters˜˜Å ã
)˜˜ã å
;˜˜å ç
return
¯¯ 
visitor
¯¯ 
.
¯¯ 
Visit
¯¯ 
(
¯¯ 

expression
¯¯ '
)
¯¯' (
;
¯¯( )
}
˘˘ 
	protected
˙˙ 
abstract
˙˙ 

Expression
˙˙ !
GetValue
˙˙" *
(
˙˙* +
string
˙˙+ 1
name
˙˙2 6
)
˙˙6 7
;
˙˙7 8
	protected
˚˚ 
override
˚˚ 

Expression
˚˚ !
VisitMember
˚˚" -
(
˚˚- .
MemberExpression
˚˚. >
node
˚˚? C
)
˚˚C D
{
¸¸ 
var
˝˝ 
member
˝˝ 
=
˝˝ 
node
˝˝ 
.
˝˝ 
Member
˝˝  
;
˝˝  !
if
˛˛ 

(
˛˛ 
!
˛˛ 
member
˛˛ 
.
˛˛ 
DeclaringType
˛˛ !
.
˛˛! "
Has
˛˛" %
<
˛˛% &(
CompilerGeneratedAttribute
˛˛& @
>
˛˛@ A
(
˛˛A B
)
˛˛B C
)
˛˛C D
{
ˇˇ 	
return
ÄÄ 
base
ÄÄ 
.
ÄÄ 
VisitMember
ÄÄ #
(
ÄÄ# $
node
ÄÄ$ (
)
ÄÄ( )
;
ÄÄ) *
}
ÅÅ 	
var
ÇÇ 
parameterName
ÇÇ 
=
ÇÇ 
member
ÇÇ "
.
ÇÇ" #
Name
ÇÇ# '
;
ÇÇ' (
var
ÉÉ 
parameterValue
ÉÉ 
=
ÉÉ 
GetValue
ÉÉ %
(
ÉÉ% &
parameterName
ÉÉ& 3
)
ÉÉ3 4
;
ÉÉ4 5
if
ÑÑ 

(
ÑÑ 
parameterValue
ÑÑ 
==
ÑÑ 
null
ÑÑ "
)
ÑÑ" #
{
ÖÖ 	
const
ÜÜ 
string
ÜÜ 
VbPrefix
ÜÜ !
=
ÜÜ" #
$str
ÜÜ$ 0
;
ÜÜ0 1
if
áá 
(
áá 
!
áá 
parameterName
áá 
.
áá 

StartsWith
áá )
(
áá) *
VbPrefix
áá* 2
,
áá2 3
StringComparison
áá4 D
.
ááD E
Ordinal
ááE L
)
ááL M
||
ááN P
(
ááQ R
parameterValue
ááR `
=
ááa b
GetValue
áác k
(
áák l
parameterName
áál y
[
ááy z
VbPrefixááz Ç
.ááÇ É
LengthááÉ â
..ááâ ã
]ááã å
)ááå ç
)ááç é
==ááè ë
nullááí ñ
)ááñ ó
{
àà 
return
ââ 
base
ââ 
.
ââ 
VisitMember
ââ '
(
ââ' (
node
ââ( ,
)
ââ, -
;
ââ- .
}
ää 
}
ãã 	
return
åå 
ToType
åå 
(
åå 
parameterValue
åå $
,
åå$ %
member
åå& ,
.
åå, -
GetMemberType
åå- :
(
åå: ;
)
åå; <
)
åå< =
;
åå= >
}
çç 
sealed
éé 

class
éé 
PropertyVisitor
éé  
(
éé  !
object
éé! '

parameters
éé( 2
)
éé2 3
:
éé4 5
ParameterVisitor
éé6 F
{
èè 
readonly
êê 
object
êê 
_parameters
êê #
=
êê$ %

parameters
êê& 0
;
êê0 1
	protected
ëë 
override
ëë 

Expression
ëë %
GetValue
ëë& .
(
ëë. /
string
ëë/ 5
name
ëë6 :
)
ëë: ;
{
íí 	
var
ìì 
matchingMember
ìì 
=
ìì  
_parameters
ìì! ,
.
ìì, -
GetType
ìì- 4
(
ìì4 5
)
ìì5 6
.
ìì6 7
GetProperty
ìì7 B
(
ììB C
name
ììC G
)
ììG H
;
ììH I
return
îî 
matchingMember
îî !
!=
îî" $
null
îî% )
?
îî* +
Property
îî, 4
(
îî4 5
Constant
îî5 =
(
îî= >
_parameters
îî> I
)
îîI J
,
îîJ K
matchingMember
îîL Z
)
îîZ [
:
îî\ ]
null
îî^ b
;
îîb c
}
ïï 	
}
ññ 
sealed
óó 

class
óó 
ConstantVisitor
óó  
(
óó  !
ParameterBag
óó! -
paramValues
óó. 9
)
óó9 :
:
óó; <
ParameterVisitor
óó= M
{
òò 
readonly
ôô 
ParameterBag
ôô 
_paramValues
ôô *
=
ôô+ ,
paramValues
ôô- 8
;
ôô8 9
	protected
öö 
override
öö 

Expression
öö %
GetValue
öö& .
(
öö. /
string
öö/ 5
name
öö6 :
)
öö: ;
=>
öö< >
_paramValues
öö? K
.
ööK L
TryGetValue
ööL W
(
ööW X
name
ööX \
,
öö\ ]
out
öö^ a
object
ööb h
parameterValue
ööi w
)
ööw x
?
ööy z
Constantöö{ É
(ööÉ Ñ
parameterValueööÑ í
)ööí ì
:ööî ï
nullööñ ö
;ööö õ
}
õõ 
}úú 
[ùù 
EditorBrowsable
ùù 
(
ùù "
EditorBrowsableState
ùù %
.
ùù% &
Never
ùù& +
)
ùù+ ,
]
ùù, -
[ûû 
DebuggerDisplay
ûû 
(
ûû 
$str
ûû <
)
ûû< =
]
ûû= >
publicüü 
readonly
üü 
record
üü 
struct
üü 
ProjectionRequest
üü /
(
üü/ 0
Type
üü0 4

SourceType
üü5 ?
,
üü? @
Type
üüA E
DestinationType
üüF U
,
üüU V

MemberPath
üüW a
[
üüa b
]
üüb c
MembersToExpand
üüd s
,
üüs t
ICollectionüüu Ä
<üüÄ Å!
ProjectionRequestüüÅ í
>üüí ì 
PreviousRequestsüüî §
)üü§ •
{†† 
public
°° 

ProjectionRequest
°° 
InnerRequest
°° )
(
°°) *
Type
°°* .

sourceType
°°/ 9
,
°°9 :
Type
°°; ?
destinationType
°°@ O
)
°°O P
{
¢¢ 
var
££ 
previousRequests
££ 
=
££ 
PreviousRequests
££ /
.
££/ 0
ToList
££0 6
(
££6 7
)
££7 8
;
££8 9
previousRequests
§§ 
.
§§ 
TryAdd
§§ 
(
§§  
this
§§  $
)
§§$ %
;
§§% &
return
•• 
new
•• 
(
•• 

sourceType
•• 
,
•• 
destinationType
•• .
,
••. /
MembersToExpand
••0 ?
,
••? @
previousRequests
••A Q
)
••Q R
;
••R S
}
¶¶ 
public
ßß 

bool
ßß 
AlreadyExists
ßß 
=>
ßß  
PreviousRequests
ßß! 1
.
ßß1 2
Contains
ßß2 :
(
ßß: ;
this
ßß; ?
)
ßß? @
;
ßß@ A
public
®® 

bool
®® 
Equals
®® 
(
®® 
ProjectionRequest
®® (
other
®®) .
)
®®. /
=>
®®0 2

SourceType
®®3 =
==
®®> @
other
®®A F
.
®®F G

SourceType
®®G Q
&&
®®R T
DestinationType
®®U d
==
®®e g
other
®®h m
.
®®m n
DestinationType
®®n }
&&®®~ Ä
MembersToExpand
©© 
.
©© 
SequenceEqual
©© %
(
©©% &
other
©©& +
.
©©+ ,
MembersToExpand
©©, ;
)
©©; <
;
©©< =
public
™™ 

override
™™ 
int
™™ 
GetHashCode
™™ #
(
™™# $
)
™™$ %
{
´´ 
HashCode
¨¨ 
hashCode
¨¨ 
=
¨¨ 
new
¨¨ 
(
¨¨  
)
¨¨  !
;
¨¨! "
hashCode
≠≠ 
.
≠≠ 
Add
≠≠ 
(
≠≠ 

SourceType
≠≠ 
)
≠≠  
;
≠≠  !
hashCode
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ 
DestinationType
ÆÆ $
)
ÆÆ$ %
;
ÆÆ% &
foreach
ØØ 
(
ØØ 
var
ØØ 
member
ØØ 
in
ØØ 
MembersToExpand
ØØ .
)
ØØ. /
{
∞∞ 	
hashCode
±± 
.
±± 
Add
±± 
(
±± 
member
±± 
)
±±  
;
±±  !
}
≤≤ 	
return
≥≥ 
hashCode
≥≥ 
.
≥≥ 

ToHashCode
≥≥ "
(
≥≥" #
)
≥≥# $
;
≥≥$ %
}
¥¥ 
public
µµ 

bool
µµ 
ShouldExpand
µµ 
(
µµ 

MemberPath
µµ '
currentPath
µµ( 3
)
µµ3 4
{
∂∂ 
foreach
∑∑ 
(
∑∑ 
var
∑∑ 
memberToExpand
∑∑ #
in
∑∑$ &
MembersToExpand
∑∑' 6
)
∑∑6 7
{
∏∏ 	
if
ππ 
(
ππ 
memberToExpand
ππ 
.
ππ 

StartsWith
ππ )
(
ππ) *
currentPath
ππ* 5
)
ππ5 6
)
ππ6 7
{
∫∫ 
return
ªª 
true
ªª 
;
ªª 
}
ºº 
}
ΩΩ 	
return
ææ 
false
ææ 
;
ææ 
}
øø 
}¿¿ ÷X
eC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\NullsafeQueryRewriter.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
;( )
internal$$ 
class$$	 !
NullsafeQueryRewriter$$ $
:$$% &
ExpressionVisitor$$' 8
{%% 
static&& 

readonly&& '
LockingConcurrentDictionary&& /
<&&/ 0
Type&&0 4
,&&4 5

Expression&&6 @
>&&@ A
Cache&&B G
=&&H I
new&&J M
(&&M N
Fallback&&N V
)&&V W
;&&W X
public(( 

static(( 

Expression(( 
	NullCheck(( &
(((& '

Expression((' 1

expression((2 <
)((< =
=>((> @
new((A D!
NullsafeQueryRewriter((E Z
(((Z [
)(([ \
.((\ ]
Visit((] b
(((b c

expression((c m
)((m n
;((n o
	protected++ 
override++ 

Expression++ !
VisitMember++" -
(++- .
MemberExpression++. >
node++? C
)++C D
{,, 
if-- 

(-- 
node-- 
==-- 
null-- 
)-- 
throw.. 
new.. !
ArgumentNullException.. +
(..+ ,
nameof.., 2
(..2 3
node..3 7
)..7 8
)..8 9
;..9 :
var00 
target00 
=00 
Visit00 
(00 
node00 
.00  

Expression00  *
)00* +
;00+ ,
if22 

(22 
!22 
IsSafe22 
(22 
target22 
)22 
)22 
{33 	
return55 
BeSafe55 
(55 
target55  
,55  !
node55" &
,55& '
node55( ,
.55, -
Update55- 3
)553 4
;554 5
}66 	
return88 
node88 
.88 
Update88 
(88 
target88 !
)88! "
;88" #
}99 
	protected<< 
override<< 

Expression<< !
VisitMethodCall<<" 1
(<<1 2 
MethodCallExpression<<2 F
node<<G K
)<<K L
{== 
if>> 

(>> 
node>> 
==>> 
null>> 
)>> 
throw?? 
new?? !
ArgumentNullException?? +
(??+ ,
nameof??, 2
(??2 3
node??3 7
)??7 8
)??8 9
;??9 :
varAA 
targetAA 
=AA 
VisitAA 
(AA 
nodeAA 
.AA  
ObjectAA  &
)AA& '
;AA' (
ifCC 

(CC 
!CC 
IsSafeCC 
(CC 
targetCC 
)CC 
)CC 
{DD 	
returnFF 
BeSafeFF 
(FF 
targetFF  
,FF  !
nodeFF" &
,FF& '
fallbackFF( 0
=>FF1 3
nodeFF4 8
.FF8 9
UpdateFF9 ?
(FF? @
fallbackFF@ H
,FFH I
nodeFFJ N
.FFN O
	ArgumentsFFO X
)FFX Y
)FFY Z
;FFZ [
}GG 	
varII 
	argumentsII 
=II 
VisitII 
(II 
nodeII "
.II" #
	ArgumentsII# ,
)II, -
;II- .
ifKK 

(KK 
IsExtensionMethodKK 
(KK 
nodeKK "
.KK" #
MethodKK# )
)KK) *
&&KK+ -
!KK. /
IsSafeKK/ 5
(KK5 6
	argumentsKK6 ?
[KK? @
$numKK@ A
]KKA B
)KKB C
)KKC D
{LL 	
returnNN 
BeSafeNN 
(NN 
	argumentsNN #
[NN# $
$numNN$ %
]NN% &
,NN& '
nodeNN( ,
.NN, -
UpdateNN- 3
(NN3 4
nullNN4 8
,NN8 9
	argumentsNN: C
)NNC D
,NND E
fallbackNNF N
=>NNO Q
{OO 
varPP 
argsPP 
=PP 
newPP 

ExpressionPP )
[PP) *
	argumentsPP* 3
.PP3 4
CountPP4 9
]PP9 :
;PP: ;
	argumentsQQ 
.QQ 
CopyToQQ  
(QQ  !
argsQQ! %
,QQ% &
$numQQ' (
)QQ( )
;QQ) *
argsRR 
[RR 
$numRR 
]RR 
=RR 
fallbackRR "
;RR" #
returnTT 
nodeTT 
.TT 
UpdateTT "
(TT" #
nullTT# '
,TT' (
argsTT) -
)TT- .
;TT. /
}UU 
)UU 
;UU 
}VV 	
returnXX 
nodeXX 
.XX 
UpdateXX 
(XX 
targetXX !
,XX! "
	argumentsXX# ,
)XX, -
;XX- .
}YY 
static[[ 


Expression[[ 
BeSafe[[ 
([[ 

Expression[[ '
target[[( .
,[[. /

Expression[[0 :

expression[[; E
,[[E F
Func[[G K
<[[K L

Expression[[L V
,[[V W

Expression[[X b
>[[b c
update[[d j
)[[j k
{\\ 
var]] 
fallback]] 
=]] 
Cache]] 
.]] 
GetOrAdd]] %
(]]% &
target]]& ,
.]], -
Type]]- 1
)]]1 2
;]]2 3
if__ 

(__ 
fallback__ 
!=__ 
null__ 
)__ 
{`` 	
returnbb 
updatebb 
(bb 
Coalescebb "
(bb" #
targetbb# )
,bb) *
fallbackbb+ 3
)bb3 4
)bb4 5
;bb5 6
}cc 	
varff 
targetFallbackff 
=ff 
Constantff %
(ff% &
nullff& *
,ff* +
targetff, 2
.ff2 3
Typeff3 7
)ff7 8
;ff8 9
varii 
expressionFallbackii 
=ii  
!ii! "%
IsNullableOrReferenceTypeii" ;
(ii; <

expressionii< F
.iiF G
TypeiiG K
)iiK L
?jj 
(jj 

Expressionjj 
)jj 
Defaultjj !
(jj! "

expressionjj" ,
.jj, -
Typejj- 1
)jj1 2
:jj3 4
Constantjj5 =
(jj= >
nulljj> B
,jjB C

expressionjjD N
.jjN O
TypejjO S
)jjS T
;jjT U
returnll 
	Conditionll 
(ll 
Equalll 
(ll 
targetll %
,ll% &
targetFallbackll' 5
)ll5 6
,ll6 7
expressionFallbackll8 J
,llJ K

expressionllL V
)llV W
;llW X
}mm 
staticoo 

booloo 
IsSafeoo 
(oo 

Expressionoo !

expressionoo" ,
)oo, -
{pp 
returnrr 

expressionrr 
==rr 
nullrr !
||ss 

expressionss 
.ss 
NodeTypess "
==ss# %
ExpressionTypess& 4
.ss4 5
Callss5 9
||tt 

expressiontt 
.tt 
NodeTypett "
==tt# %
ExpressionTypett& 4
.tt4 5
Constanttt5 =
||uu 
!uu %
IsNullableOrReferenceTypeuu )
(uu) *

expressionuu* 4
.uu4 5
Typeuu5 9
)uu9 :
;uu: ;
}vv 
staticxx 


Expressionxx 
Fallbackxx 
(xx 
Typexx #
typexx$ (
)xx( )
{yy 
if{{ 

({{ 
type{{ 
.{{ $
IsConstructedGenericType{{ )
&&{{* ,
type{{- 1
.{{1 2 
GenericTypeArguments{{2 F
.{{F G
Length{{G M
=={{N P
$num{{Q R
){{R S
{|| 	
return}} 
CollectionFallback}} %
(}}% &
typeof}}& ,
(}}, -
List}}- 1
<}}1 2
>}}2 3
)}}3 4
,}}4 5
type}}6 :
)}}: ;
??~~ 
CollectionFallback~~ %
(~~% &
typeof~~& ,
(~~, -
HashSet~~- 4
<~~4 5
>~~5 6
)~~6 7
,~~7 8
type~~9 =
)~~= >
;~~> ?
} 	
if
ÇÇ 

(
ÇÇ 
type
ÇÇ 
.
ÇÇ 
IsArray
ÇÇ 
)
ÇÇ 
{
ÉÉ 	
return
ÑÑ 
NewArrayInit
ÑÑ 
(
ÑÑ  
type
ÑÑ  $
.
ÑÑ$ %
GetElementType
ÑÑ% 3
(
ÑÑ3 4
)
ÑÑ4 5
)
ÑÑ5 6
;
ÑÑ6 7
}
ÖÖ 	
return
áá 
null
áá 
;
áá 
}
àà 
static
ää 


Expression
ää  
CollectionFallback
ää (
(
ää( )
Type
ää) -

definition
ää. 8
,
ää8 9
Type
ää: >
type
ää? C
)
ääC D
{
ãã 
var
åå 

collection
åå 
=
åå 

definition
åå #
.
åå# $
MakeGenericType
åå$ 3
(
åå3 4
type
åå4 8
.
åå8 9
GetTypeInfo
åå9 D
(
ååD E
)
ååE F
.
ååF G"
GenericTypeArguments
ååG [
)
åå[ \
;
åå\ ]
if
èè 

(
èè 
type
èè 
.
èè 
GetTypeInfo
èè 
(
èè 
)
èè 
.
èè 
IsAssignableFrom
èè /
(
èè/ 0

collection
èè0 :
.
èè: ;
GetTypeInfo
èè; F
(
èèF G
)
èèG H
)
èèH I
)
èèI J
{
êê 	
return
ëë 
Convert
ëë 
(
ëë 
New
ëë 
(
ëë 

collection
ëë )
)
ëë) *
,
ëë* +
type
ëë, 0
)
ëë0 1
;
ëë1 2
}
íí 	
return
îî 
null
îî 
;
îî 
}
ïï 
static
óó 

bool
óó 
IsExtensionMethod
óó !
(
óó! "

MethodInfo
óó" ,
element
óó- 4
)
óó4 5
{
òò 
return
ôô 
element
ôô 
.
ôô 
	IsDefined
ôô  
(
ôô  !
typeof
ôô! '
(
ôô' ( 
ExtensionAttribute
ôô( :
)
ôô: ;
,
ôô; <
false
ôô= B
)
ôôB C
;
ôôC D
}
öö 
static
úú 

bool
úú '
IsNullableOrReferenceType
úú )
(
úú) *
Type
úú* .
type
úú/ 3
)
úú3 4
{
ùù 
return
ûû 
!
ûû 
type
ûû 
.
ûû 
GetTypeInfo
ûû  
(
ûû  !
)
ûû! "
.
ûû" #
IsValueType
ûû# .
||
ûû/ 1
Nullable
ûû2 :
.
ûû: ;
GetUnderlyingType
ûû; L
(
ûûL M
type
ûûM Q
)
ûûQ R
!=
ûûS U
null
ûûV Z
;
ûûZ [
}
üü 
}†† ªN
ZC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\QueryableExtensions\Extensions.cs
	namespace 	

AutoMapper
 
. 
QueryableExtensions (
;( )
public 
static 
class 

Extensions 
{		 
static

 

readonly

 

MethodInfo

 
SelectMethod

 +
=

, -
typeof

. 4
(

4 5
	Queryable

5 >
)

> ?
.

? @
StaticGenericMethod

@ S
(

S T
$str

T \
,

\ ]
parametersCount

^ m
:

m n
$num

o p
)

p q
;

q r
static 


IQueryable 
Select 
( 

IQueryable '
source( .
,. /
LambdaExpression0 @
lambdaA G
)G H
=>I K
sourceL R
.R S
ProviderS [
.[ \
CreateQuery\ g
(g h
Call 
( 
SelectMethod 
. 
MakeGenericMethod +
(+ ,
source, 2
.2 3
ElementType3 >
,> ?
lambda@ F
.F G

ReturnTypeG Q
)Q R
,R S
sourceT Z
.Z [

Expression[ e
,e f
Quoteg l
(l m
lambdam s
)s t
)t u
)u v
;v w
public 

static 

IQueryable 
< 
TDestination )
>) *
	ProjectTo+ 4
<4 5
TDestination5 A
>A B
(B C
thisC G

IQueryableH R
sourceS Y
,Y Z"
IConfigurationProvider[ q
configurationr 
,	 Ä
object
Å á

parameters
à í
,
í ì
params
î ö

Expression
õ •
<
• ¶
Func
¶ ™
<
™ ´
TDestination
´ ∑
,
∑ ∏
object
π ø
>
ø ¿
>
¿ ¡
[
¡ ¬
]
¬ √
membersToExpand
ƒ ”
)
” ‘
=>
’ ◊
source 
. 
ToCore 
< 
TDestination "
>" #
(# $
configuration$ 1
,1 2

parameters3 =
,= >
membersToExpand? N
.N O
SelectO U
(U V
MemberVisitorV c
.c d
GetMemberPathd q
)q r
)r s
;s t
public"" 

static"" 

IQueryable"" 
<"" 
TDestination"" )
>"") *
	ProjectTo""+ 4
<""4 5
TDestination""5 A
>""A B
(""B C
this""C G

IQueryable""H R
source""S Y
,""Y Z"
IConfigurationProvider""[ q
configuration""r 
,	"" Ä
params## 

Expression## 
<## 
Func## 
<## 
TDestination## +
,##+ ,
object##- 3
>##3 4
>##4 5
[##5 6
]##6 7
membersToExpand##8 G
)##G H
=>##I K
source$$ 
.$$ 
	ProjectTo$$ 
($$ 
configuration$$ &
,$$& '
null$$( ,
,$$, -
membersToExpand$$. =
)$$= >
;$$> ?
public.. 

static.. 

IQueryable.. 
<.. 
TDestination.. )
>..) *
	ProjectTo..+ 4
<..4 5
TDestination..5 A
>..A B
(..B C
this..C G

IQueryable..H R
source..S Y
,..Y Z"
IConfigurationProvider..[ q
configuration..r 
,	.. Ä
ParameterBag
..Å ç

parameters
..é ò
,
..ò ô
params
..ö †
string
..° ß
[
..ß ®
]
..® ©
membersToExpand
..™ π
)
..π ∫
=>
..ª Ω
source// 
.// 
ToCore// 
<// 
TDestination// "
>//" #
(//# $
configuration//$ 1
,//1 2

parameters//3 =
,//= >
membersToExpand//? N
.//N O
Select//O U
(//U V

memberName//V `
=>//a c
ReflectionHelper//d t
.//t u
GetMemberPath	//u Ç
(
//Ç É
typeof
//É â
(
//â ä
TDestination
//ä ñ
)
//ñ ó
,
//ó ò

memberName
//ô £
)
//£ §
)
//§ •
)
//• ¶
;
//¶ ß
public88 

static88 

IQueryable88 
	ProjectTo88 &
(88& '
this88' +

IQueryable88, 6
source887 =
,88= >
Type88? C
destinationType88D S
,88S T"
IConfigurationProvider88U k
configuration88l y
)88y z
=>88{ }
source99 
.99 
	ProjectTo99 
(99 
destinationType99 (
,99( )
configuration99* 7
,997 8
null999 =
)99= >
;99> ?
publicCC 

staticCC 

IQueryableCC 
	ProjectToCC &
(CC& '
thisCC' +

IQueryableCC, 6
sourceCC7 =
,CC= >
TypeCC? C
destinationTypeCCD S
,CCS T"
IConfigurationProviderCCU k
configurationCCl y
,CCy z
ParameterBag	CC{ á

parameters
CCà í
,
CCí ì
params
CCî ö
string
CCõ °
[
CC° ¢
]
CC¢ £
membersToExpand
CC§ ≥
)
CC≥ ¥
=>
CCµ ∑
sourceDD 
.DD 
ToCoreDD 
(DD 
destinationTypeDD %
,DD% &
configurationDD' 4
,DD4 5

parametersDD6 @
,DD@ A
membersToExpandDDB Q
.DDQ R
SelectDDR X
(DDX Y

memberNameDDY c
=>DDd f
ReflectionHelperDDg w
.DDw x
GetMemberPath	DDx Ö
(
DDÖ Ü
destinationType
DDÜ ï
,
DDï ñ

memberName
DDó °
)
DD° ¢
)
DD¢ £
)
DD£ §
;
DD§ •
staticEE 


IQueryableEE 
<EE 
TResultEE 
>EE 
ToCoreEE %
<EE% &
TResultEE& -
>EE- .
(EE. /
thisEE/ 3

IQueryableEE4 >
sourceEE? E
,EEE F"
IConfigurationProviderEEG ]
configurationEE^ k
,EEk l
objectEEm s

parametersEEt ~
,EE~ 
MemberPaths
EEÄ ã!
memberPathsToExpand
EEå ü
)
EEü †
=>
EE° £
(FF 	

IQueryableFF	 
<FF 
TResultFF 
>FF 
)FF 
sourceFF #
.FF# $
ToCoreFF$ *
(FF* +
typeofFF+ 1
(FF1 2
TResultFF2 9
)FF9 :
,FF: ;
configurationFF< I
,FFI J

parametersFFK U
,FFU V
memberPathsToExpandFFW j
)FFj k
;FFk l
staticGG 


IQueryableGG 
ToCoreGG 
(GG 
thisGG !

IQueryableGG" ,
sourceGG- 3
,GG3 4
TypeGG5 9
destinationTypeGG: I
,GGI J"
IConfigurationProviderGGK a
configurationGGb o
,GGo p
objectGGq w

parameters	GGx Ç
,
GGÇ É
MemberPaths
GGÑ è!
memberPathsToExpand
GGê £
)
GG£ §
=>
GG• ß
configurationHH 
.HH 
InternalHH 
(HH 
)HH  
.HH  !
ProjectionBuilderHH! 2
.HH2 3
GetProjectionHH3 @
(HH@ A
sourceHHA G
.HHG H
ElementTypeHHH S
,HHS T
destinationTypeHHU d
,HHd e

parametersHHf p
,HHp q 
memberPathsToExpand	HHr Ö
.
HHÖ Ü
Select
HHÜ å
(
HHå ç
m
HHç é
=>
HHè ë
new
HHí ï

MemberPath
HHñ †
(
HH† °
m
HH° ¢
)
HH¢ £
)
HH£ §
.
HH§ •
ToArray
HH• ¨
(
HH¨ ≠
)
HH≠ Æ
)
HHÆ Ø
.II 	
ChainII	 
(II 
sourceII 
,II 
SelectII 
)II 
;II 
}JJ 
publicKK 
sealedKK 
classKK 
MemberVisitorKK !
:KK" #
ExpressionVisitorKK$ 5
{LL 
privateMM 
readonlyMM 
ListMM 
<MM 

MemberInfoMM $
>MM$ %
_membersMM& .
=MM/ 0
[MM1 2
]MM2 3
;MM3 4
publicNN 

staticNN 

MemberInfoNN 
[NN 
]NN 
GetMemberPathNN ,
(NN, -

ExpressionNN- 7

expressionNN8 B
)NNB C
{OO 
MemberVisitorPP 
memberVisitorPP #
=PP$ %
newPP& )
(PP) *
)PP* +
;PP+ ,
memberVisitorQQ 
.QQ 
VisitQQ 
(QQ 

expressionQQ &
)QQ& '
;QQ' (
returnRR 
[RR 
..RR 
memberVisitorRR  
.RR  !
_membersRR! )
]RR) *
;RR* +
}SS 
	protectedTT 
overrideTT 

ExpressionTT !
VisitMemberTT" -
(TT- .
MemberExpressionTT. >
nodeTT? C
)TTC D
{UU 
_membersVV 
.VV 
AddRangeVV 
(VV 
nodeVV 
.VV  
GetMemberExpressionsVV 3
(VV3 4
)VV4 5
.VV5 6
SelectVV6 <
(VV< =
eVV= >
=>VV? A
eVVB C
.VVC D
MemberVVD J
)VVJ K
)VVK L
;VVL M
returnWW 
nodeWW 
;WW 
}XX 
}YY ì_
GC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\PropertyMap.cs
	namespace 	

AutoMapper
 
; 
[ 
DebuggerDisplay 
( 
$str +
)+ ,
], -
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 
PropertyMap 
:  !
	MemberMap" +
{ 
private 
MemberMapDetails 
_details %
;% &
public 

PropertyMap 
( 

MemberInfo !
destinationMember" 3
,3 4
Type5 9!
destinationMemberType: O
,O P
TypeMapQ X
typeMapY `
)` a
:b c
based h
(h i
typeMapi p
,p q"
destinationMemberType	r á
)
á à
=>
â ã
DestinationMember		 
=		 
destinationMember		 -
;		- .
public

 

PropertyMap

 
(

 
PropertyMap

 "#
inheritedMappedProperty

# :
,

: ;
TypeMap

< C
typeMap

D K
)

K L
:

M N
base

O S
(

S T
typeMap

T [
,

[ \#
inheritedMappedProperty

] t
.

t u
DestinationType	

u Ñ
)


Ñ Ö
{ 
DestinationMember 
= #
inheritedMappedProperty 3
.3 4
DestinationMember4 E
;E F
if 

( 
DestinationMember 
. 
DeclaringType +
.+ ,%
ContainsGenericParameters, E
)E F
{ 	
DestinationMember 
= 
typeMap  '
.' (
DestinationSetters( :
.: ;
Single; A
(A B
mB C
=>D F
mG H
.H I
NameI M
==N P
DestinationMemberQ b
.b c
Namec g
)g h
;h i
} 	
if 

( 
DestinationType 
. %
ContainsGenericParameters 5
)5 6
{ 	
DestinationType 
= 
DestinationMember /
./ 0
GetMemberType0 =
(= >
)> ?
;? @
} 	%
ApplyInheritedPropertyMap !
(! "#
inheritedMappedProperty" 9
)9 :
;: ;
} 
public 

PropertyMap 
( 
PropertyMap "
includedMemberMap# 4
,4 5
TypeMap6 =
typeMap> E
,E F
IncludedMemberG U
includedMemberV d
)d e
: 	
this
 
( 
includedMemberMap  
,  !
typeMap" )
)) *
=>+ -
Details. 5
.5 6
IncludedMember6 D
=E F
includedMemberG U
.U V
ChainV [
([ \
includedMemberMap\ m
.m n
IncludedMembern |
)| }
;} ~
private 
MemberMapDetails 
Details $
=>% '
_details( 0
??=1 4
new5 8
(8 9
)9 :
;: ;
public 


MemberInfo 
DestinationMember '
{( )
get* -
;- .
}/ 0
public 

override 
string 
DestinationName *
=>+ -
DestinationMember. ?
?? @
.@ A
NameA E
;E F
public 

override 

MemberInfo 
[ 
]  
SourceMembers! .
{/ 0
get1 4
;4 5
set6 9
;9 :
}; <
== >
[? @
]@ A
;A B
public 

override 
bool 
CanBeSet !
=>" $
DestinationMember% 6
.6 7
CanBeSet7 ?
(? @
)@ A
;A B
public 

override 
bool 
Ignored  
{! "
get# &
;& '
set( +
;+ ,
}- .
public 

void %
ApplyInheritedPropertyMap )
() *
PropertyMap* 5
inheritedMap6 B
)B C
{   
ApplyInheritedMap!! 
(!! 
inheritedMap!! &
)!!& '
;!!' (
if"" 

("" 
!"" 
Ignored"" 
&&"" 
inheritedMap"" $
.""$ %
_details""% -
!="". 0
null""1 5
)""5 6
{## 	
Details$$ 
.$$ %
ApplyInheritedPropertyMap$$ -
($$- .
inheritedMap$$. :
.$$: ;
_details$$; C
)$$C D
;$$D E
}%% 	
}&& 
public'' 

override'' 
IncludedMember'' "
IncludedMember''# 1
=>''2 4
_details''5 =
?''= >
.''> ?
IncludedMember''? M
;''M N
public(( 

override(( 
bool(( 
?(( 
	AllowNull(( #
{(($ %
get((& )
=>((* ,
_details((- 5
?((5 6
.((6 7
	AllowNull((7 @
;((@ A
set((B E
=>((F H
Details((I P
.((P Q
	AllowNull((Q Z
=(([ \
value((] b
;((b c
}((d e
public)) 

int)) 
?)) 
MappingOrder)) 
{)) 
get)) "
=>))# %
_details))& .
?)). /
.))/ 0
MappingOrder))0 <
;))< =
set))> A
=>))B D
Details))E L
.))L M
MappingOrder))M Y
=))Z [
value))\ a
;))a b
}))c d
public** 

override** 
bool** 
?** 
ExplicitExpansion** +
{**, -
get**. 1
=>**2 4
_details**5 =
?**= >
.**> ?
ExplicitExpansion**? P
;**P Q
set**R U
=>**V X
Details**Y `
.**` a
ExplicitExpansion**a r
=**s t
value**u z
;**z {
}**| }
public++ 

override++ 
bool++ 
?++ 
UseDestinationValue++ -
{++. /
get++0 3
=>++4 6
_details++7 ?
?++? @
.++@ A
UseDestinationValue++A T
;++T U
set++V Y
=>++Z \
Details++] d
.++d e
UseDestinationValue++e x
=++y z
value	++{ Ä
;
++Ä Å
}
++Ç É
public,, 

override,, 
object,, 
NullSubstitute,, )
{,,* +
get,,, /
=>,,0 2
_details,,3 ;
?,,; <
.,,< =
NullSubstitute,,= K
;,,K L
set,,M P
=>,,Q S
Details,,T [
.,,[ \
NullSubstitute,,\ j
=,,k l
value,,m r
;,,r s
},,t u
public-- 

override-- 
LambdaExpression-- $
PreCondition--% 1
{--2 3
get--4 7
=>--8 :
_details--; C
?--C D
.--D E
PreCondition--E Q
;--Q R
set--S V
=>--W Y
Details--Z a
.--a b
PreCondition--b n
=--o p
value--q v
;--v w
}--x y
public.. 

override.. 
LambdaExpression.. $
	Condition..% .
{../ 0
get..1 4
=>..5 7
_details..8 @
?..@ A
...A B
	Condition..B K
;..K L
set..M P
=>..Q S
Details..T [
...[ \
	Condition..\ e
=..f g
value..h m
;..m n
}..o p
public// 

void// "
AddValueTransformation// &
(//& ')
ValueTransformerConfiguration//' D
config//E K
)//K L
=>//M O
Details//P W
.//W X"
AddValueTransformation//X n
(//n o
config//o u
)//u v
;//v w
public00 

override00 
IReadOnlyCollection00 '
<00' ()
ValueTransformerConfiguration00( E
>00E F
ValueTransformers00G X
=>00Y [
(00\ ]
_details00] e
?00e f
.00f g
ValueTransformers00g x
)00x y
.00y z
	NullCheck	00z É
(
00É Ñ
)
00Ñ Ö
;
00Ö Ü
class11 	
MemberMapDetails11
 
{22 
public33 
List33 
<33 )
ValueTransformerConfiguration33 1
>331 2
ValueTransformers333 D
{33E F
get33G J
;33J K
private33L S
set33T W
;33W X
}33Y Z
public44 
bool44 
?44 
	AllowNull44 
;44 
public55 
int55 
?55 
MappingOrder55  
;55  !
public66 
bool66 
?66 
ExplicitExpansion66 &
;66& '
public77 
bool77 
?77 
UseDestinationValue77 (
;77( )
public88 
object88 
NullSubstitute88 $
;88$ %
public99 
LambdaExpression99 
PreCondition99  ,
;99, -
public:: 
LambdaExpression:: 
	Condition::  )
;::) *
public;; 
IncludedMember;; 
IncludedMember;; ,
;;;, -
public<< 
void<< %
ApplyInheritedPropertyMap<< -
(<<- .
MemberMapDetails<<. >#
inheritedMappedProperty<<? V
)<<V W
{== 	
	AllowNull>> 
??=>> #
inheritedMappedProperty>> 1
.>>1 2
	AllowNull>>2 ;
;>>; <
	Condition?? 
??=?? #
inheritedMappedProperty?? 1
.??1 2
	Condition??2 ;
;??; <
PreCondition@@ 
??=@@ #
inheritedMappedProperty@@ 4
.@@4 5
PreCondition@@5 A
;@@A B
NullSubstituteAA 
??=AA #
inheritedMappedPropertyAA 6
.AA6 7
NullSubstituteAA7 E
;AAE F
MappingOrderBB 
??=BB #
inheritedMappedPropertyBB 4
.BB4 5
MappingOrderBB5 A
;BBA B
UseDestinationValueCC 
??=CC  ##
inheritedMappedPropertyCC$ ;
.CC; <
UseDestinationValueCC< O
;CCO P
ExplicitExpansionDD 
??=DD !#
inheritedMappedPropertyDD" 9
.DD9 :
ExplicitExpansionDD: K
;DDK L
ifEE 
(EE #
inheritedMappedPropertyEE '
.EE' (
ValueTransformersEE( 9
!=EE: <
nullEE= A
)EEA B
{FF 
ValueTransformersGG !
??=GG" %
[GG& '
]GG' (
;GG( )
ValueTransformersHH !
.HH! "
InsertRangeHH" -
(HH- .
$numHH. /
,HH/ 0#
inheritedMappedPropertyHH1 H
.HHH I
ValueTransformersHHI Z
)HHZ [
;HH[ \
}II 
}JJ 	
publicKK 
voidKK "
AddValueTransformationKK *
(KK* +)
ValueTransformerConfigurationKK+ H)
valueTransformerConfigurationKKI f
)KKf g
{LL 	
ValueTransformersMM 
??=MM !
[MM" #
]MM# $
;MM$ %
ValueTransformersNN 
.NN 
AddNN !
(NN! ")
valueTransformerConfigurationNN" ?
)NN? @
;NN@ A
}OO 	
}PP 
}QQ Ö¬
FC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\ProfileMap.cs
	namespace 	

AutoMapper
 
; 
[ 
DebuggerDisplay 
( 
$str 
) 
] 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 

ProfileMap 
{ 
private 
static 
readonly 
HashSet #
<# $
string$ *
>* +
EmptyHashSet, 8
=9 :
[; <
]< =
;= >
private		  
TypeMapConfiguration		  
[		  !
]		! "
_typeMapConfigs		# 2
;		2 3
private

 

Dictionary

 
<

 
TypePair

 
,

   
TypeMapConfiguration

! 5
>

5 6
_openTypeMapConfigs

7 J
;

J K
private 

Dictionary 
< 
Type 
, 
TypeDetails (
>( )
_typeDetails* 6
;6 7
private 
	LazyValue 
<  
ConcurrentDictionary *
<* +
Type+ /
,/ 0
TypeDetails1 <
>< =
>= >
_runtimeTypeDetails? R
;R S
public 


ProfileMap 
( !
IProfileConfiguration +
profile, 3
,3 4*
IGlobalConfigurationExpression5 S
configurationT a
=b c
nulld h
)h i
{ 
var 
globalProfile 
= 
( !
IProfileConfiguration 2
)2 3
configuration3 @
;@ A
Name 
= 
profile 
. 
ProfileName "
;" # 
AllowNullCollections 
= 
profile &
.& ' 
AllowNullCollections' ;
??< >
configuration? L
?L M
.M N 
AllowNullCollectionsN b
??c e
falsef k
;k l&
AllowNullDestinationValues "
=# $
profile% ,
., -&
AllowNullDestinationValues- G
??H J
configurationK X
?X Y
.Y Z&
AllowNullDestinationValuesZ t
??u w
truex |
;| }0
$EnableNullPropagationForQueryMapping ,
=- .
profile/ 6
.6 70
$EnableNullPropagationForQueryMapping7 [
??\ ^
configuration_ l
?l m
.m n1
$EnableNullPropagationForQueryMapping	n í
??
ì ï
false
ñ õ
;
õ ú%
ConstructorMappingEnabled !
=" #
profile$ +
.+ ,%
ConstructorMappingEnabled, E
??F H
globalProfileI V
?V W
.W X%
ConstructorMappingEnabledX q
??r t
trueu y
;y z 
MethodMappingEnabled 
= 
profile &
.& ' 
MethodMappingEnabled' ;
??< >
globalProfile? L
?L M
.M N 
MethodMappingEnabledN b
??c e
truef j
;j k
FieldMappingEnabled 
= 
profile %
.% &
FieldMappingEnabled& 9
??: <
globalProfile= J
?J K
.K L
FieldMappingEnabledL _
??` b
truec g
;g h
ShouldMapField 
= 
profile  
.  !
ShouldMapField! /
??0 2
configuration3 @
?@ A
.A B
ShouldMapFieldB P
??Q S
(T U
pU V
=>W Y
pZ [
.[ \
IsPublic\ d
)d e
;e f
ShouldMapProperty 
= 
profile #
.# $
ShouldMapProperty$ 5
??6 8
configuration9 F
?F G
.G H
ShouldMapPropertyH Y
??Z \
(] ^
p^ _
=>` b
pc d
.d e
IsPublice m
(m n
)n o
)o p
;p q
ShouldMapMethod 
= 
profile !
.! "
ShouldMapMethod" 1
??2 4
configuration5 B
?B C
.C D
ShouldMapMethodD S
??T V
(W X
pX Y
=>Z \
!] ^
p^ _
._ `
IsSpecialName` m
)m n
;n o 
ShouldUseConstructor 
= 
profile &
.& ' 
ShouldUseConstructor' ;
??< >
configuration? L
?L M
.M N 
ShouldUseConstructorN b
??c e
(f g
cg h
=>i k
truel p
)p q
;q r
ValueTransformers 
= 
profile #
.# $
ValueTransformers$ 5
.5 6
Concat6 <
(< =
configuration= J
?J K
.K L
ValueTransformersL ]
)] ^
.^ _
ToArray_ f
(f g
)g h
;h i
var 
profileInternal 
= 
( &
IProfileExpressionInternal 9
)9 :
profile: A
;A B
MemberConfiguration 
= 
profileInternal -
.- .
MemberConfiguration. A
;A B
if 

(
 
configuration 
== 
null  
)  !
{ 	
MemberConfiguration   
.    "
SourceNamingConvention    6
??=  7 :&
PascalCaseNamingConvention  ; U
.  U V
Instance  V ^
;  ^ _
MemberConfiguration!! 
.!!  '
DestinationNamingConvention!!  ;
??=!!< ?&
PascalCaseNamingConvention!!@ Z
.!!Z [
Instance!![ c
;!!c d
}"" 	
else## 
{$$ 	
MemberConfiguration%% 
.%%  
Merge%%  %
(%%% &
configuration%%& 3
.%%3 4
Internal%%4 <
(%%< =
)%%= >
.%%> ?
MemberConfiguration%%? R
)%%R S
;%%S T
}&& 	
var'' 
globalIgnores'' 
='' 
profile'' #
.''# $
GlobalIgnores''$ 1
.''1 2
Concat''2 8
(''8 9
globalProfile''9 F
?''F G
.''G H
GlobalIgnores''H U
)''U V
;''V W
GlobalIgnores(( 
=(( 
globalIgnores(( %
==((& (
Array(() .
.((. /
Empty((/ 4
<((4 5
string((5 ;
>((; <
(((< =
)((= >
?((? @
EmptyHashSet((A M
:((N O
[((P Q
..((Q S
globalIgnores((S `
]((` a
;((a b"
SourceExtensionMethods)) 
=))  
profile))! (
.))( )"
SourceExtensionMethods))) ?
.))? @
Concat))@ F
())F G
globalProfile))G T
?))T U
.))U V"
SourceExtensionMethods))V l
)))l m
.))m n
ToArray))n u
())u v
)))v w
;))w x!
AllPropertyMapActions** 
=** 
profile**  '
.**' (!
AllPropertyMapActions**( =
.**= >
Concat**> D
(**D E
globalProfile**E R
?**R S
.**S T!
AllPropertyMapActions**T i
)**i j
.**j k
ToArray**k r
(**r s
)**s t
;**t u
AllTypeMapActions++ 
=++ 
profile++ #
.++# $
AllTypeMapActions++$ 5
.++5 6
Concat++6 <
(++< =
globalProfile++= J
?++J K
.++K L
AllTypeMapActions++L ]
)++] ^
.++^ _
ToArray++_ f
(++f g
)++g h
;++h i
profileInternal,, 
.,, 
MemberConfiguration,, +
.,,+ ,
Seal,,, 0
(,,0 1
),,1 2
;,,2 3
Prefixes-- 
.-- 
TryAdd-- 
(-- 
profileInternal-- '
.--' (
Prefixes--( 0
.--0 1
Concat--1 7
(--7 8
configuration--8 E
?--E F
.--F G
Prefixes--G O
)--O P
)--P Q
;--Q R
	Postfixes.. 
... 
TryAdd.. 
(.. 
profileInternal.. (
...( )
	Postfixes..) 2
...2 3
Concat..3 9
(..9 :
configuration..: G
?..G H
...H I
	Postfixes..I R
)..R S
)..S T
;..T U
TypeMapConfigs// 
(// 
)// 
;// 
OpenTypeMapConfigs00 
(00 
)00 
;00 
_typeDetails11 
=11 
new11 
(11 
$num11 
*11 
_typeMapConfigs11 .
.11. /
Length11/ 5
)115 6
;116 7
_runtimeTypeDetails22 
=22 
new22  
(22  !
(22! "
)22" #
=>22# %
new22% (
(22( )
Environment22) 4
.224 5
ProcessorCount225 C
,22C D
$num22E F
*22G H
_openTypeMapConfigs22I \
.22\ ]
Count22] b
)22b c
)22c d
;22d e
return33 
;33 
void44 
TypeMapConfigs44 
(44 
)44 
{55 	
_typeMapConfigs66 
=66 
new66 ! 
TypeMapConfiguration66" 6
[666 7
profile667 >
.66> ?
TypeMapConfigs66? M
.66M N
Count66N S
]66S T
;66T U
var77 
index77 
=77 
$num77 
;77 
var88 
reverseMapsCount88  
=88! "
$num88# $
;88$ %
foreach99 
(99 
var99 
typeMapConfig99 &
in99' )
profile99* 1
.991 2
TypeMapConfigs992 @
)99@ A
{:: 
_typeMapConfigs;; 
[;;  
index;;  %
++;;% '
];;' (
=;;) *
typeMapConfig;;+ 8
;;;8 9
if<< 
(<< 
typeMapConfig<< !
.<<! "
ReverseTypeMap<<" 0
!=<<1 3
null<<4 8
)<<8 9
{== 
reverseMapsCount>> $
++>>$ &
;>>& '
}?? 
}@@ 
TypeMapsCountAA 
=AA 
indexAA !
+AA" #
reverseMapsCountAA$ 4
;AA4 5
}BB 	
voidCC 
OpenTypeMapConfigsCC 
(CC  
)CC  !
{DD 	
_openTypeMapConfigsEE 
=EE  !
newEE" %
(EE% &
profileEE& -
.EE- .
OpenTypeMapConfigsEE. @
.EE@ A
CountEEA F
)EEF G
;EEG H
foreachFF 
(FF 
varFF 
openTypeMapConfigFF *
inFF+ -
profileFF. 5
.FF5 6
OpenTypeMapConfigsFF6 H
)FFH I
{GG 
_openTypeMapConfigsHH #
.HH# $
AddHH$ '
(HH' (
openTypeMapConfigHH( 9
.HH9 :
TypesHH: ?
,HH? @
openTypeMapConfigHHA R
)HHR S
;HHS T
varII 

reverseMapII 
=II  
openTypeMapConfigII! 2
.II2 3
ReverseTypeMapII3 A
;IIA B
ifJJ 
(JJ 

reverseMapJJ 
!=JJ !
nullJJ" &
)JJ& '
{KK 
_openTypeMapConfigsLL '
.LL' (
AddLL( +
(LL+ ,

reverseMapLL, 6
.LL6 7
TypesLL7 <
,LL< =

reverseMapLL> H
)LLH I
;LLI J
}MM 
}NN 
}OO 	
}PP 
publicQQ 

intQQ 
OpenTypeMapsCountQQ  
=>QQ! #
_openTypeMapConfigsQQ$ 7
.QQ7 8
CountQQ8 =
;QQ= >
publicRR 

intRR 
TypeMapsCountRR 
{RR 
getRR "
;RR" #
privateRR$ +
setRR, /
;RR/ 0
}RR1 2
internalSS 
voidSS 
ClearSS 
(SS 
)SS 
{TT 
_typeDetailsUU 
=UU 
nullUU 
;UU 
_typeMapConfigsVV 
=VV 
nullVV 
;VV 
}WW 
publicXX 

boolXX  
AllowNullCollectionsXX $
{XX% &
getXX' *
;XX* +
}XX, -
publicYY 

boolYY &
AllowNullDestinationValuesYY *
{YY+ ,
getYY- 0
;YY0 1
}YY2 3
publicZZ 

boolZZ %
ConstructorMappingEnabledZZ )
{ZZ* +
getZZ, /
;ZZ/ 0
}ZZ1 2
public[[ 

bool[[ 0
$EnableNullPropagationForQueryMapping[[ 4
{[[5 6
get[[7 :
;[[: ;
}[[< =
public\\ 

bool\\  
MethodMappingEnabled\\ $
{\\% &
get\\' *
;\\* +
}\\, -
public]] 

bool]] 
FieldMappingEnabled]] #
{]]$ %
get]]& )
;]]) *
}]]+ ,
public^^ 

string^^ 
Name^^ 
{^^ 
get^^ 
;^^ 
}^^ 
public__ 

Func__ 
<__ 
	FieldInfo__ 
,__ 
bool__ 
>__  
ShouldMapField__! /
{__0 1
get__2 5
;__5 6
}__7 8
public`` 

Func`` 
<`` 
PropertyInfo`` 
,`` 
bool`` "
>``" #
ShouldMapProperty``$ 5
{``6 7
get``8 ;
;``; <
}``= >
publicaa 

Funcaa 
<aa 

MethodInfoaa 
,aa 
boolaa  
>aa  !
ShouldMapMethodaa" 1
{aa2 3
getaa4 7
;aa7 8
}aa9 :
publicbb 

Funcbb 
<bb 
ConstructorInfobb 
,bb  
boolbb! %
>bb% & 
ShouldUseConstructorbb' ;
{bb< =
getbb> A
;bbA B
}bbC D
publiccc 

IEnumerablecc 
<cc 
PropertyMapActioncc (
>cc( )!
AllPropertyMapActionscc* ?
{cc@ A
getccB E
;ccE F
}ccG H
publicdd 

IEnumerabledd 
<dd 
Actiondd 
<dd 
TypeMapdd %
,dd% &
IMappingExpressiondd' 9
>dd9 :
>dd: ;
AllTypeMapActionsdd< M
{ddN O
getddP S
;ddS T
}ddU V
publicee 

HashSetee 
<ee 
stringee 
>ee 
GlobalIgnoresee (
{ee) *
getee+ .
;ee. /
}ee0 1
publicff 

MemberConfigurationff 
MemberConfigurationff 2
{ff3 4
getff5 8
;ff8 9
}ff: ;
publicgg 

IEnumerablegg 
<gg 

MethodInfogg !
>gg! ""
SourceExtensionMethodsgg# 9
{gg: ;
getgg< ?
;gg? @
}ggA B
publichh 

Listhh 
<hh 
stringhh 
>hh 
Prefixeshh  
{hh! "
gethh# &
;hh& '
}hh( )
=hh* +
[hh, -
]hh- .
;hh. /
publicii 

Listii 
<ii 
stringii 
>ii 
	Postfixesii !
{ii" #
getii$ '
;ii' (
}ii) *
=ii+ ,
[ii- .
]ii. /
;ii/ 0
publicjj 

IReadOnlyCollectionjj 
<jj )
ValueTransformerConfigurationjj <
>jj< =
ValueTransformersjj> O
{jjP Q
getjjR U
;jjU V
}jjW X
publickk 

TypeDetailskk 
CreateTypeDetailskk (
(kk( )
Typekk) -
typekk. 2
)kk2 3
{ll 
ifmm 

(mm 
_typeDetailsmm 
==mm 
nullmm  
)mm  !
{nn 	
returnoo 
_runtimeTypeDetailsoo &
.oo& '
Valueoo' ,
.oo, -
GetOrAddoo- 5
(oo5 6
typeoo6 :
,oo: ;
(oo< =
typeoo= A
,ooA B
profileooC J
)ooJ K
=>ooL N
newooO R
(ooR S
typeooS W
,ooW X
profileooY `
)oo` a
,ooa b
thisooc g
)oog h
;ooh i
}pp 	
ifqq 

(qq 
_typeDetailsqq 
.qq 
TryGetValueqq $
(qq$ %
typeqq% )
,qq) *
outqq+ .
varqq/ 2
typeDetailsqq3 >
)qq> ?
)qq? @
{rr 	
returnss 
typeDetailsss 
;ss 
}tt 	
typeDetailsuu 
=uu 
newuu 
(uu 
typeuu 
,uu 
thisuu  $
)uu$ %
;uu% &
_typeDetailsvv 
.vv 
Addvv 
(vv 
typevv 
,vv 
typeDetailsvv *
)vv* +
;vv+ ,
returnww 
typeDetailsww 
;ww 
}xx 
publicyy 

voidyy 
Registeryy 
(yy  
IGlobalConfigurationyy -
configurationyy. ;
)yy; <
{zz 
foreach{{ 
({{ 
var{{ 
config{{ 
in{{ 
_typeMapConfigs{{ .
){{. /
{|| 	
if}} 
(}} 
config}} 
.}} #
DestinationTypeOverride}} .
!=}}/ 1
null}}2 6
)}}6 7
{~~ 
continue 
; 
}
ÄÄ 
BuildTypeMap
ÅÅ 
(
ÅÅ 
configuration
ÅÅ &
,
ÅÅ& '
config
ÅÅ( .
)
ÅÅ. /
;
ÅÅ/ 0
var
ÇÇ 

reverseMap
ÇÇ 
=
ÇÇ 
config
ÇÇ #
.
ÇÇ# $
ReverseTypeMap
ÇÇ$ 2
;
ÇÇ2 3
if
ÉÉ 
(
ÉÉ 

reverseMap
ÉÉ 
!=
ÉÉ 
null
ÉÉ "
&&
ÉÉ# %

reverseMap
ÉÉ& 0
.
ÉÉ0 1%
DestinationTypeOverride
ÉÉ1 H
==
ÉÉI K
null
ÉÉL P
)
ÉÉP Q
{
ÑÑ 
BuildTypeMap
ÖÖ 
(
ÖÖ 
configuration
ÖÖ *
,
ÖÖ* +

reverseMap
ÖÖ, 6
)
ÖÖ6 7
;
ÖÖ7 8
}
ÜÜ 
}
áá 	
}
àà 
private
ââ 
void
ââ 
BuildTypeMap
ââ 
(
ââ "
IGlobalConfiguration
ââ 2
configuration
ââ3 @
,
ââ@ A"
TypeMapConfiguration
ââB V
config
ââW ]
)
ââ] ^
{
ää 
var
ãã 
sourceMembers
ãã 
=
ãã 
configuration
ãã )
.
ãã) *
SourceMembers
ãã* 7
;
ãã7 8
TypeMap
åå 
typeMap
åå 
=
åå 
new
åå 
(
åå 
config
åå $
.
åå$ %

SourceType
åå% /
,
åå/ 0
config
åå1 7
.
åå7 8
DestinationType
åå8 G
,
ååG H
this
ååI M
,
ååM N
config
ååO U
,
ååU V
sourceMembers
ååW d
)
ååd e
;
ååe f
config
çç 
.
çç 
	Configure
çç 
(
çç 
typeMap
çç  
,
çç  !
sourceMembers
çç" /
)
çç/ 0
;
çç0 1
configuration
éé 
.
éé 
RegisterTypeMap
éé %
(
éé% &
typeMap
éé& -
)
éé- .
;
éé. /
}
èè 
public
êê 

void
êê 
	Configure
êê 
(
êê "
IGlobalConfiguration
êê .
configuration
êê/ <
)
êê< =
{
ëë 
foreach
íí 
(
íí 
var
íí "
typeMapConfiguration
íí )
in
íí* ,
_typeMapConfigs
íí- <
)
íí< =
{
ìì 	
if
îî 
(
îî "
typeMapConfiguration
îî $
.
îî$ %%
DestinationTypeOverride
îî% <
!=
îî= ?
null
îî@ D
)
îîD E
{
ïï 
configuration
ññ 
.
ññ 
RegisterAsMap
ññ +
(
ññ+ ,"
typeMapConfiguration
ññ, @
)
ññ@ A
;
ññA B
continue
óó 
;
óó 
}
òò 
	Configure
ôô 
(
ôô "
typeMapConfiguration
ôô *
,
ôô* +
configuration
ôô, 9
)
ôô9 :
;
ôô: ;
var
öö 

reverseMap
öö 
=
öö "
typeMapConfiguration
öö 1
.
öö1 2
ReverseTypeMap
öö2 @
;
öö@ A
if
õõ 
(
õõ 

reverseMap
õõ 
==
õõ 
null
õõ "
)
õõ" #
{
úú 
continue
ùù 
;
ùù 
}
ûû 
if
üü 
(
üü 

reverseMap
üü 
.
üü %
DestinationTypeOverride
üü 2
==
üü3 5
null
üü6 :
)
üü: ;
{
†† 
	Configure
°° 
(
°° 

reverseMap
°° $
,
°°$ %
configuration
°°& 3
)
°°3 4
;
°°4 5
}
¢¢ 
else
££ 
{
§§ 
configuration
•• 
.
•• 
RegisterAsMap
•• +
(
••+ ,

reverseMap
••, 6
)
••6 7
;
••7 8
}
¶¶ 
}
ßß 	
}
®® 
private
©© 
void
©© 
	Configure
©© 
(
©© "
TypeMapConfiguration
©© /"
typeMapConfiguration
©©0 D
,
©©D E"
IGlobalConfiguration
©©F Z
configuration
©©[ h
)
©©h i
{
™™ 
var
´´ 
typeMap
´´ 
=
´´ "
typeMapConfiguration
´´ *
.
´´* +
TypeMap
´´+ 2
;
´´2 3
if
¨¨ 

(
¨¨ 
typeMap
¨¨ 
.
¨¨ $
IncludeAllDerivedTypes
¨¨ *
)
¨¨* +
{
≠≠ 	
IncludeAllDerived
ÆÆ 
(
ÆÆ 
configuration
ÆÆ +
,
ÆÆ+ ,
typeMap
ÆÆ- 4
)
ÆÆ4 5
;
ÆÆ5 6
}
ØØ 	
	Configure
∞∞ 
(
∞∞ 
typeMap
∞∞ 
,
∞∞ 
configuration
∞∞ (
)
∞∞( )
;
∞∞) *
}
±± 
private
≤≤ 
static
≤≤ 
void
≤≤ 
IncludeAllDerived
≤≤ )
(
≤≤) *"
IGlobalConfiguration
≤≤* >
configuration
≤≤? L
,
≤≤L M
TypeMap
≤≤N U
typeMap
≤≤V ]
)
≤≤] ^
{
≥≥ 
foreach
¥¥ 
(
¥¥ 
var
¥¥ 

derivedMap
¥¥ 
in
¥¥  "
configuration
¥¥# 0
.
¥¥0 1
GetAllTypeMaps
¥¥1 ?
(
¥¥? @
)
¥¥@ A
.
¥¥A B
Where
¥¥B G
(
¥¥G H
tm
¥¥H J
=>
¥¥K M
typeMap
µµ 
!=
µµ 
tm
µµ 
&&
µµ  
typeMap
∂∂ 
.
∂∂ 

SourceType
∂∂ "
.
∂∂" #
IsAssignableFrom
∂∂# 3
(
∂∂3 4
tm
∂∂4 6
.
∂∂6 7

SourceType
∂∂7 A
)
∂∂A B
&&
∂∂C E
typeMap
∑∑ 
.
∑∑ 
DestinationType
∑∑ '
.
∑∑' (
IsAssignableFrom
∑∑( 8
(
∑∑8 9
tm
∑∑9 ;
.
∑∑; <
DestinationType
∑∑< K
)
∑∑K L
)
∑∑L M
)
∑∑M N
{
∏∏ 	
typeMap
ππ 
.
ππ !
IncludeDerivedTypes
ππ '
(
ππ' (

derivedMap
ππ( 2
.
ππ2 3
Types
ππ3 8
)
ππ8 9
;
ππ9 :
}
∫∫ 	
}
ªª 
private
ºº 
void
ºº 
	Configure
ºº 
(
ºº 
TypeMap
ºº "
typeMap
ºº# *
,
ºº* +"
IGlobalConfiguration
ºº, @
configuration
ººA N
)
ººN O
{
ΩΩ 
if
ææ 

(
ææ 
typeMap
ææ 
.
ææ 
HasTypeConverter
ææ $
)
ææ$ %
{
øø 	
return
¿¿ 
;
¿¿ 
}
¡¡ 	
MappingExpression
¬¬ 

expression
¬¬ $
=
¬¬% &
new
¬¬' *
(
¬¬* +
typeMap
¬¬+ 2
)
¬¬2 3
;
¬¬3 4
foreach
√√ 
(
√√ 
var
√√ 
action
√√ 
in
√√ 
AllTypeMapActions
√√ /
)
√√/ 0
{
ƒƒ 	
action
≈≈ 
(
≈≈ 
typeMap
≈≈ 
,
≈≈ 

expression
≈≈ &
)
≈≈& '
;
≈≈' (
}
∆∆ 	

expression
«« 
.
«« 
	Configure
«« 
(
«« 
typeMap
«« $
,
««$ %
configuration
««& 3
.
««3 4
SourceMembers
««4 A
)
««A B
;
««B C
foreach
»» 
(
»» 
var
»» 
propertyMap
»» 
in
»»  "
typeMap
»»# *
.
»»* +
PropertyMaps
»»+ 7
)
»»7 8
{
…… 	+
MemberConfigurationExpression
   )
memberExpression
  * :
=
  ; <
null
  = A
;
  A B
foreach
ÀÀ 
(
ÀÀ 
var
ÀÀ 
action
ÀÀ 
in
ÀÀ !#
AllPropertyMapActions
ÀÀ" 7
)
ÀÀ7 8
{
ÃÃ 
if
ÕÕ 
(
ÕÕ 
!
ÕÕ 
action
ÕÕ 
.
ÕÕ 
	Condition
ÕÕ %
(
ÕÕ% &
propertyMap
ÕÕ& 1
)
ÕÕ1 2
)
ÕÕ2 3
{
ŒŒ 
continue
œœ 
;
œœ 
}
–– 
memberExpression
——  
??=
——! $
new
——% (
(
——( )
propertyMap
——) 4
.
——4 5
DestinationMember
——5 F
,
——F G
typeMap
——H O
.
——O P

SourceType
——P Z
)
——Z [
;
——[ \
action
““ 
.
““ 
Action
““ 
(
““ 
propertyMap
““ )
,
““) *
memberExpression
““+ ;
)
““; <
;
““< =
}
”” 
memberExpression
‘‘ 
?
‘‘ 
.
‘‘ 
	Configure
‘‘ '
(
‘‘' (
typeMap
‘‘( /
)
‘‘/ 0
;
‘‘0 1
}
’’ 	
ApplyBaseMaps
÷÷ 
(
÷÷ 
typeMap
÷÷ 
,
÷÷ 
typeMap
÷÷ &
,
÷÷& '
configuration
÷÷( 5
)
÷÷5 6
;
÷÷6 7
ApplyDerivedMaps
◊◊ 
(
◊◊ 
typeMap
◊◊  
,
◊◊  !
typeMap
◊◊" )
,
◊◊) *
configuration
◊◊+ 8
)
◊◊8 9
;
◊◊9 :
ApplyMemberMaps
ÿÿ 
(
ÿÿ 
typeMap
ÿÿ 
,
ÿÿ  
configuration
ÿÿ! .
)
ÿÿ. /
;
ÿÿ/ 0
}
ŸŸ 
public
⁄⁄ 

TypeMap
⁄⁄ (
CreateClosedGenericTypeMap
⁄⁄ -
(
⁄⁄- ."
TypeMapConfiguration
⁄⁄. B
openMapConfig
⁄⁄C P
,
⁄⁄P Q
TypePair
⁄⁄R Z
closedTypes
⁄⁄[ f
,
⁄⁄f g"
IGlobalConfiguration
⁄⁄h |
configuration⁄⁄} ä
)⁄⁄ä ã
{
€€ 
TypeMap
‹‹ 
	closedMap
‹‹ 
;
‹‹ 
lock
›› 
(
›› 
configuration
›› 
)
›› 
{
ﬁﬁ 	
	closedMap
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 
(
ﬂﬂ 
closedTypes
ﬂﬂ '
.
ﬂﬂ' (

SourceType
ﬂﬂ( 2
,
ﬂﬂ2 3
closedTypes
ﬂﬂ4 ?
.
ﬂﬂ? @
DestinationType
ﬂﬂ@ O
,
ﬂﬂO P
this
ﬂﬂQ U
,
ﬂﬂU V
openMapConfig
ﬂﬂW d
)
ﬂﬂd e
;
ﬂﬂe f
}
‡‡ 	
openMapConfig
·· 
.
·· 
	Configure
·· 
(
··  
	closedMap
··  )
,
··) *
configuration
··+ 8
.
··8 9
SourceMembers
··9 F
)
··F G
;
··G H
	Configure
‚‚ 
(
‚‚ 
	closedMap
‚‚ 
,
‚‚ 
configuration
‚‚ *
)
‚‚* +
;
‚‚+ ,
	closedMap
„„ 
.
„„ 
CloseGenerics
„„ 
(
„„  
openMapConfig
„„  -
,
„„- .
closedTypes
„„/ :
)
„„: ;
;
„„; <
return
‰‰ 
	closedMap
‰‰ 
;
‰‰ 
}
ÂÂ 
public
ÊÊ 
"
TypeMapConfiguration
ÊÊ 
GetGenericMap
ÊÊ  -
(
ÊÊ- .
TypePair
ÊÊ. 6
genericPair
ÊÊ7 B
)
ÊÊB C
=>
ÊÊD F!
_openTypeMapConfigs
ÊÊG Z
.
ÊÊZ [
GetValueOrDefault
ÊÊ[ l
(
ÊÊl m
genericPair
ÊÊm x
)
ÊÊx y
;
ÊÊy z
private
ÁÁ 
void
ÁÁ 
ApplyBaseMaps
ÁÁ 
(
ÁÁ 
TypeMap
ÁÁ &

derivedMap
ÁÁ' 1
,
ÁÁ1 2
TypeMap
ÁÁ3 :

currentMap
ÁÁ; E
,
ÁÁE F"
IGlobalConfiguration
ÁÁG [
configuration
ÁÁ\ i
)
ÁÁi j
{
ËË 
foreach
ÈÈ 
(
ÈÈ 
var
ÈÈ 
baseMap
ÈÈ 
in
ÈÈ 
configuration
ÈÈ  -
.
ÈÈ- .!
GetIncludedTypeMaps
ÈÈ. A
(
ÈÈA B

currentMap
ÈÈB L
.
ÈÈL M
IncludedBaseTypes
ÈÈM ^
)
ÈÈ^ _
)
ÈÈ_ `
{
ÍÍ 	
baseMap
ÎÎ 
.
ÎÎ !
IncludeDerivedTypes
ÎÎ '
(
ÎÎ' (

currentMap
ÎÎ( 2
.
ÎÎ2 3
Types
ÎÎ3 8
)
ÎÎ8 9
;
ÎÎ9 :

derivedMap
ÏÏ 
.
ÏÏ 
AddInheritedMap
ÏÏ &
(
ÏÏ& '
baseMap
ÏÏ' .
)
ÏÏ. /
;
ÏÏ/ 0
}
ÌÌ 	
}
ÓÓ 
private
ÔÔ 
void
ÔÔ 
ApplyMemberMaps
ÔÔ  
(
ÔÔ  !
TypeMap
ÔÔ! (

currentMap
ÔÔ) 3
,
ÔÔ3 4"
IGlobalConfiguration
ÔÔ5 I
configuration
ÔÔJ W
)
ÔÔW X
{
 
if
ÒÒ 

(
ÒÒ 
!
ÒÒ 

currentMap
ÒÒ 
.
ÒÒ  
HasIncludedMembers
ÒÒ *
)
ÒÒ* +
{
ÚÚ 	
return
ÛÛ 
;
ÛÛ 
}
ÙÙ 	
foreach
ıı 
(
ıı 
var
ıı &
includedMemberExpression
ıı -
in
ıı. 0

currentMap
ıı1 ;
.
ıı; <#
GetAllIncludedMembers
ıı< Q
(
ııQ R
)
ııR S
)
ııS T
{
ˆˆ 	
var
˜˜ 
includedMap
˜˜ 
=
˜˜ 
configuration
˜˜ +
.
˜˜+ , 
GetIncludedTypeMap
˜˜, >
(
˜˜> ?&
includedMemberExpression
˜˜? W
.
˜˜W X
Body
˜˜X \
.
˜˜\ ]
Type
˜˜] a
,
˜˜a b

currentMap
˜˜c m
.
˜˜m n
DestinationType
˜˜n }
)
˜˜} ~
;
˜˜~ 
IncludedMember
¯¯ 
includedMember
¯¯ )
=
¯¯* +
new
¯¯, /
(
¯¯/ 0
includedMap
¯¯0 ;
,
¯¯; <&
includedMemberExpression
¯¯= U
)
¯¯U V
;
¯¯V W
if
˘˘ 
(
˘˘ 

currentMap
˘˘ 
.
˘˘ 
AddMemberMap
˘˘ '
(
˘˘' (
includedMember
˘˘( 6
)
˘˘6 7
)
˘˘7 8
{
˙˙ 
ApplyMemberMaps
˚˚ 
(
˚˚  
includedMap
˚˚  +
,
˚˚+ ,
configuration
˚˚- :
)
˚˚: ;
;
˚˚; <
foreach
¸¸ 
(
¸¸ 
var
¸¸ %
inheritedIncludedMember
¸¸ 4
in
¸¸5 7
includedMap
¸¸8 C
.
¸¸C D%
IncludedMembersTypeMaps
¸¸D [
)
¸¸[ \
{
˝˝ 

currentMap
˛˛ 
.
˛˛ 
AddMemberMap
˛˛ +
(
˛˛+ ,
includedMember
˛˛, :
.
˛˛: ;
Chain
˛˛; @
(
˛˛@ A%
inheritedIncludedMember
˛˛A X
,
˛˛X Y
configuration
˛˛Z g
)
˛˛g h
)
˛˛h i
;
˛˛i j
}
ˇˇ 
}
ÄÄ 
}
ÅÅ 	
}
ÇÇ 
private
ÉÉ 
void
ÉÉ 
ApplyDerivedMaps
ÉÉ !
(
ÉÉ! "
TypeMap
ÉÉ" )
baseMap
ÉÉ* 1
,
ÉÉ1 2
TypeMap
ÉÉ3 :
typeMap
ÉÉ; B
,
ÉÉB C"
IGlobalConfiguration
ÉÉD X
configuration
ÉÉY f
)
ÉÉf g
{
ÑÑ 
foreach
ÖÖ 
(
ÖÖ 
var
ÖÖ 

derivedMap
ÖÖ 
in
ÖÖ  "
configuration
ÖÖ# 0
.
ÖÖ0 1!
GetIncludedTypeMaps
ÖÖ1 D
(
ÖÖD E
typeMap
ÖÖE L
)
ÖÖL M
)
ÖÖM N
{
ÜÜ 	

derivedMap
áá 
.
áá 
IncludeBaseTypes
áá '
(
áá' (
typeMap
áá( /
.
áá/ 0
Types
áá0 5
)
áá5 6
;
áá6 7

derivedMap
àà 
.
àà 
AddInheritedMap
àà &
(
àà& '
baseMap
àà' .
)
àà. /
;
àà/ 0
}
ââ 	
}
ää 
public
ãã 

bool
ãã ,
MapDestinationPropertyToSource
ãã .
(
ãã. /
TypeDetails
ãã/ :
sourceTypeDetails
ãã; L
,
ããL M
Type
ããN R
destType
ããS [
,
ãã[ \
Type
ãã] a
destMemberType
ããb p
,
ããp q
string
ããr x
destMemberNameããy á
,ããá à
Listããâ ç
<ããç é

MemberInfoããé ò
>ããò ô
membersããö °
,ãã° ¢
boolãã£ ß(
reverseNamingConventionsãã® ¿
)ãã¿ ¡
=>ãã¬ ƒ!
MemberConfiguration
åå 
.
åå 
IsMatch
åå #
(
åå# $
this
åå$ (
,
åå( )
sourceTypeDetails
åå* ;
,
åå; <
destType
åå= E
,
ååE F
destMemberType
ååG U
,
ååU V
destMemberName
ååW e
,
ååe f
members
ååg n
,
åån o'
reverseNamingConventionsååp à
)ååà â
;ååâ ä
public
çç 

bool
çç ,
AllowsNullDestinationValuesFor
çç .
(
çç. /
	MemberMap
çç/ 8
	memberMap
çç9 B
=
ççC D
null
ççE I
)
ççI J
=>
ççK M
	memberMap
ççN W
?
ççW X
.
ççX Y
	AllowNull
ççY b
??
ççc e)
AllowNullDestinationValuesççf Ä
;ççÄ Å
public
éé 

bool
éé &
AllowsNullCollectionsFor
éé (
(
éé( )
	MemberMap
éé) 2
	memberMap
éé3 <
=
éé= >
null
éé? C
)
ééC D
=>
ééE G
	memberMap
ééH Q
?
ééQ R
.
ééR S
	AllowNull
ééS \
??
éé] _"
AllowNullCollections
éé` t
;
éét u
}èè 
[êê 
EditorBrowsable
êê 
(
êê "
EditorBrowsableState
êê %
.
êê% &
Never
êê& +
)
êê+ ,
]
êê, -
[ëë 
DebuggerDisplay
ëë 
(
ëë 
$str
ëë 0
)
ëë0 1
]
ëë1 2
publicíí 
sealed
íí 
record
íí 
IncludedMember
íí #
(
íí# $
TypeMap
íí$ +
TypeMap
íí, 3
,
íí3 4
LambdaExpression
íí5 E
MemberExpression
ííF V
,
ííV W!
ParameterExpression
ííX k
Variable
ííl t
,
íít u
LambdaExpressioníív Ü%
ProjectToCustomSourceííá ú
)ííú ù
{ìì 
public
îî 

IncludedMember
îî 
(
îî 
TypeMap
îî !
typeMap
îî" )
,
îî) *
LambdaExpression
îî+ ;
memberExpression
îî< L
)
îîL M
:
îîN O
this
îîP T
(
îîT U
typeMap
îîU \
,
îî\ ]
memberExpression
îî^ n
,
îîn o

Expression
ïï 
.
ïï 
Variable
ïï 
(
ïï 
memberExpression
ïï ,
.
ïï, -
Body
ïï- 1
.
ïï1 2
Type
ïï2 6
,
ïï6 7
string
ïï8 >
.
ïï> ?
Join
ïï? C
(
ïïC D
$str
ïïD F
,
ïïF G
memberExpression
ïïH X
.
ïïX Y
GetMembersChain
ïïY h
(
ïïh i
)
ïïi j
.
ïïj k
Select
ïïk q
(
ïïq r
m
ïïr s
=>
ïït v
m
ïïw x
.
ïïx y
Name
ïïy }
)
ïï} ~
)
ïï~ 
)ïï Ä
,ïïÄ Å 
memberExpressionïïÇ í
)ïïí ì
{ïïì î
}ïïî ï
public
ññ 

IncludedMember
ññ 
Chain
ññ 
(
ññ  
IncludedMember
ññ  .
other
ññ/ 4
,
ññ4 5"
IGlobalConfiguration
ññ6 J
configuration
ññK X
=
ññY Z
null
ññ[ _
)
ññ_ `
{
óó 
if
òò 

(
òò 
other
òò 
==
òò 
null
òò 
)
òò 
{
ôô 	
return
öö 
this
öö 
;
öö 
}
õõ 	
return
úú 
new
úú 
(
úú 
other
úú 
.
úú 
TypeMap
úú  
,
úú  !
Chain
úú" '
(
úú' (
other
úú( -
.
úú- .
MemberExpression
úú. >
,
úú> ?
other
úú@ E
,
úúE F
configuration
úúG T
)
úúT U
,
úúU V
other
úúW \
.
úú\ ]
Variable
úú] e
,
úúe f
Chain
úúg l
(
úúl m
MemberExpression
úúm }
,
úú} ~
otherúú Ñ
.úúÑ Ö 
MemberExpressionúúÖ ï
)úúï ñ
)úúñ ó
;úúó ò
}
ùù 
public
ûû 

static
ûû 
LambdaExpression
ûû "
Chain
ûû# (
(
ûû( )
LambdaExpression
ûû) 9
customSource
ûû: F
,
ûûF G
LambdaExpression
ûûH X
lambda
ûûY _
)
ûû_ `
=>
ûûa c
Lambda
üü 
(
üü 
lambda
üü 
.
üü 
ReplaceParameters
üü '
(
üü' (
customSource
üü( 4
.
üü4 5
Body
üü5 9
)
üü9 :
,
üü: ;
customSource
üü< H
.
üüH I

Parameters
üüI S
)
üüS T
;
üüT U
public
†† 

LambdaExpression
†† 
Chain
†† !
(
††! "
LambdaExpression
††" 2
lambda
††3 9
)
††9 :
=>
††; =
Chain
††> C
(
††C D
lambda
††D J
,
††J K
null
††L P
,
††P Q
null
††R V
)
††V W
;
††W X
LambdaExpression
°° 
Chain
°° 
(
°° 
LambdaExpression
°° +
lambda
°°, 2
,
°°2 3
IncludedMember
°°4 B
includedMember
°°C Q
,
°°Q R"
IGlobalConfiguration
°°S g
configuration
°°h u
)
°°u v
=>
°°w y
Lambda
¢¢ 
(
¢¢ 
lambda
¢¢ 
.
¢¢ 
ReplaceParameters
¢¢ '
(
¢¢' (
Variable
¢¢( 0
)
¢¢0 1
.
¢¢1 2
	NullCheck
¢¢2 ;
(
¢¢; <
configuration
¢¢< I
,
¢¢I J
includedMember
¢¢K Y
:
¢¢Y Z
includedMember
¢¢[ i
)
¢¢i j
,
¢¢j k
lambda
¢¢l r
.
¢¢r s

Parameters
¢¢s }
)
¢¢} ~
;
¢¢~ 
public
££ 

bool
££ 
Equals
££ 
(
££ 
IncludedMember
££ %
other
££& +
)
££+ ,
=>
££- /
TypeMap
££0 7
==
££8 :
other
££; @
?
££@ A
.
££A B
TypeMap
££B I
;
££I J
public
§§ 

override
§§ 
int
§§ 
GetHashCode
§§ #
(
§§# $
)
§§$ %
=>
§§& (
TypeMap
§§) 0
.
§§0 1
GetHashCode
§§1 <
(
§§< =
)
§§= >
;
§§> ?
}•• Ω
CC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\PathMap.cs
	namespace 	

AutoMapper
 
; 
[ 
DebuggerDisplay 
( 
$str *
)* +
]+ ,
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 
PathMap 
( 
LambdaExpression ,!
destinationExpression- B
,B C

MemberPathD N

memberPathO Y
,Y Z
TypeMap[ b
typeMapc j
)j k
: 
	MemberMap 
( 
typeMap 
, 

memberPath #
.# $
Last$ (
.( )
GetMemberType) 6
(6 7
)7 8
)8 9
{ 
public 

PathMap 
( 
PathMap 
pathMap "
," #
TypeMap$ +
typeMap, 3
,3 4
IncludedMember5 C
includedMemberD R
)R S
:T U
thisV Z
(Z [
pathMap[ b
.b c!
DestinationExpressionc x
,x y
pathMap	z Å
.
Å Ç

MemberPath
Ç å
,
å ç
typeMap
é ï
)
ï ñ
{ 
IncludedMember		 
=		 
includedMember		 '
.		' (
Chain		( -
(		- .
pathMap		. 5
.		5 6
IncludedMember		6 D
)		D E
;		E F
Resolver

 
=

 
pathMap

 
.

 
Resolver

 #
;

# $
	Condition 
= 
pathMap 
. 
	Condition %
;% &
Ignored 
= 
pathMap 
. 
Ignored !
;! "
} 
public 

override 
Type 

SourceType #
=>$ &
Resolver' /
./ 0
ResolvedType0 <
;< =
public 

LambdaExpression !
DestinationExpression 1
{2 3
get4 7
;7 8
}9 :
=; <!
destinationExpression= R
;R S
public 


MemberPath 

MemberPath  
{! "
get# &
;& '
}( )
=* +

memberPath, 6
;6 7
public 

override 
string 
DestinationName *
=>+ -

MemberPath. 8
.8 9
ToString9 A
(A B
)B C
;C D
public 

override 
bool 
CanBeSet !
=>" $
ReflectionHelper% 5
.5 6
CanBeSet6 >
(> ?

MemberPath? I
.I J
LastJ N
)N O
;O P
public 

override 
bool 
Ignored  
{! "
get# &
;& '
set( +
;+ ,
}- .
public 

override 
IncludedMember "
IncludedMember# 1
{2 3
get4 7
;7 8
	protected9 B
setC F
;F G
}H I
public 

override 
LambdaExpression $
	Condition% .
{/ 0
get1 4
;4 5
set6 9
;9 :
}; <
} ‰|
EC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\MemberMap.cs
	namespace 	

AutoMapper
 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
class 
	MemberMap 
: 
IValueResolver '
{ 
private 
	protected 
Type 
_sourceType &
;& '
	protected		 
	MemberMap		 
(		 
TypeMap		 
typeMap		  '
,		' (
Type		) -
destinationType		. =
)		= >
=>		? A
(		B C
TypeMap		C J
,		J K
DestinationType		L [
)		[ \
=		] ^
(		_ `
typeMap		` g
,		g h
destinationType		i x
)		x y
;		y z
internal

 
static

 
readonly

 
	MemberMap

 &
Instance

' /
=

0 1
new

2 5
(

5 6
null

6 :
,

: ;
null

< @
)

@ A
;

A B
public 

TypeMap 
TypeMap 
{ 
get  
;  !
	protected" +
set, /
;/ 0
}1 2
public 

LambdaExpression 
CustomMapExpression /
=>0 2
Resolver3 ;
?; <
.< =
ProjectToExpression= P
;P Q
public 

bool 
IsResolveConfigured #
=>$ &
Resolver' /
!=0 2
null3 7
&&8 :
Resolver; C
!=D F
thisG K
;K L
public 

void 
MapFrom 
( 
LambdaExpression (
lambda) /
)/ 0
=>1 3
SetResolver4 ?
(? @
new@ C
ExpressionResolverD V
(V W
lambdaW ]
)] ^
)^ _
;_ `
public 

void 
SetResolver 
( 
IValueResolver *
resolver+ 3
)3 4
{ 
Resolver 
= 
resolver 
; 
_sourceType 
= 
resolver 
. 
ResolvedType +
;+ ,
Ignored 
= 
false 
; 
} 
public 

virtual 
Type 

SourceType "
=># %
_sourceType& 1
??=2 5
GetSourceType6 C
(C D
)D E
;E F
public 

virtual 

MemberInfo 
[ 
] 
SourceMembers  -
{. /
get0 3
=>4 6
[7 8
]8 9
;9 :
set; >
{? @
}A B
}C D
public 

virtual 
IncludedMember !
IncludedMember" 0
{1 2
get3 6
=>7 9
default: A
;A B
	protectedC L
setM P
{Q R
}S T
}U V
public 

virtual 
string 
DestinationName )
=>* ,
default- 4
;4 5
public 

Type 
DestinationType 
{  !
get" %
;% &
	protected' 0
set1 4
;4 5
}6 7
public 

virtual 
TypePair 
Types !
(! "
)" #
=>$ &
new' *
(* +

SourceType+ 5
,5 6
DestinationType7 F
)F G
;G H
public 

bool 
CanResolveValue 
=>  "
!# $
Ignored$ +
&&, .
Resolver/ 7
!=8 :
null; ?
;? @
public 

bool 
IsMapped 
=> 
Ignored #
||$ &
Resolver' /
!=0 2
null3 7
;7 8
public 

virtual 
bool 
Ignored 
{  !
get" %
=>& (
default) 0
;0 1
set2 5
{6 7
}8 9
}: ;
public 

virtual 
bool 
? 
ExplicitExpansion *
{+ ,
get- 0
=>1 3
default4 ;
;; <
set= @
{A B
}C D
}E F
public 

virtual 
bool 
Inline 
{  
get! $
;$ %
set& )
;) *
}+ ,
=- .
true/ 3
;3 4
public   

virtual   
bool   
?   
	AllowNull   "
{  # $
get  % (
=>  ) +
null  , 0
;  0 1
set  2 5
{  6 7
}  8 9
}  : ;
public!! 

virtual!! 
bool!! 
CanBeSet!!  
=>!!! #
true!!$ (
;!!( )
public"" 

virtual"" 
bool"" 
?"" 
UseDestinationValue"" ,
{""- .
get""/ 2
=>""3 5
default""6 =
;""= >
set""? B
{""C D
}""E F
}""G H
public## 

virtual## 
object## 
NullSubstitute## (
{##) *
get##+ .
=>##/ 1
default##2 9
;##9 :
set##; >
{##? @
}##A B
}##C D
public$$ 

virtual$$ 
LambdaExpression$$ #
PreCondition$$$ 0
{$$1 2
get$$3 6
=>$$7 9
default$$: A
;$$A B
set$$C F
{$$G H
}$$I J
}$$K L
public%% 

virtual%% 
LambdaExpression%% #
	Condition%%$ -
{%%. /
get%%0 3
=>%%4 6
default%%7 >
;%%> ?
set%%@ C
{%%D E
}%%F G
}%%H I
public&& 

IValueResolver&& 
Resolver&& "
{&&# $
get&&% (
;&&( )
	protected&&* 3
set&&4 7
;&&7 8
}&&9 :
public'' 

virtual'' 
IReadOnlyCollection'' &
<''& ')
ValueTransformerConfiguration''' D
>''D E
ValueTransformers''F W
=>''X Z
[''[ \
]''\ ]
;''] ^
public(( 


MemberInfo(( 
SourceMember(( "
=>((# %
Resolver((& .
?((. /
.((/ 0
GetSourceMember((0 ?
(((? @
this((@ D
)((D E
;((E F
public)) 

string)) 
GetSourceMemberName)) %
())% &
)))& '
=>))( *
Resolver))+ 3
?))3 4
.))4 5
SourceMemberName))5 E
??))F H
SourceMember))I U
?))U V
.))V W
Name))W [
;))[ \
public** 

bool** 
MustUseDestination** "
=>**# %
UseDestinationValue**& 9
is**: <
true**= A
||**B D
!**E F
CanBeSet**F N
;**N O
public++ 

void++ 
MapFrom++ 
(++ 
string++ 
sourceMembersPath++ 0
,++0 1

MemberInfo++2 <
[++< =
]++= >
members++? F
)++F G
{,, 
var-- 

sourceType-- 
=-- 
TypeMap--  
.--  !

SourceType--! +
;--+ ,
var.. 
sourceMembers.. 
=.. 

sourceType.. &
...& '%
ContainsGenericParameters..' @
?..A B
members..C J
:..K L
members// 
[// 
$num// 
]// 
.// 
DeclaringType// $
.//$ %%
ContainsGenericParameters//% >
?//? @
ReflectionHelper//A Q
.//Q R
GetMemberPath//R _
(//_ `

sourceType//` j
,//j k
sourceMembersPath//l }
,//} ~
TypeMap	// Ü
)
//Ü á
:
//à â
members
//ä ë
;
//ë í
SetResolver00 
(00 
new00 
MemberPathResolver00 *
(00* +
sourceMembers00+ 8
)008 9
)009 :
;00: ;
}11 
public22 

override22 
string22 
ToString22 #
(22# $
)22$ %
=>22& (
DestinationName22) 8
;228 9
public33 


Expression33 
ChainSourceMembers33 (
(33( )

Expression33) 3
source334 :
)33: ;
=>33< >
SourceMembers33? L
.33L M
Chain33M R
(33R S
source33S Y
)33Y Z
;33Z [
public44 


Expression44 
ChainSourceMembers44 (
(44( ) 
IGlobalConfiguration44) =
configuration44> K
,44K L

Expression44M W
source44X ^
,44^ _

Expression44` j
defaultValue44k w
)44w x
{55 
var66 

expression66 
=66 
ChainSourceMembers66 +
(66+ ,
source66, 2
)662 3
;663 4
return77 
IncludedMember77 
==77  
null77! %
&&77& (
SourceMembers77) 6
.776 7
Length777 =
<77> ?
$num77@ A
?77B C

expression77D N
:77O P

expression77Q [
.77[ \
	NullCheck77\ e
(77e f
configuration77f s
,77s t
this77u y
,77y z
defaultValue	77{ á
)
77á à
;
77à â
}88 
public99 

bool99 '
AllowsNullDestinationValues99 +
=>99, .
Profile99/ 6
?996 7
.997 8*
AllowsNullDestinationValuesFor998 V
(99V W
this99W [
)99[ \
??99] _
true99` d
;99d e
public:: 


ProfileMap:: 
Profile:: 
=>::  
TypeMap::! (
?::( )
.::) *
Profile::* 1
;::1 2
	protected;; 
Type;; 
GetSourceType;;  
(;;  !
);;! "
=>;;# %
Resolver;;& .
?;;. /
.;;/ 0
ResolvedType;;0 <
??;;= ?
DestinationType;;@ O
;;;O P
public<< 

void<< 
MapByConvention<< 
(<<  

MemberInfo<<  *
[<<* +
]<<+ ,
sourceMembers<<- :
)<<: ;
{== 
Debug>> 
.>> 
Assert>> 
(>> 
sourceMembers>> "
.>>" #
Length>># )
>>>* +
$num>>, -
)>>- .
;>>. /
SourceMembers?? 
=?? 
sourceMembers?? %
;??% &
Resolver@@ 
=@@ 
this@@ 
;@@ 
}AA 
	protectedBB 
boolBB 
ApplyInheritedMapBB $
(BB$ %
	MemberMapBB% .
inheritedMapBB/ ;
)BB; <
{CC 
ifDD 

(DD
 
IgnoredDD 
||DD 
IsResolveConfiguredDD )
)DD) *
{EE 	
returnFF 
falseFF 
;FF 
}GG 	
ifHH 

(HH
 
inheritedMapHH 
.HH 
IgnoredHH 
)HH  
{II 	
IgnoredJJ 
=JJ 
trueJJ 
;JJ 
returnKK 
trueKK 
;KK 
}LL 	
ifMM 

(MM
 
inheritedMapMM 
.MM 
IsResolveConfiguredMM +
)MM+ ,
{NN 	
_sourceTypeOO 
=OO 
inheritedMapOO &
.OO& '
_sourceTypeOO' 2
;OO2 3
ResolverPP 
=PP 
inheritedMapPP #
.PP# $
ResolverPP$ ,
.PP, -
CloseGenericsPP- :
(PP: ;
TypeMapPP; B
)PPB C
;PPC D
returnQQ 
trueQQ 
;QQ 
}RR 	
ifSS 

(SS
 
ResolverSS 
==SS 
nullSS 
)SS 
{TT 	
_sourceTypeUU 
=UU 
inheritedMapUU &
.UU& '
_sourceTypeUU' 2
;UU2 3
MapByConventionVV 
(VV 
inheritedMapVV (
.VV( )
SourceMembersVV) 6
)VV6 7
;VV7 8
returnWW 
trueWW 
;WW 
}XX 	
returnYY 
falseYY 
;YY 
}ZZ 

Expression[[ 
IValueResolver[[ 
.[[ 
GetExpression[[ +
([[+ , 
IGlobalConfiguration[[, @
configuration[[A N
,[[N O
	MemberMap[[P Y
	memberMap[[Z c
,[[c d

Expression[[e o
source[[p v
,[[v w

Expression	[[x Ç
destination
[[É é
,
[[é è

Expression
[[ê ö
destinationMember
[[õ ¨
)
[[¨ ≠
=>
[[Æ ∞
ChainSourceMembers\\ 
(\\ 
configuration\\ (
,\\( )
source\\* 0
,\\0 1
destinationMember\\2 C
)\\C D
;\\D E

MemberInfo]] 
IValueResolver]] 
.]] 
GetSourceMember]] -
(]]- .
	MemberMap]]. 7
	memberMap]]8 A
)]]A B
=>]]C E
SourceMembers]]F S
[]]S T
$num]]T U
]]]U V
;]]V W
Type^^ 
IValueResolver^^	 
.^^ 
ResolvedType^^ $
=>^^% '
SourceMembers^^( 5
[^^5 6
^^^6 7
$num^^7 8
]^^8 9
.^^9 :
GetMemberType^^: G
(^^G H
)^^H I
;^^I J
}__ 
public`` 
readonly`` 
record`` 
struct`` )
ValueTransformerConfiguration`` ;
(``; <
Type``< @
	ValueType``A J
,``J K
LambdaExpression``L \!
TransformerExpression``] r
)``r s
{aa 
publicbb 

boolbb 
IsMatchbb 
(bb 
	MemberMapbb !
	memberMapbb" +
)bb+ ,
=>bb- /
	ValueTypebb0 9
.bb9 :
IsAssignableFrombb: J
(bbJ K
	memberMapbbK T
.bbT U

SourceTypebbU _
)bb_ `
&&bba c
	memberMapbbd m
.bbm n
DestinationTypebbn }
.bb} ~
IsAssignableFrom	bb~ é
(
bbé è
	ValueType
bbè ò
)
bbò ô
;
bbô ö
}cc 
publicdd 
staticdd 
classdd 3
'ValueTransformerConfigurationExtensionsdd ;
{ee 
publicll 

staticll 
voidll 
Addll 
<ll 
TValuell !
>ll! "
(ll" #
thisll# '
Listll( ,
<ll, -)
ValueTransformerConfigurationll- J
>llJ K
valueTransformersllL ]
,ll] ^

Expressionll_ i
<lli j
Funcllj n
<lln o
TValuello u
,llu v
TValuellw }
>ll} ~
>ll~ 
transformer
llÄ ã
)
llã å
=>
llç è
valueTransformersmm 
.mm 
Addmm 
(mm 
newmm !
(mm! "
typeofmm" (
(mm( )
TValuemm) /
)mm/ 0
,mm0 1
transformermm2 =
)mm= >
)mm> ?
;mm? @
}nn Ë	
\C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\UnderlyingEnumTypeMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class $
UnderlyingTypeEnumMapper ,
:- .
IObjectMapper/ <
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5"
IsEnumToUnderlyingType5 K
(K L
)L M
||N P
contextQ X
.X Y"
IsUnderlyingTypeToEnumY o
(o p
)p q
;q r
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap 
	memberMap 
, 

Expression '
sourceExpression( 8
,8 9

Expression: D
destExpressionE S
)S T
=>U W
sourceExpressionX h
;h i
} ≤
RC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ToStringMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
ToStringMapper "
:# $
IObjectMapper% 2
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
DestinationType5 D
==E G
typeofH N
(N O
stringO U
)U V
;V W
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
{ 
var 

sourceType 
= 
sourceExpression )
.) *
Type* .
;. /
var 
toStringCall 
= 
Call 
(  
sourceExpression  0
,0 1
ObjectToString2 @
)@ A
;A B
return		 

sourceType		 
.		 
IsEnum		  
?		! "
StringToEnumMapper		# 5
.		5 6
CheckEnumMember		6 E
(		E F
sourceExpression		F V
,		V W

sourceType		X b
,		b c
toStringCall		d p
)		p q
:		r s
toStringCall			t Ä
;
		Ä Å
}

 
} Œ
\C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ToStringDictionaryMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class $
ToStringDictionaryMapper ,
:- .
IObjectMapper/ <
{ 
private 
static 
readonly 

MethodInfo &'
MembersDictionaryMethodInfo' B
=C D
typeofE K
(K L$
ToStringDictionaryMapperL d
)d e
.e f
GetStaticMethodf u
(u v
nameofv |
(| }
MembersDictionary	} é
)
é è
)
è ê
;
ê ë
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
typeof- 3
(3 4
IDictionary4 ?
<? @
string@ F
,F G
objectH N
>N O
)O P
.P Q
IsAssignableFromQ a
(a b
contextb i
.i j
DestinationTypej y
)y z
;z {
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
=>
¨ Æ
Call 
( '
MembersDictionaryMethodInfo (
,( )
sourceExpression* :
.: ;
ToObject; C
(C D
)D E
,E F
ConstantG O
(O P

profileMapP Z
)Z [
)[ \
;\ ]
private 
static 

Dictionary 
< 
string $
,$ %
object& ,
>, -
MembersDictionary. ?
(? @
object@ F
sourceG M
,M N

ProfileMapO Y

profileMapZ d
)d e
=>f h

profileMap		 
.		 
CreateTypeDetails		 $
(		$ %
source		% +
.		+ ,
GetType		, 3
(		3 4
)		4 5
)		5 6
.		6 7
ReadAccessors		7 D
.		D E
ToDictionary		E Q
(		Q R
p		R S
=>		T V
p		W X
.		X Y
Name		Y ]
,		] ^
p		_ `
=>		a c
p		d e
.		e f
GetMemberValue		f t
(		t u
source		u {
)		{ |
)		| }
;		} ~
}

 ∫-
SC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ToDynamicMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
ToDynamicMapper #
:$ %
IObjectMapper& 3
{ 
private 
static 
readonly 

MethodInfo &
MapMethodInfo' 4
=5 6
typeof7 =
(= >
ToDynamicMapper> M
)M N
.N O
GetStaticMethodO ^
(^ _
nameof_ e
(e f
Mapf i
)i j
)j k
;k l
private 
static 
object 
Map 
( 
object $
source% +
,+ ,
object- 3
destination4 ?
,? @
TypeA E
destinationTypeF U
,U V
ResolutionContextW h
contexti p
,p q

ProfileMapr |

profileMap	} á
)
á à
{		 
destination

 
??=

 
ObjectFactory

 %
.

% &
CreateInstance

& 4
(

4 5
destinationType

5 D
)

D E
;

E F
var 
sourceTypeDetails 
= 

profileMap  *
.* +
CreateTypeDetails+ <
(< =
source= C
.C D
GetTypeD K
(K L
)L M
)M N
;N O
foreach 
( 
var 
member 
in 
sourceTypeDetails 0
.0 1
ReadAccessors1 >
)> ?
{ 	
object 
sourceMemberValue $
;$ %
try 
{ 
sourceMemberValue !
=" #
member$ *
.* +
GetMemberValue+ 9
(9 :
source: @
)@ A
;A B
} 
catch 
( "
RuntimeBinderException )
)) *
{ 
continue 
; 
} 
var "
destinationMemberValue &
=' (
context) 0
.0 1
	MapMember1 :
(: ;
member; A
,A B
sourceMemberValueC T
)T U
;U V
SetDynamically 
( 
member !
.! "
Name" &
,& '
destination( 3
,3 4"
destinationMemberValue5 K
)K L
;L M
} 	
return 
destination 
; 
} 
private 
static 
void 
SetDynamically &
(& '
string' -

memberName. 8
,8 9
object: @
targetA G
,G H
objectI O
valueP U
)U V
{ 
var 
binder 
= 
Binder 
. 
	SetMember %
(% &
CSharpBinderFlags& 7
.7 8
None8 <
,< =

memberName> H
,H I
nullJ N
,N O
[ 
CSharpArgumentInfo   "
.  " #
Create  # )
(  ) *#
CSharpArgumentInfoFlags  * A
.  A B
None  B F
,  F G
null  H L
)  L M
,  M N
CSharpArgumentInfo!! "
.!!" #
Create!!# )
(!!) *#
CSharpArgumentInfoFlags!!* A
.!!A B
None!!B F
,!!F G
null!!H L
)!!L M
]"" 
)"" 
;"" 
var## 
callsite## 
=## 
CallSite## 
<##  
Func##  $
<##$ %
CallSite##% -
,##- .
object##/ 5
,##5 6
object##7 =
,##= >
object##? E
>##E F
>##F G
.##G H
Create##H N
(##N O
binder##O U
)##U V
;##V W
callsite$$ 
.$$ 
Target$$ 
($$ 
callsite$$  
,$$  !
target$$" (
,$$( )
value$$* /
)$$/ 0
;$$0 1
}%% 
public&& 

bool&& 
IsMatch&& 
(&& 
TypePair&&  
context&&! (
)&&( )
=>&&* ,
context&&- 4
.&&4 5
DestinationType&&5 D
.&&D E
	IsDynamic&&E N
(&&N O
)&&O P
&&&&Q S
!&&T U
context&&U \
.&&\ ]

SourceType&&] g
.&&g h
	IsDynamic&&h q
(&&q r
)&&r s
;&&s t
public'' 


Expression'' 
MapExpression'' #
(''# $ 
IGlobalConfiguration''$ 8
configuration''9 F
,''F G

ProfileMap''H R

profileMap''S ]
,''] ^
	MemberMap(( 
	memberMap(( 
,(( 

Expression(( '
sourceExpression((( 8
,((8 9

Expression((: D
destExpression((E S
)((S T
=>((U W
Call)) 
()) 
MapMethodInfo)) 
,)) 
sourceExpression)) ,
.)), -
ToObject))- 5
())5 6
)))6 7
,))7 8
destExpression))9 G
,))G H
Constant))I Q
())Q R
destExpression))R `
.))` a
Type))a e
)))e f
,))f g
ContextParameter))h x
,))x y
Constant	))z Ç
(
))Ç É

profileMap
))É ç
)
))ç é
)
))é è
;
))è ê
}** ∫7
VC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\StringToEnumMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
StringToEnumMapper &
:' (
IObjectMapper) 6
{ 
private 
static 
readonly 

MethodInfo &
EqualsMethod' 3
=4 5
typeof6 <
(< =
StringToEnumMapper= O
)O P
.P Q
	GetMethodQ Z
(Z [
nameof[ a
(a b+
StringCompareOrdinalIgnoreCase	b Ä
)
Ä Å
)
Å Ç
;
Ç É
private 
static 
readonly 

MethodInfo &
ParseMethod' 2
=3 4
typeof5 ;
(; <
Enum< @
)@ A
.A B
StaticGenericMethodB U
(U V
$strV ]
,] ^
parametersCount_ n
:n o
$nump q
)q r
;r s
private 
static 
readonly 
PropertyInfo (
Length) /
=0 1
typeof2 8
(8 9
string9 ?
)? @
.@ A
GetPropertyA L
(L M
$strM U
)U V
;V W
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5

SourceType5 ?
==@ B
typeofC I
(I J
stringJ P
)P Q
&&R T
contextU \
.\ ]
DestinationType] l
.l m
IsEnumm s
;s t
public		 


Expression		 
MapExpression		 #
(		# $ 
IGlobalConfiguration		$ 8
configuration		9 F
,		F G

ProfileMap		H R

profileMap		S ]
,		] ^
	MemberMap

 
	memberMap

 
,

 

Expression

 '
sourceExpression

( 8
,

8 9

Expression

: D
destExpression

E S
)

S T
{ 
var 
destinationType 
= 
destExpression ,
., -
Type- 1
;1 2
var 

ignoreCase 
= 
True 
; 
var 
	enumParse 
= 
Call 
( 
ParseMethod (
.( )
MakeGenericMethod) :
(: ;
destinationType; J
)J K
,K L
sourceExpressionM ]
,] ^

ignoreCase_ i
)i j
;j k
var 

enumMember 
= 
CheckEnumMember (
(( )
sourceExpression) 9
,9 :
destinationType; J
,J K
	enumParseL U
,U V
EqualsMethodW c
)c d
;d e
return 
	Condition 
( 
Equal 
( 
Property '
(' (
sourceExpression( 8
,8 9
Length: @
)@ A
,A B
ZeroC G
)G H
,H I
configurationJ W
.W X
DefaultX _
(_ `
destinationType` o
)o p
,p q

enumMemberr |
)| }
;} ~
} 
internal 
static 

Expression 
CheckEnumMember .
(. /

Expression/ 9
sourceExpression: J
,J K
TypeL P
enumTypeQ Y
,Y Z

Expression[ e
defaultExpressionf w
,w x

MethodInfo	y É

comparison
Ñ é
=
è ê
null
ë ï
)
ï ñ
{ 
List 
< 

SwitchCase 
> 
switchCases $
=% &
null' +
;+ ,
foreach 
( 
var 

memberInfo 
in  "
enumType# +
.+ ,
	GetFields, 5
(5 6
TypeExtensions6 D
.D E
StaticFlagsE P
)P Q
)Q R
{ 	
var 
attributeValue 
=  

memberInfo! +
.+ ,
GetCustomAttribute, >
<> ?
EnumMemberAttribute? R
>R S
(S T
)T U
?U V
.V W
ValueW \
;\ ]
if 
( 
attributeValue 
== !
null" &
)& '
{ 
continue 
; 
} 
var 
enumToObject 
= 
Constant '
(' (
Enum( ,
., -
ToObject- 5
(5 6
enumType6 >
,> ?

memberInfo@ J
.J K
GetValueK S
(S T
nullT X
)X Y
)Y Z
)Z [
;[ \
var 
attributeConstant !
=" #
Constant$ ,
(, -
attributeValue- ;
); <
;< =
var 
( 
body 
, 
	testValue  
)  !
=" #

comparison$ .
==/ 1
null2 6
?7 8
(9 :
attributeConstant: K
,K L
enumToObjectM Y
)Y Z
:[ \
(] ^
ToType^ d
(d e
enumToObjecte q
,q r
enumTypes {
){ |
,| }
attributeConstant	~ è
)
è ê
;
ê ë
switchCases 
??= 
[ 
] 
; 
switchCases   
.   
Add   
(   

SwitchCase   &
(  & '
body  ' +
,  + ,
	testValue  - 6
)  6 7
)  7 8
;  8 9
}!! 	
return"" 
switchCases"" 
=="" 
null"" "
?""# $
defaultExpression""% 6
:""7 8
Switch""9 ?
(""? @
sourceExpression""@ P
,""P Q
defaultExpression""R c
,""c d

comparison""e o
,""o p
switchCases""q |
)""| }
;""} ~
}## 
public$$ 

static$$ 
bool$$ *
StringCompareOrdinalIgnoreCase$$ 5
($$5 6
string$$6 <
x$$= >
,$$> ?
string$$@ F
y$$G H
)$$H I
=>$$J L
StringComparer$$M [
.$$[ \
OrdinalIgnoreCase$$\ m
.$$m n
Equals$$n t
($$t u
x$$u v
,$$v w
y$$x y
)$$y z
;$$z {
}%% ‚
UC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ParseStringMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
ParseStringMapper %
:& '
IObjectMapper( 5
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5

SourceType5 ?
==@ B
typeofC I
(I J
stringJ P
)P Q
&&R T
HasParseU ]
(] ^
context^ e
.e f
DestinationTypef u
)u v
;v w
static 

bool 
HasParse 
( 
Type 
type "
)" #
=>$ &
type' +
==, .
typeof/ 5
(5 6
Guid6 :
): ;
||< >
type? C
==D F
typeofG M
(M N
TimeSpanN V
)V W
||X Z
type[ _
==` b
typeofc i
(i j
DateTimeOffsetj x
)x y
;y z
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
=>
¨ Æ
Call 
( 
destExpression 
. 
Type  
.  !
	GetMethod! *
(* +
$str+ 2
,2 3
[4 5
typeof5 ;
(; <
string< B
)B C
]C D
)D E
,E F
sourceExpressionG W
)W X
;X Y
}		 û
XC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\NullableSourceMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class  
NullableSourceMapper (
:) *
IObjectMapper+ 8
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5

SourceType5 ?
.? @
IsNullableType@ N
(N O
)O P
;P Q
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
=>
¨ Æ
configuration 
. 
MapExpression #
(# $

profileMap$ .
,. /
GetAssociatedTypes0 B
(B C
sourceExpressionC S
.S T
TypeT X
,X Y
destExpressionZ h
.h i
Typei m
)m n
,n o
ExpressionBuilder !
.! "
Property" *
(* +
sourceExpression+ ;
,; <
$str= D
)D E
,E F
	memberMapG P
,P Q
destExpressionR `
)` a
;a b
public		 

TypePair		 
?		 
GetAssociatedTypes		 '
(		' (
TypePair		( 0
initialTypes		1 =
)		= >
=>		? A
GetAssociatedTypes		B T
(		T U
initialTypes		U a
.		a b

SourceType		b l
,		l m
initialTypes		n z
.		z {
DestinationType			{ ä
)
		ä ã
;
		ã å
TypePair

 
GetAssociatedTypes

 
(

  
Type

  $

sourceType

% /
,

/ 0
Type

1 5
destinationType

6 E
)

E F
=>

G I
new

J M
(

M N
Nullable

N V
.

V W
GetUnderlyingType

W h
(

h i

sourceType

i s
)

s t
,

t u
destinationType	

v Ö
)


Ö Ü
;


Ü á
} ä
]C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\NullableDestinationMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class %
NullableDestinationMapper -
:. /
IObjectMapper0 =
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
DestinationType5 D
.D E
IsNullableTypeE S
(S T
)T U
;U V
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
=>
¨ Æ
configuration 
. 
MapExpression #
(# $

profileMap$ .
,. /
GetAssociatedTypes0 B
(B C
sourceExpressionC S
.S T
TypeT X
,X Y
destExpressionZ h
.h i
Typei m
)m n
,n o
sourceExpression	p Ä
,
Ä Å
	memberMap
Ç ã
)
ã å
;
å ç
public 

TypePair 
? 
GetAssociatedTypes '
(' (
TypePair( 0
initialTypes1 =
)= >
=>? A
GetAssociatedTypesB T
(T U
initialTypesU a
.a b

SourceTypeb l
,l m
initialTypesn z
.z {
DestinationType	{ ä
)
ä ã
;
ã å
TypePair		 
GetAssociatedTypes		 
(		  
Type		  $

sourceType		% /
,		/ 0
Type		1 5
destinationType		6 E
)		E F
=>		G I
new		J M
(		M N

sourceType		N X
,		X Y
Nullable		Z b
.		b c
GetUnderlyingType		c t
(		t u
destinationType			u Ñ
)
		Ñ Ö
)
		Ö Ü
;
		Ü á
}

 ˝
RC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\MapperRegistry.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
internal 
static	 
class 
MapperRegistry $
{ 
public 

static 
List 
< 
IObjectMapper $
>$ %
Mappers& -
(- .
). /
=>0 2
[ 
new 
CollectionMapper 
( 
) 
, 
new 
AssignableMapper 
( 
) 
, 
new		  
NullableSourceMapper		  
(		  !
)		! "
,		" #
new

 
ToStringMapper

 
(

 
)

 
,

 
new %
NullableDestinationMapper %
(% &
)& '
,' (
new 
ConvertMapper 
( 
) 
, 
new 
StringToEnumMapper 
( 
)  
,  !
new 
EnumToEnumMapper 
( 
) 
, 
new 
ParseStringMapper 
( 
) 
,  
new $
UnderlyingTypeEnumMapper $
($ %
)% &
,& '
new 
KeyValueMapper 
( 
) 
, 
new 
ConstructorMapper 
( 
) 
,  
new $
ConversionOperatorMapper $
($ %
$str% 2
)2 3
,3 4
new $
ConversionOperatorMapper $
($ %
$str% 2
)2 3
,3 4
new 
FromDynamicMapper 
( 
) 
,  
new 
ToDynamicMapper 
( 
) 
, 
new &
FromStringDictionaryMapper &
(& '
)' (
,( )
new $
ToStringDictionaryMapper $
($ %
)% &
,& '
] 
; 
} ’
RC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\KeyValueMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
KeyValueMapper "
:# $
IObjectMapper% 2
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,

IsKeyValue- 7
(7 8
context8 ?
.? @

SourceType@ J
)J K
&&L N

IsKeyValueO Y
(Y Z
contextZ a
.a b
DestinationTypeb q
)q r
;r s
public 

static 
bool 

IsKeyValue !
(! "
Type" &
type' +
)+ ,
=>- /
type0 4
.4 5
IsGenericType5 B
(B C
typeofC I
(I J
KeyValuePairJ V
<V W
,W X
>X Y
)Y Z
)Z [
;[ \
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
{ 
var 
sourceArguments 
= 
sourceExpression .
.. /
Type/ 3
.3 4 
GenericTypeArguments4 H
;H I
var		 
destinationType		 
=		 
destExpression		 ,
.		, -
Type		- 1
;		1 2
var

  
destinationArguments

  
=

! "
destinationType

# 2
.

2 3 
GenericTypeArguments

3 G
;

G H
TypePair 
keys 
= 
new 
( 
sourceArguments +
[+ ,
$num, -
]- .
,. / 
destinationArguments0 D
[D E
$numE F
]F G
)G H
;H I
TypePair 
values 
= 
new 
( 
sourceArguments -
[- .
$num. /
]/ 0
,0 1 
destinationArguments2 F
[F G
$numG H
]H I
)I J
;J K
var 
mapKeys 
= 
configuration #
.# $
MapExpression$ 1
(1 2

profileMap2 <
,< =
keys> B
,B C
ExpressionBuilderD U
.U V
PropertyV ^
(^ _
sourceExpression_ o
,o p
$strq v
)v w
)w x
;x y
var 
	mapValues 
= 
configuration %
.% &
MapExpression& 3
(3 4

profileMap4 >
,> ?
values@ F
,F G
ExpressionBuilderH Y
.Y Z
PropertyZ b
(b c
sourceExpressionc s
,s t
$stru |
)| }
)} ~
;~ 
return 
New 
( 
destinationType "
." #
GetConstructor# 1
(1 2 
destinationArguments2 F
)F G
,G H
mapKeysI P
,P Q
	mapValuesR [
)[ \
;\ ]
} 
} ≤
QC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\IObjectMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
	interface 
IObjectMapper 
{ 
bool 
IsMatch	 
( 
TypePair 
context !
)! "
;" #

Expression 
MapExpression 
(  
IGlobalConfiguration 1
configuration2 ?
,? @

ProfileMapA K

profileMapL V
,V W
	MemberMap 
	memberMap 
, 

Expression '
sourceExpression( 8
,8 9

Expression: D
destExpressionE S
)S T
;T U
TypePair 
? 
GetAssociatedTypes  
(  !
TypePair! )
initialTypes* 6
)6 7
=>8 :
null; ?
;? @
} 
public!! 
abstract!! 
class!! 
ObjectMapper!! "
<!!" #
TSource!!# *
,!!* +
TDestination!!, 8
>!!8 9
:!!: ;
IObjectMapper!!< I
{"" 
private## 
static## 
readonly## 

MethodInfo## &
	MapMethod##' 0
=##1 2
typeof##3 9
(##9 :
ObjectMapper##: F
<##F G
TSource##G N
,##N O
TDestination##P \
>##\ ]
)##] ^
.##^ _
	GetMethod##_ h
(##h i
$str##i n
)##n o
;##o p
public** 

virtual** 
bool** 
IsMatch** 
(**  
TypePair**  (
context**) 0
)**0 1
=>**2 4
typeof++ 
(++ 
TSource++ 
)++ 
.++ 
IsAssignableFrom++ (
(++( )
context++) 0
.++0 1

SourceType++1 ;
)++; <
&&++= ?
typeof++@ F
(++F G
TDestination++G S
)++S T
.++T U
IsAssignableFrom++U e
(++e f
context++f m
.++m n
DestinationType++n }
)++} ~
;++~ 
public66 

abstract66 
TDestination66  
Map66! $
(66$ %
TSource66% ,
source66- 3
,663 4
TDestination665 A
destination66B M
,66M N
Type66O S

sourceType66T ^
,66^ _
Type66` d
destinationType66e t
,66t u
ResolutionContext	66v á
context
66à è
)
66è ê
;
66ê ë
public88 


Expression88 
MapExpression88 #
(88# $ 
IGlobalConfiguration88$ 8
configuration889 F
,88F G

ProfileMap88H R

profileMap88S ]
,88] ^
	MemberMap99 
	memberMap99 
,99 

Expression99 '
sourceExpression99( 8
,998 9

Expression99: D
destExpression99E S
)99S T
=>99U W
Call:: 
(:: 
Constant;; 
(;; 
this;; 
);; 
,;; 
	MapMethod<< 
,<< 
ToType== 
(== 
sourceExpression== #
,==# $
typeof==% +
(==+ ,
TSource==, 3
)==3 4
)==4 5
,==5 6
ToType>> 
(>> 
destExpression>> !
,>>! "
typeof>># )
(>>) *
TDestination>>* 6
)>>6 7
)>>7 8
,>>8 9
Constant?? 
(?? 
sourceExpression?? %
.??% &
Type??& *
)??* +
,??+ ,
Constant@@ 
(@@ 
destExpression@@ #
.@@# $
Type@@$ (
)@@( )
,@@) *
ContextParameterAA 
)AA 
;AA 
}BB áP
^C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\FromStringDictionaryMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class &
FromStringDictionaryMapper .
:/ 0
IObjectMapper1 >
{ 
private 
static 
readonly 

MethodInfo &
MapDynamicMethod' 7
=8 9
typeof: @
(@ A&
FromStringDictionaryMapperA [
)[ \
.\ ]
GetStaticMethod] l
(l m
nameofm s
(s t

MapDynamict ~
)~ 
)	 Ä
;
Ä Å
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
typeof- 3
(3 4
StringDictionary4 D
)D E
.E F
IsAssignableFromF V
(V W
contextW ^
.^ _

SourceType_ i
)i j
;j k
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expression 
sourceExpression #
,# $

Expression% /
destExpression0 >
)> ?
=>@ B
Call		 
(		 
MapDynamicMethod		 !
,		! "
sourceExpression		# 3
,		3 4
destExpression		5 C
.		C D
ToObject		D L
(		L M
)		M N
,		N O
Constant		P X
(		X Y
destExpression		Y g
.		g h
Type		h l
)		l m
,		m n
ContextParameter		o 
,			 Ä
Constant
		Å â
(
		â ä

profileMap
		ä î
)
		î ï
)
		ï ñ
;
		ñ ó
private

 
static

 
object

 

MapDynamic

 $
(

$ %
StringDictionary

% 5
source

6 <
,

< =
object

> D
boxedDestination

E U
,

U V
Type

W [
destinationType

\ k
,

k l
ResolutionContext

m ~
context	

 Ü
,


Ü á

ProfileMap


à í

profileMap


ì ù
)


ù û
{ 
boxedDestination 
??= 
ObjectFactory *
.* +
CreateInstance+ 9
(9 :
destinationType: I
)I J
;J K
int 
matchedCount 
= 
$num 
; 
foreach 
( 
var 
member 
in 

profileMap )
.) *
CreateTypeDetails* ;
(; <
destinationType< K
)K L
.L M
WriteAccessorsM [
)[ \
{ 	
var 
( 
value 
, 
count 
) 
=  
MatchSource! ,
(, -
member- 3
.3 4
Name4 8
)8 9
;9 :
if 
( 
count 
== 
$num 
) 
{ 
continue 
; 
} 
if 
( 
count 
> 
$num 
) 
{ 
throw 
new &
AutoMapperMappingException 4
(4 5
$"5 7
$str	7 â
{
â ä
member
ä ê
}
ê ë
$str
ë í
"
í ì
,
ì î
null
ï ô
,
ô ö
new
õ û
TypePair
ü ß
(
ß ®
typeof
® Æ
(
Æ Ø
StringDictionary
Ø ø
)
ø ¿
,
¿ ¡
destinationType
¬ —
)
— “
)
“ ”
;
” ‘
} 
var 
mappedValue 
= 
context %
.% &
	MapMember& /
(/ 0
member0 6
,6 7
value8 =
,= >
boxedDestination? O
)O P
;P Q
member 
. 
SetMemberValue !
(! "
boxedDestination" 2
,2 3
mappedValue4 ?
)? @
;@ A
matchedCount 
++ 
; 
} 	
if 

( 
matchedCount 
< 
source !
.! "
Count" '
)' (
{ 	
MapInnerProperties 
( 
)  
;  !
}   	
return!! 
boxedDestination!! 
;!!  
("" 	
object""	 
Value"" 
,"" 
int"" 
Count""  
)""  !
MatchSource""" -
(""- .
string"". 4
name""5 9
)""9 :
{## 	
if$$ 
($$ 
source$$ 
.$$ 
TryGetValue$$ "
($$" #
name$$# '
,$$' (
out$$) ,
var$$- 0
value$$1 6
)$$6 7
)$$7 8
{%% 
return&& 
(&& 
value&& 
,&& 
$num&&  
)&&  !
;&&! "
}'' 
var(( 
matches(( 
=(( 
source((  
.((  !
Where((! &
(((& '
s((' (
=>(() +
s((, -
.((- .
Key((. 1
.((1 2
Trim((2 6
(((6 7
)((7 8
==((9 ;
name((< @
)((@ A
.((A B
Select((B H
(((H I
s((I J
=>((J L
s((L M
.((M N
Value((N S
)((S T
.((T U
ToArray((U \
(((\ ]
)((] ^
;((^ _
if)) 
()) 
matches)) 
.)) 
Length)) 
==)) !
$num))" #
)))# $
{** 
return++ 
(++ 
matches++ 
[++  
$num++  !
]++! "
,++" #
$num++$ %
)++% &
;++& '
},, 
return-- 
(-- 
null-- 
,-- 
matches-- !
.--! "
Length--" (
)--( )
;--) *
}.. 	
void// 
MapInnerProperties// 
(//  
)//  !
{00 	

MemberInfo11 
[11 
]11 
innerMembers11 %
;11% &
foreach22 
(22 
var22 

memberPath22 #
in22$ &
source22' -
.22- .
Keys22. 2
.222 3
Where223 8
(228 9
k229 :
=>22; =
k22> ?
.22? @
Contains22@ H
(22H I
$char22I L
)22L M
)22M N
)22N O
{33 
innerMembers44 
=44 
ReflectionHelper44 /
.44/ 0
GetMemberPath440 =
(44= >
destinationType44> M
,44M N

memberPath44O Y
)44Y Z
;44Z [
var55 
innerDestination55 $
=55% &
GetInnerDestination55' :
(55: ;
)55; <
;55< =
if66 
(66 
innerDestination66 $
==66% '
null66( ,
)66, -
{77 
continue88 
;88 
}99 
var:: 

lastMember:: 
=::  
innerMembers::! -
[::- .
innerMembers::. :
.::: ;
Length::; A
-::B C
$num::D E
]::E F
;::F G
var;; 
value;; 
=;; 
context;; #
.;;# $
	MapMember;;$ -
(;;- .

lastMember;;. 8
,;;8 9
source;;: @
[;;@ A

memberPath;;A K
];;K L
,;;L M
innerDestination;;N ^
);;^ _
;;;_ `

lastMember<< 
.<< 
SetMemberValue<< )
(<<) *
innerDestination<<* :
,<<: ;
value<<< A
)<<A B
;<<B C
}== 
return>> 
;>> 
object?? 
GetInnerDestination?? &
(??& '
)??' (
{@@ 
varAA 
currentDestinationAA &
=AA' (
boxedDestinationAA) 9
;AA9 :
foreachBB 
(BB 
varBB 
memberBB #
inBB$ &
innerMembersBB' 3
.BB3 4
TakeBB4 8
(BB8 9
innerMembersBB9 E
.BBE F
LengthBBF L
-BBM N
$numBBO P
)BBP Q
)BBQ R
{CC 
varDD 
newDestinationDD &
=DD' (
memberDD) /
.DD/ 0
GetMemberValueDD0 >
(DD> ?
currentDestinationDD? Q
)DDQ R
;DDR S
ifEE 
(EE 
newDestinationEE &
==EE' )
nullEE* .
)EE. /
{FF 
ifGG 
(GG 
!GG 
memberGG #
.GG# $
CanBeSetGG$ ,
(GG, -
)GG- .
)GG. /
{HH 
returnII "
nullII# '
;II' (
}JJ 
newDestinationKK &
=KK' (
ObjectFactoryKK) 6
.KK6 7
CreateInstanceKK7 E
(KKE F
memberKKF L
.KKL M
GetMemberTypeKKM Z
(KKZ [
)KK[ \
)KK\ ]
;KK] ^
memberLL 
.LL 
SetMemberValueLL -
(LL- .
currentDestinationLL. @
,LL@ A
newDestinationLLB P
)LLP Q
;LLQ R
}MM 
currentDestinationNN &
=NN' (
newDestinationNN) 7
;NN7 8
}OO 
returnPP 
currentDestinationPP )
;PP) *
}QQ 
}RR 	
}SS 
}TT è+
UC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\FromDynamicMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
FromDynamicMapper %
:& '
IObjectMapper( 5
{ 
private 
static 
readonly 

MethodInfo &
MapMethodInfo' 4
=5 6
typeof7 =
(= >
FromDynamicMapper> O
)O P
.P Q
GetStaticMethodQ `
(` a
nameofa g
(g h
Maph k
)k l
)l m
;m n
private 
static 
object 
Map 
( 
object $
source% +
,+ ,
object- 3
destination4 ?
,? @
TypeA E
destinationTypeF U
,U V
ResolutionContextW h
contexti p
,p q

ProfileMapr |

profileMap	} á
)
á à
{		 
destination

 
??=

 
ObjectFactory

 %
.

% &
CreateInstance

& 4
(

4 5
destinationType

5 D
)

D E
;

E F
var "
destinationTypeDetails "
=# $

profileMap% /
./ 0
CreateTypeDetails0 A
(A B
destinationTypeB Q
)Q R
;R S
foreach 
( 
var 
member 
in "
destinationTypeDetails 5
.5 6
WriteAccessors6 D
)D E
{ 	
object 
sourceMemberValue $
;$ %
try 
{ 
sourceMemberValue !
=" #
GetDynamically$ 2
(2 3
member3 9
.9 :
Name: >
,> ?
source@ F
)F G
;G H
} 
catch 
( "
RuntimeBinderException )
)) *
{ 
continue 
; 
} 
var "
destinationMemberValue &
=' (
context) 0
.0 1
	MapMember1 :
(: ;
member; A
,A B
sourceMemberValueC T
,T U
destinationV a
)a b
;b c
member 
. 
SetMemberValue !
(! "
destination" -
,- ."
destinationMemberValue/ E
)E F
;F G
} 	
return 
destination 
; 
} 
private 
static 
object 
GetDynamically (
(( )
string) /

memberName0 :
,: ;
object< B
targetC I
)I J
{ 
var 
binder 
= 
Binder 
. 
	GetMember %
(% &
CSharpBinderFlags& 7
.7 8
None8 <
,< =

memberName> H
,H I
nullJ N
,N O
[P Q
CSharpArgumentInfoQ c
.c d
Created j
(j k$
CSharpArgumentInfoFlags	k Ç
.
Ç É
None
É á
,
á à
null
â ç
)
ç é
]
é è
)
è ê
;
ê ë
var 
callsite 
= 
CallSite 
<  
Func  $
<$ %
CallSite% -
,- .
object/ 5
,5 6
object7 =
>= >
>> ?
.? @
Create@ F
(F G
binderG M
)M N
;N O
return   
callsite   
.   
Target   
(   
callsite   '
,  ' (
target  ) /
)  / 0
;  0 1
}!! 
public"" 

bool"" 
IsMatch"" 
("" 
TypePair""  
context""! (
)""( )
=>""* ,
context""- 4
.""4 5

SourceType""5 ?
.""? @
	IsDynamic""@ I
(""I J
)""J K
&&""L N
!""O P
context""P W
.""W X
DestinationType""X g
.""g h
	IsDynamic""h q
(""q r
)""r s
;""s t
public## 


Expression## 
MapExpression## #
(### $ 
IGlobalConfiguration##$ 8
configuration##9 F
,##F G

ProfileMap##H R

profileMap##S ]
,##] ^
	MemberMap$$ 
	memberMap$$ 
,$$ 

Expression$$ '
sourceExpression$$( 8
,$$8 9

Expression$$: D
destExpression$$E S
)$$S T
=>$$U W
Call%% 
(%% 
MapMethodInfo%% 
,%% 
sourceExpression%% ,
,%%, -
destExpression%%. <
.%%< =
ToObject%%= E
(%%E F
)%%F G
,%%G H
Constant%%I Q
(%%Q R
destExpression%%R `
.%%` a
Type%%a e
)%%e f
,%%f g
ContextParameter%%h x
,%%x y
Constant	%%z Ç
(
%%Ç É

profileMap
%%É ç
)
%%ç é
)
%%é è
;
%%è ê
}&& Ÿ
TC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\EnumToEnumMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
EnumToEnumMapper $
:% &
IObjectMapper' 4
{ 
private 
static 
readonly 

MethodInfo &
TryParseMethod' 5
=6 7
typeof8 >
(> ?
Enum? C
)C D
.D E
StaticGenericMethodE X
(X Y
$strY c
,c d
parametersCounte t
:t u
$numv w
)w x
;x y
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
IsEnumToEnum5 A
(A B
)B C
;C D
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap 
	memberMap 
, 

Expression '
sourceExpression( 8
,8 9

Expression: D
destExpressionE S
)S T
{ 
var		 
destinationType		 
=		 
destExpression		 ,
.		, -
Type		- 1
;		1 2
var

 
sourceToString

 
=

 
Call

 !
(

! "
sourceExpression

" 2
,

2 3
ObjectToString

4 B
)

B C
;

C D
var 
result 
= 
Variable 
( 
destinationType -
,- .
$str/ E
)E F
;F G
var 

ignoreCase 
= 
True 
; 
var 
tryParse 
= 
Call 
( 
TryParseMethod *
.* +
MakeGenericMethod+ <
(< =
destinationType= L
)L M
,M N
sourceToStringO ]
,] ^

ignoreCase_ i
,i j
resultk q
)q r
;r s
var 
( 
	variables 
, 

statements "
)" #
=$ %
configuration& 3
.3 4

Scratchpad4 >
(> ?
)? @
;@ A
	variables 
. 
Add 
( 
result 
) 
; 

statements 
. 
Add 
( 
	Condition  
(  !
tryParse! )
,) *
result+ 1
,1 2
Convert3 :
(: ;
sourceExpression; K
,K L
destinationTypeM \
)\ ]
)] ^
)^ _
;_ `
return 
Block 
( 
	variables 
, 

statements  *
)* +
;+ ,
} 
} â
QC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ConvertMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
ConvertMapper !
:" #
IObjectMapper$ 1
{ 
public 

static 
bool 
IsPrimitive "
(" #
Type# '
type( ,
), -
=>. 0
type1 5
.5 6
IsPrimitive6 A
||B D
typeE I
==J L
typeofM S
(S T
stringT Z
)Z [
||\ ^
type_ c
==d f
typeofg m
(m n
decimaln u
)u v
;v w
public 

bool 
IsMatch 
( 
TypePair  
types! &
)& '
=>( *
(+ ,
types, 1
.1 2

SourceType2 <
=== ?
typeof@ F
(F G
stringG M
)M N
&&O Q
typesR W
.W X
DestinationTypeX g
==h j
typeofk q
(q r
DateTimer z
)z {
){ |
||} 
( 	
IsPrimitive	 
( 
types 
. 

SourceType %
)% &
&&' )
IsPrimitive* 5
(5 6
types6 ;
.; <
DestinationType< K
)K L
)L M
;M N
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap 
	memberMap 
, 

Expression '
sourceExpression( 8
,8 9

Expression: D
destExpressionE S
)S T
{		 
var

 
convertMethod

 
=

 
typeof

 "
(

" #
Convert

# *
)

* +
.

+ ,
	GetMethod

, 5
(

5 6
$str

6 :
+

; <
destExpression

= K
.

K L
Type

L P
.

P Q
Name

Q U
,

U V
[

W X
sourceExpression

X h
.

h i
Type

i m
]

m n
)

n o
;

o p
return 
Call 
( 
convertMethod !
,! "
sourceExpression# 3
)3 4
;4 5
} 
} ì
\C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ConversionOperatorMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class $
ConversionOperatorMapper ,
:- .
IObjectMapper/ <
{ 
private 
readonly 
string 
_operatorName )
;) *
public 
$
ConversionOperatorMapper #
(# $
string$ *
operatorName+ 7
)7 8
=>9 ;
_operatorName< I
=J K
operatorNameL X
;X Y
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,!
GetConversionOperator- B
(B C
contextC J
.J K

SourceTypeK U
,U V
contextW ^
.^ _
DestinationType_ n
)n o
!=p r
nulls w
;w x
private 

MethodInfo !
GetConversionOperator ,
(, -
Type- 1

sourceType2 <
,< =
Type> B
destinationTypeC R
)R S
{ 
foreach		 
(		 

MethodInfo		 
sourceMethod		 (
in		) +

sourceType		, 6
.		6 7
	GetMember		7 @
(		@ A
_operatorName		A N
,		N O
MemberTypes		P [
.		[ \
Method		\ b
,		b c
BindingFlags		d p
.		p q
Static		q w
|		x y
BindingFlags			z Ü
.
		Ü á
Public
		á ç
|
		é è
BindingFlags
		ê ú
.
		ú ù
FlattenHierarchy
		ù ≠
)
		≠ Æ
)
		Æ Ø
{

 	
if 
( 
destinationType 
.  
IsAssignableFrom  0
(0 1
sourceMethod1 =
.= >

ReturnType> H
)H I
)I J
{ 
return 
sourceMethod #
;# $
} 
} 	
return 
destinationType 
. 
	GetMethod (
(( )
_operatorName) 6
,6 7
TypeExtensions8 F
.F G
StaticFlagsG R
,R S
nullT X
,X Y
[Z [

sourceType[ e
]e f
,f g
nullh l
)l m
;m n
} 
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
{ 
var 
conversionOperator 
=  !
GetConversionOperator! 6
(6 7
sourceExpression7 G
.G H
TypeH L
,L M
destExpressionN \
.\ ]
Type] a
)a b
;b c
return 
Call 
( 
conversionOperator &
,& '
ToType( .
(. /
sourceExpression/ ?
,? @
conversionOperatorA S
.S T
FirstParameterTypeT f
(f g
)g h
)h i
)i j
;j k
} 
} ÷
UC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\ConstructorMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
ConstructorMapper %
:& '
IObjectMapper( 5
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
GetConstructor- ;
(; <
context< C
.C D

SourceTypeD N
,N O
contextP W
.W X
DestinationTypeX g
)g h
!=i k
nulll p
;p q
private 
static 
ConstructorInfo "
GetConstructor# 1
(1 2
Type2 6

sourceType7 A
,A B
TypeC G
destinationTypeH W
)W X
=>Y [
destinationType 
. 
GetConstructor &
(& '
TypeExtensions' 5
.5 6
InstanceFlags6 C
,C D
nullE I
,I J
[K L

sourceTypeL V
]V W
,W X
nullY ]
)] ^
;^ _
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
{ 
var		 
constructor		 
=		 
GetConstructor		 (
(		( )
sourceExpression		) 9
.		9 :
Type		: >
,		> ?
destExpression		@ N
.		N O
Type		O S
)		S T
;		T U
return

 
New

 
(

 
constructor

 
,

 
ToType

  &
(

& '
sourceExpression

' 7
,

7 8
constructor

9 D
.

D E
FirstParameterType

E W
(

W X
)

X Y
)

Y Z
)

Z [
;

[ \
} 
} ‹•
TC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\CollectionMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
CollectionMapper $
:% &
IObjectMapper' 4
{ 
static 

readonly 

MethodInfo 
IListAdd '
=( )
typeof* 0
(0 1
IList1 6
)6 7
.7 8
	GetMethod8 A
(A B
nameofB H
(H I
IListI N
.N O
AddO R
)R S
)S T
;T U
public		 

TypePair		 
?		 
GetAssociatedTypes		 '
(		' (
TypePair		( 0
context		1 8
)		8 9
=>		: <
new		= @
(		@ A
GetElementType		A O
(		O P
context		P W
.		W X

SourceType		X b
)		b c
,		c d
GetElementType		e s
(		s t
context		t {
.		{ |
DestinationType			| ã
)
		ã å
)
		å ç
;
		ç é
public

 

bool

 
IsMatch

 
(

 
TypePair

  
context

! (
)

( )
=>

* ,
context

- 4
.

4 5
IsCollection

5 A
(

A B
)

B C
;

C D
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap_ h
	memberMapi r
,r s

Expressiont ~
sourceExpression	 è
,
è ê

Expression
ë õ
destExpression
ú ™
)
™ ´
{ 
var 
destinationType 
= 
destExpression ,
., -
Type- 1
;1 2
if 

( 
destinationType 
. 
IsArray #
)# $
{ 	
return 
ArrayMapper 
. 

MapToArray )
() *
configuration* 7
,7 8

profileMap9 C
,C D
sourceExpressionE U
,U V
destinationTypeW f
)f g
;g h
} 	
if 

( 
destinationType 
. 
IsGenericType )
() *
typeof* 0
(0 1
ReadOnlyCollection1 C
<C D
>D E
)E F
)F G
)G H
{ 	
return !
MapReadOnlyCollection (
(( )
typeof) /
(/ 0
List0 4
<4 5
>5 6
)6 7
,7 8
typeof9 ?
(? @
ReadOnlyCollection@ R
<R S
>S T
)T U
)U V
;V W
} 	
if 

( 
destinationType 
. 
IsGenericType )
() *
typeof* 0
(0 1
ReadOnlyDictionary1 C
<C D
,D E
>E F
)F G
)G H
||I K
destinationTypeL [
.[ \
IsGenericType\ i
(i j
typeofj p
(p q 
IReadOnlyDictionary	q Ñ
<
Ñ Ö
,
Ö Ü
>
Ü á
)
á à
)
à â
)
â ä
{ 	
return !
MapReadOnlyCollection (
(( )
typeof) /
(/ 0

Dictionary0 :
<: ;
,; <
>< =
)= >
,> ?
typeof@ F
(F G
ReadOnlyDictionaryG Y
<Y Z
,Z [
>[ \
)\ ]
)] ^
;^ _
} 	
if 

( 
destinationType 
== 
sourceExpression /
./ 0
Type0 4
&&5 7
destinationType8 G
.G H
NameH L
==M O
nameofP V
(V W
NameValueCollectionW j
)j k
)k l
{ 	
return %
CreateNameValueCollection ,
(, -
sourceExpression- =
)= >
;> ?
} 	
return 
MapCollectionCore  
(  !
destExpression! /
)/ 0
;0 1

Expression !
MapReadOnlyCollection (
(( )
Type) -!
genericCollectionType. C
,C D
TypeE I)
genericReadOnlyCollectionTypeJ g
)g h
{   	
var!! $
destinationTypeArguments!! (
=!!) *
destinationType!!+ :
.!!: ; 
GenericTypeArguments!!; O
;!!O P
var""  
closedCollectionType"" $
=""% &!
genericCollectionType""' <
.""< =
MakeGenericType""= L
(""L M$
destinationTypeArguments""M e
)""e f
;""f g
var## 
dict## 
=## 
MapCollectionCore## (
(##( )
configuration##) 6
.##6 7
Default##7 >
(##> ? 
closedCollectionType##? S
)##S T
)##T U
;##U V
var$$ 
readOnlyClosedType$$ "
=$$# $
destinationType$$% 4
.$$4 5
IsInterface$$5 @
?$$A B)
genericReadOnlyCollectionType$$C `
.$$` a
MakeGenericType$$a p
($$p q%
destinationTypeArguments	$$q â
)
$$â ä
:
$$ã å
destinationType
$$ç ú
;
$$ú ù
return%% 
New%% 
(%% 
readOnlyClosedType%% )
.%%) *
GetConstructors%%* 9
(%%9 :
)%%: ;
[%%; <
$num%%< =
]%%= >
,%%> ?
dict%%@ D
)%%D E
;%%E F
}&& 	

Expression'' 
MapCollectionCore'' $
(''$ %

Expression''% /
destExpression''0 >
)''> ?
{(( 	
var)) 
destinationType)) 
=))  !
destExpression))" 0
.))0 1
Type))1 5
;))5 6
var** 

sourceType** 
=** 
sourceExpression** -
.**- .
Type**. 2
;**2 3

MethodInfo++ 
	addMethod++  
=++! "
null++# '
;++' (
bool,, 
isIList,, 
=,, 
false,,  
,,,  !
mustUseDestination,," 4
=,,5 6
	memberMap,,7 @
is,,A C
{,,D E
MustUseDestination,,F X
:,,X Y
true,,Z ^
},,_ `
;,,` a
Type-- %
destinationCollectionType-- *
=--+ ,
null--- 1
,--1 2"
destinationElementType--3 I
=--J K
null--L P
;--P Q
GetDestinationType.. 
(.. 
)..  
;..  !
var// 
passedDestination// !
=//" #
Variable//$ ,
(//, -
destExpression//- ;
.//; <
Type//< @
,//@ A
$str//B U
)//U V
;//V W
var00 
newExpression00 
=00 
Variable00  (
(00( )
passedDestination00) :
.00: ;
Type00; ?
,00? @
$str00A X
)00X Y
;00Y Z
var11 
sourceElementType11 !
=11" #$
GetEnumerableElementType11$ <
(11< =

sourceType11= G
)11G H
;11H I
if22 
(22 %
destinationCollectionType22 )
==22* ,
null22- 1
||222 4
(225 6

sourceType226 @
==22A C
sourceElementType22D U
&&22V X
destinationType22Y h
==22i k#
destinationElementType	22l Ç
)
22Ç É
)
22É Ñ
{33 
return44 
destinationType44 &
.44& '
IsAssignableFrom44' 7
(447 8

sourceType448 B
)44B C
?44D E
sourceExpression55 ,
:55- .
Throw66 !
(66! "
Constant66" *
(66* +
new66+ .!
NotSupportedException66/ D
(66D E
$"66E G
$str	66G Å
{
66Å Ç

sourceType
66Ç å
}
66å ç
$str
66ç ë
{
66ë í
destinationType
66í °
}
66° ¢
$str
66¢ £
"
66£ §
)
66§ •
)
66• ¶
,
66¶ ß
destinationType
66® ∑
)
66∑ ∏
;
66∏ π
}77 
var88 
	itemParam88 
=88 
	Parameter88 %
(88% &
sourceElementType88& 7
,887 8
$str889 ?
)88? @
;88@ A
var99 
itemExpr99 
=99 
configuration99 (
.99( )
MapExpression99) 6
(996 7

profileMap997 A
,99A B
new99C F
(99F G
sourceElementType99G X
,99X Y"
destinationElementType99Z p
)99p q
,99q r
	itemParam99s |
)99| }
;99} ~

Expression:: 
destination:: "
,::" #
assignNewExpression::$ 7
;::7 8
UseDestinationValue;; 
(;;  
);;  !
;;;! "
var<< 
(<< 
	variables<< 
,<< 

statements<< &
)<<& '
=<<( )
configuration<<* 7
.<<7 8

Scratchpad<<8 B
(<<B C
)<<C D
;<<D E

statements== 
.== 
Add== 
(== 
itemExpr== #
)==# $
;==$ %
var>> 
addCall>> 
=>> 
Call>> 
(>> 
destination>> *
,>>* +
	addMethod>>, 5
,>>5 6

statements>>7 A
)>>A B
;>>B C

statements?? 
.?? 
Clear?? 
(?? 
)?? 
;?? 
var@@ 
addItems@@ 
=@@ 
ForEach@@ "
(@@" #
	variables@@# ,
,@@, -

statements@@. 8
,@@8 9
	itemParam@@: C
,@@C D
sourceExpression@@E U
,@@U V
addCall@@W ^
)@@^ _
;@@_ `
varAA 
overMaxDepthAA 
=AA 
OverMaxDepthAA +
(AA+ ,
	memberMapAA, 5
?AA5 6
.AA6 7
TypeMapAA7 >
)AA> ?
;AA? @
ifBB 
(BB 
overMaxDepthBB 
!=BB 
nullBB  $
)BB$ %
{CC 
addItemsDD 
=DD 

IfThenElseDD %
(DD% &
overMaxDepthDD& 2
,DD2 3
ExpressionBuilderDD4 E
.DDE F
EmptyDDF K
,DDK L
addItemsDDM U
)DDU V
;DDV W
}EE 
varFF 
clearMethodFF 
=FF 
isIListFF %
?FF& '

IListClearFF( 2
:FF3 4%
destinationCollectionTypeFF5 N
.FFN O
	GetMethodFFO X
(FFX Y
$strFFY `
)FF` a
;FFa b

statementsGG 
.GG 
ClearGG 
(GG 
)GG 
;GG 
	variablesHH 
.HH 
ClearHH 
(HH 
)HH 
;HH 
	variablesII 
.II 
AddII 
(II 
newExpressionII '
)II' (
;II( )
	variablesJJ 
.JJ 
AddJJ 
(JJ 
passedDestinationJJ +
)JJ+ ,
;JJ, -
varKK 
checkContextKK 
=KK 
CheckContextKK +
(KK+ ,
)KK, -
;KK- .
ifLL 
(LL 
checkContextLL 
!=LL 
nullLL  $
)LL$ %
{MM 

statementsNN 
.NN 
AddNN 
(NN 
checkContextNN +
)NN+ ,
;NN, -
}OO 

statementsPP 
.PP 
AddPP 
(PP 
AssignPP !
(PP! "
passedDestinationPP" 3
,PP3 4
destExpressionPP5 C
)PPC D
)PPD E
;PPE F

statementsQQ 
.QQ 
AddQQ 
(QQ 
assignNewExpressionQQ .
)QQ. /
;QQ/ 0

statementsRR 
.RR 
AddRR 
(RR 
CallRR 
(RR  
destinationRR  +
,RR+ ,
clearMethodRR- 8
)RR8 9
)RR9 :
;RR: ;

statementsSS 
.SS 
AddSS 
(SS 
addItemsSS #
)SS# $
;SS$ %

statementsTT 
.TT 
AddTT 
(TT 
destinationTT &
)TT& '
;TT' (
returnUU 
BlockUU 
(UU 
	variablesUU "
,UU" #

statementsUU$ .
)UU. /
;UU/ 0
voidVV 
GetDestinationTypeVV #
(VV# $
)VV$ %
{WW 
varXX 
immutableCollectionXX '
=XX( )
!XX* +
mustUseDestinationXX+ =
&&XX> @
destinationTypeXXA P
.XXP Q
IsValueTypeXXQ \
;XX\ ]
ifYY 
(YY 
immutableCollectionYY '
)YY' (
{ZZ 
return[[ 
;[[ 
}\\ %
destinationCollectionType]] )
=]]* +
destinationType]], ;
.]]; <
GetICollectionType]]< N
(]]N O
)]]O P
;]]P Q
isIList^^ 
=^^ 
destExpression^^ (
.^^( )
Type^^) -
.^^- .

IsListType^^. 8
(^^8 9
)^^9 :
;^^: ;
if__ 
(__ %
destinationCollectionType__ -
==__. 0
null__1 5
)__5 6
{`` 
ifaa 
(aa 
isIListaa 
)aa  
{bb %
destinationCollectionTypecc 1
=cc2 3
typeofcc4 :
(cc: ;
IListcc; @
)cc@ A
;ccA B
	addMethoddd !
=dd" #
IListAdddd$ ,
;dd, -"
destinationElementTypeee .
=ee/ 0$
GetEnumerableElementTypeee1 I
(eeI J
destinationTypeeeJ Y
)eeY Z
;eeZ [
}ff 
elsegg 
{hh 
ifii 
(ii 
!ii 
destinationTypeii ,
.ii, -
IsInterfaceii- 8
)ii8 9
{jj 
returnkk "
;kk" #
}ll "
destinationElementTypemm .
=mm/ 0$
GetEnumerableElementTypemm1 I
(mmI J
destinationTypemmJ Y
)mmY Z
;mmZ [%
destinationCollectionTypenn 1
=nn2 3
destinationTypenn4 C
.nnC D
IsGenericTypennD Q
(nnQ R
typeofnnR X
(nnX Y
IReadOnlySetnnY e
<nne f
>nnf g
)nng h
)nnh i
?nnj k
typeofnnl r
(nnr s
HashSetnns z
<nnz {
>nn{ |
)nn| }
:nn~ 
typeof
nnÄ Ü
(
nnÜ á
ICollection
nná í
<
nní ì
>
nnì î
)
nnî ï
;
nnï ñ%
destinationCollectionTypeoo 1
=oo2 3%
destinationCollectionTypeoo4 M
.ooM N
MakeGenericTypeooN ]
(oo] ^"
destinationElementTypeoo^ t
)oot u
;oou v
destExpressionpp &
=pp' (
Convertpp) 0
(pp0 1
mustUseDestinationpp1 C
?ppD E
destExpressionppF T
:ppU V
NullppW [
,pp[ \%
destinationCollectionTypepp] v
)ppv w
;ppw x
	addMethodqq !
=qq" #%
destinationCollectionTypeqq$ =
.qq= >
	GetMethodqq> G
(qqG H
$strqqH M
)qqM N
;qqN O
}rr 
}ss 
elsett 
{uu "
destinationElementTypevv *
=vv+ ,%
destinationCollectionTypevv- F
.vvF G 
GenericTypeArgumentsvvG [
[vv[ \
$numvv\ ]
]vv] ^
;vv^ _
	addMethodww 
=ww %
destinationCollectionTypeww  9
.ww9 :
	GetMethodww: C
(wwC D
$strwwD I
)wwI J
;wwJ K
}xx 
}yy 
voidzz 
UseDestinationValuezz $
(zz$ %
)zz% &
{{{ 
if|| 
(|| 
mustUseDestination|| &
)||& '
{}} 
destination~~ 
=~~  !
passedDestination~~" 3
;~~3 4
assignNewExpression '
=( )
ExpressionBuilder* ;
.; <
Empty< A
;A B
}
ÄÄ 
else
ÅÅ 
{
ÇÇ 
destination
ÉÉ 
=
ÉÉ  !
newExpression
ÉÉ" /
;
ÉÉ/ 0
var
ÑÑ 
ctor
ÑÑ 
=
ÑÑ 
ObjectFactory
ÑÑ ,
.
ÑÑ, -+
GenerateConstructorExpression
ÑÑ- J
(
ÑÑJ K
passedDestination
ÑÑK \
.
ÑÑ\ ]
Type
ÑÑ] a
,
ÑÑa b
configuration
ÑÑc p
)
ÑÑp q
;
ÑÑq r!
assignNewExpression
ÖÖ '
=
ÖÖ( )
Assign
ÖÖ* 0
(
ÖÖ0 1
newExpression
ÖÖ1 >
,
ÖÖ> ?
Coalesce
ÖÖ@ H
(
ÖÖH I
passedDestination
ÖÖI Z
,
ÖÖZ [
ctor
ÖÖ\ `
)
ÖÖ` a
)
ÖÖa b
;
ÖÖb c
}
ÜÜ 
}
áá 

Expression
àà 
CheckContext
àà #
(
àà# $
)
àà$ %
{
ââ 
var
ää 
elementTypeMap
ää "
=
ää# $
configuration
ää% 2
.
ää2 3
ResolveTypeMap
ää3 A
(
ääA B
sourceElementType
ääB S
,
ääS T$
destinationElementType
ääU k
)
ääk l
;
ääl m
return
ãã 
elementTypeMap
ãã %
==
ãã& (
null
ãã) -
?
ãã. /
null
ãã0 4
:
ãã5 6
ExpressionBuilder
ãã7 H
.
ããH I
CheckContext
ããI U
(
ããU V
elementTypeMap
ããV d
)
ããd e
;
ããe f
}
åå 
}
çç 	
}
éé 
private
èè 
static
èè 

Expression
èè '
CreateNameValueCollection
èè 7
(
èè7 8

Expression
èè8 B
sourceExpression
èèC S
)
èèS T
=>
èèU W
New
êê 
(
êê 
typeof
êê 
(
êê !
NameValueCollection
êê &
)
êê& '
.
êê' (
GetConstructor
êê( 6
(
êê6 7
[
êê7 8
typeof
êê8 >
(
êê> ?!
NameValueCollection
êê? R
)
êêR S
]
êêS T
)
êêT U
,
êêU V
sourceExpression
êêW g
)
êêg h
;
êêh i
static
ëë 

class
ëë 
ArrayMapper
ëë 
{
íí 
private
ìì 
static
ìì 
readonly
ìì 

MethodInfo
ìì  *
ToArrayMethod
ìì+ 8
=
ìì9 :
typeof
ìì; A
(
ììA B

Enumerable
ììB L
)
ììL M
.
ììM N
GetStaticMethod
ììN ]
(
ìì] ^
$str
ìì^ g
)
ììg h
;
ììh i
private
îî 
static
îî 
readonly
îî 

MethodInfo
îî  *
CopyToMethod
îî+ 7
=
îî8 9
typeof
îî: @
(
îî@ A
Array
îîA F
)
îîF G
.
îîG H
	GetMethod
îîH Q
(
îîQ R
$str
îîR Z
,
îîZ [
[
îî\ ]
typeof
îî] c
(
îîc d
Array
îîd i
)
îîi j
,
îîj k
typeof
îîl r
(
îîr s
int
îîs v
)
îîv w
]
îîw x
)
îîx y
;
îîy z
private
ïï 
static
ïï 
readonly
ïï 

MethodInfo
ïï  *
CountMethod
ïï+ 6
=
ïï7 8
typeof
ïï9 ?
(
ïï? @

Enumerable
ïï@ J
)
ïïJ K
.
ïïK L!
StaticGenericMethod
ïïL _
(
ïï_ `
$str
ïï` g
,
ïïg h
parametersCount
ïïi x
:
ïïx y
$num
ïïz {
)
ïï{ |
;
ïï| }
private
ññ 
static
ññ 
readonly
ññ 

MethodInfo
ññ  *'
MapMultidimensionalMethod
ññ+ D
=
ññE F
typeof
ññG M
(
ññM N
ArrayMapper
ññN Y
)
ññY Z
.
ññZ [
GetStaticMethod
ññ[ j
(
ññj k
nameof
ññk q
(
ññq r"
MapMultidimensionalññr Ö
)ññÖ Ü
)ññÜ á
;ññá à
private
óó 
static
óó 
readonly
óó !
ParameterExpression
óó  3
Index
óó4 9
=
óó: ;
Variable
óó< D
(
óóD E
typeof
óóE K
(
óóK L
int
óóL O
)
óóO P
,
óóP Q
$str
óóR i
)
óói j
;
óój k
private
òò 
static
òò 
readonly
òò 
BinaryExpression
òò  0

ResetIndex
òò1 ;
=
òò< =
Assign
òò> D
(
òòD E
Index
òòE J
,
òòJ K
Zero
òòL P
)
òòP Q
;
òòQ R
private
ôô 
static
ôô 
readonly
ôô  
ReadOnlyCollection
ôô  2
<
ôô2 3

Expression
ôô3 =
>
ôô= >
IncrementIndex
ôô? M
=
ôôN O!
PostIncrementAssign
ôôP c
(
ôôc d
Index
ôôd i
)
ôôi j
.
ôôj k

ToReadOnly
ôôk u
<
ôôu v

Expressionôôv Ä
>ôôÄ Å
(ôôÅ Ç
)ôôÇ É
;ôôÉ Ñ
private
öö 
static
öö 
Array
öö !
MapMultidimensional
öö 0
(
öö0 1
Array
öö1 6
source
öö7 =
,
öö= >
Type
öö? C$
destinationElementType
ööD Z
,
ööZ [
ResolutionContext
öö\ m
context
öön u
)
ööu v
{
õõ 	
var
úú 
sourceElementType
úú !
=
úú" #
source
úú$ *
.
úú* +
GetType
úú+ 2
(
úú2 3
)
úú3 4
.
úú4 5
GetElementType
úú5 C
(
úúC D
)
úúD E
;
úúE F
var
ùù 
destinationArray
ùù  
=
ùù! "
Array
ùù# (
.
ùù( )
CreateInstance
ùù) 7
(
ùù7 8$
destinationElementType
ùù8 N
,
ùùN O

Enumerable
ùùP Z
.
ùùZ [
Range
ùù[ `
(
ùù` a
$num
ùùa b
,
ùùb c
source
ùùd j
.
ùùj k
Rank
ùùk o
)
ùùo p
.
ùùp q
Select
ùùq w
(
ùùw x
source
ùùx ~
.
ùù~ 
	GetLengthùù à
)ùùà â
.ùùâ ä
ToArrayùùä ë
(ùùë í
)ùùí ì
)ùùì î
;ùùî ï)
MultidimensionalArrayFiller
ûû '
filler
ûû( .
=
ûû/ 0
new
ûû1 4
(
ûû4 5
destinationArray
ûû5 E
)
ûûE F
;
ûûF G
foreach
üü 
(
üü 
var
üü 
item
üü 
in
üü  
source
üü! '
)
üü' (
{
†† 
filler
°° 
.
°° 
NewValue
°° 
(
°°  
context
°°  '
.
°°' (
Map
°°( +
(
°°+ ,
item
°°, 0
,
°°0 1
null
°°2 6
,
°°6 7
sourceElementType
°°8 I
,
°°I J$
destinationElementType
°°K a
,
°°a b
null
°°c g
)
°°g h
)
°°h i
;
°°i j
}
¢¢ 
return
££ 
destinationArray
££ #
;
££# $
}
§§ 	
public
•• 
static
•• 

Expression
••  

MapToArray
••! +
(
••+ ,"
IGlobalConfiguration
••, @
configuration
••A N
,
••N O

ProfileMap
••P Z

profileMap
••[ e
,
••e f

Expression
••g q
sourceExpression••r Ç
,••Ç É
Type••Ñ à
destinationType••â ò
)••ò ô
{
¶¶ 	
var
ßß $
destinationElementType
ßß &
=
ßß' (
destinationType
ßß) 8
.
ßß8 9
GetElementType
ßß9 G
(
ßßG H
)
ßßH I
;
ßßI J
if
®® 
(
®® 
destinationType
®® 
.
®®  
GetArrayRank
®®  ,
(
®®, -
)
®®- .
>
®®/ 0
$num
®®1 2
)
®®2 3
{
©© 
return
™™ 
Call
™™ 
(
™™ '
MapMultidimensionalMethod
™™ 5
,
™™5 6
sourceExpression
™™7 G
,
™™G H
Constant
™™I Q
(
™™Q R$
destinationElementType
™™R h
)
™™h i
,
™™i j
ContextParameter
™™k {
)
™™{ |
;
™™| }
}
´´ 
var
¨¨ 

sourceType
¨¨ 
=
¨¨ 
sourceExpression
¨¨ -
.
¨¨- .
Type
¨¨. 2
;
¨¨2 3
Type
≠≠ 
sourceElementType
≠≠ "
=
≠≠# $
typeof
≠≠% +
(
≠≠+ ,
object
≠≠, 2
)
≠≠2 3
;
≠≠3 4

Expression
ÆÆ 
createDestination
ÆÆ (
;
ÆÆ( )
var
ØØ 
destination
ØØ 
=
ØØ 
	Parameter
ØØ '
(
ØØ' (
destinationType
ØØ( 7
,
ØØ7 8
$str
ØØ9 K
)
ØØK L
;
ØØL M
var
∞∞ 
(
∞∞ 
	variables
∞∞ 
,
∞∞ 

statements
∞∞ &
)
∞∞& '
=
∞∞( )
configuration
∞∞* 7
.
∞∞7 8

Scratchpad
∞∞8 B
(
∞∞B C
)
∞∞C D
;
∞∞D E
if
±± 
(
±± 

sourceType
±± 
.
±± 
IsArray
±± "
)
±±" #
{
≤≤ 
var
≥≥ 
mapFromArray
≥≥  
=
≥≥! "
MapFromArray
≥≥# /
(
≥≥/ 0
)
≥≥0 1
;
≥≥1 2
if
¥¥ 
(
¥¥ 
mapFromArray
¥¥  
!=
¥¥! #
null
¥¥$ (
)
¥¥( )
{
µµ 
return
∂∂ 
mapFromArray
∂∂ '
;
∂∂' (
}
∑∑ 
}
∏∏ 
else
ππ 
{
∫∫ 
var
ªª  
mapFromIEnumerable
ªª &
=
ªª' ( 
MapFromIEnumerable
ªª) ;
(
ªª; <
)
ªª< =
;
ªª= >
if
ºº 
(
ºº  
mapFromIEnumerable
ºº &
!=
ºº' )
null
ºº* .
)
ºº. /
{
ΩΩ 
return
ææ  
mapFromIEnumerable
ææ -
;
ææ- .
}
øø 
var
¿¿ 
count
¿¿ 
=
¿¿ 
Call
¿¿  
(
¿¿  !
CountMethod
¿¿! ,
.
¿¿, -
MakeGenericMethod
¿¿- >
(
¿¿> ?
sourceElementType
¿¿? P
)
¿¿P Q
,
¿¿Q R
sourceExpression
¿¿S c
)
¿¿c d
;
¿¿d e

statements
¡¡ 
.
¡¡ 
Add
¡¡ 
(
¡¡ 
count
¡¡ $
)
¡¡$ %
;
¡¡% &
createDestination
¬¬ !
=
¬¬" #
Assign
¬¬$ *
(
¬¬* +
destination
¬¬+ 6
,
¬¬6 7
NewArrayBounds
¬¬8 F
(
¬¬F G$
destinationElementType
¬¬G ]
,
¬¬] ^

statements
¬¬_ i
)
¬¬i j
)
¬¬j k
;
¬¬k l
}
√√ 
var
ƒƒ 
	itemParam
ƒƒ 
=
ƒƒ 
	Parameter
ƒƒ %
(
ƒƒ% &
sourceElementType
ƒƒ& 7
,
ƒƒ7 8
$str
ƒƒ9 E
)
ƒƒE F
;
ƒƒF G
var
≈≈ 
itemExpr
≈≈ 
=
≈≈ 
configuration
≈≈ (
.
≈≈( )
MapExpression
≈≈) 6
(
≈≈6 7

profileMap
≈≈7 A
,
≈≈A B
new
≈≈C F
(
≈≈F G
sourceElementType
≈≈G X
,
≈≈X Y$
destinationElementType
≈≈Z p
)
≈≈p q
,
≈≈q r
	itemParam
≈≈s |
)
≈≈| }
;
≈≈} ~
var
∆∆ 
setItem
∆∆ 
=
∆∆ 
Assign
∆∆  
(
∆∆  !
ArrayAccess
∆∆! ,
(
∆∆, -
destination
∆∆- 8
,
∆∆8 9
IncrementIndex
∆∆: H
)
∆∆H I
,
∆∆I J
itemExpr
∆∆K S
)
∆∆S T
;
∆∆T U
	variables
«« 
.
«« 
Clear
«« 
(
«« 
)
«« 
;
«« 

statements
»» 
.
»» 
Clear
»» 
(
»» 
)
»» 
;
»» 
var
…… 
forEach
…… 
=
…… 
ForEach
…… !
(
……! "
	variables
……" +
,
……+ ,

statements
……- 7
,
……7 8
	itemParam
……9 B
,
……B C
sourceExpression
……D T
,
……T U
setItem
……V ]
)
……] ^
;
……^ _
	variables
   
.
   
Clear
   
(
   
)
   
;
   

statements
ÀÀ 
.
ÀÀ 
Clear
ÀÀ 
(
ÀÀ 
)
ÀÀ 
;
ÀÀ 
	variables
ÃÃ 
.
ÃÃ 
Add
ÃÃ 
(
ÃÃ 
destination
ÃÃ %
)
ÃÃ% &
;
ÃÃ& '
	variables
ÕÕ 
.
ÕÕ 
Add
ÕÕ 
(
ÕÕ 
Index
ÕÕ 
)
ÕÕ  
;
ÕÕ  !

statements
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
createDestination
ŒŒ ,
)
ŒŒ, -
;
ŒŒ- .

statements
œœ 
.
œœ 
Add
œœ 
(
œœ 

ResetIndex
œœ %
)
œœ% &
;
œœ& '

statements
–– 
.
–– 
Add
–– 
(
–– 
forEach
–– "
)
––" #
;
––# $

statements
—— 
.
—— 
Add
—— 
(
—— 
destination
—— &
)
——& '
;
——' (
return
““ 
Block
““ 
(
““ 
	variables
““ "
,
““" #

statements
““$ .
)
““. /
;
““/ 0

Expression
”” 
MapFromArray
”” #
(
””# $
)
””$ %
{
‘‘ 
sourceElementType
’’ !
=
’’" #

sourceType
’’$ .
.
’’. /
GetElementType
’’/ =
(
’’= >
)
’’> ?
;
’’? @

statements
÷÷ 
.
÷÷ 
Add
÷÷ 
(
÷÷ 
ArrayLength
÷÷ *
(
÷÷* +
sourceExpression
÷÷+ ;
)
÷÷; <
)
÷÷< =
;
÷÷= >
createDestination
◊◊ !
=
◊◊" #
Assign
◊◊$ *
(
◊◊* +
destination
◊◊+ 6
,
◊◊6 7
NewArrayBounds
◊◊8 F
(
◊◊F G$
destinationElementType
◊◊G ]
,
◊◊] ^

statements
◊◊_ i
)
◊◊i j
)
◊◊j k
;
◊◊k l
if
ÿÿ 
(
ÿÿ 
MustMap
ÿÿ 
(
ÿÿ 
sourceElementType
ÿÿ -
,
ÿÿ- .$
destinationElementType
ÿÿ/ E
)
ÿÿE F
)
ÿÿF G
{
ŸŸ 
return
⁄⁄ 
null
⁄⁄ 
;
⁄⁄  
}
€€ 
	variables
‹‹ 
.
‹‹ 
Clear
‹‹ 
(
‹‹  
)
‹‹  !
;
‹‹! "

statements
›› 
.
›› 
Clear
››  
(
››  !
)
››! "
;
››" #
	variables
ﬁﬁ 
.
ﬁﬁ 
Add
ﬁﬁ 
(
ﬁﬁ 
destination
ﬁﬁ )
)
ﬁﬁ) *
;
ﬁﬁ* +

statements
ﬂﬂ 
.
ﬂﬂ 
Add
ﬂﬂ 
(
ﬂﬂ 
createDestination
ﬂﬂ 0
)
ﬂﬂ0 1
;
ﬂﬂ1 2

statements
‡‡ 
.
‡‡ 
Add
‡‡ 
(
‡‡ 
Call
‡‡ #
(
‡‡# $
sourceExpression
‡‡$ 4
,
‡‡4 5
CopyToMethod
‡‡6 B
,
‡‡B C
destination
‡‡D O
,
‡‡O P
Zero
‡‡Q U
)
‡‡U V
)
‡‡V W
;
‡‡W X

statements
·· 
.
·· 
Add
·· 
(
·· 
destination
·· *
)
··* +
;
··+ ,
return
‚‚ 
Block
‚‚ 
(
‚‚ 
	variables
‚‚ &
,
‚‚& '

statements
‚‚( 2
)
‚‚2 3
;
‚‚3 4
}
„„ 

Expression
‰‰  
MapFromIEnumerable
‰‰ )
(
‰‰) *
)
‰‰* +
{
ÂÂ 
var
ÊÊ 
iEnumerableType
ÊÊ #
=
ÊÊ$ %

sourceType
ÊÊ& 0
.
ÊÊ0 1 
GetIEnumerableType
ÊÊ1 C
(
ÊÊC D
)
ÊÊD E
;
ÊÊE F
if
ÁÁ 
(
ÁÁ 
iEnumerableType
ÁÁ #
==
ÁÁ$ &
null
ÁÁ' +
||
ÁÁ, .
MustMap
ÁÁ/ 6
(
ÁÁ6 7
sourceElementType
ÁÁ7 H
=
ÁÁI J
iEnumerableType
ÁÁK Z
.
ÁÁZ ["
GenericTypeArguments
ÁÁ[ o
[
ÁÁo p
$num
ÁÁp q
]
ÁÁq r
,
ÁÁr s%
destinationElementTypeÁÁt ä
)ÁÁä ã
)ÁÁã å
{
ËË 
return
ÈÈ 
null
ÈÈ 
;
ÈÈ  
}
ÍÍ 
return
ÎÎ 
Call
ÎÎ 
(
ÎÎ 
ToArrayMethod
ÎÎ )
.
ÎÎ) *
MakeGenericMethod
ÎÎ* ;
(
ÎÎ; <
sourceElementType
ÎÎ< M
)
ÎÎM N
,
ÎÎN O
sourceExpression
ÎÎP `
)
ÎÎ` a
;
ÎÎa b
}
ÏÏ 
bool
ÌÌ 
MustMap
ÌÌ 
(
ÌÌ 
Type
ÌÌ 

sourceType
ÌÌ (
,
ÌÌ( )
Type
ÌÌ* .
destinationType
ÌÌ/ >
)
ÌÌ> ?
=>
ÌÌ@ B
!
ÌÌC D
destinationType
ÌÌD S
.
ÌÌS T
IsAssignableFrom
ÌÌT d
(
ÌÌd e

sourceType
ÌÌe o
)
ÌÌo p
||
ÌÌq s
configuration
ÓÓ 
.
ÓÓ 
FindTypeMapFor
ÓÓ ,
(
ÓÓ, -

sourceType
ÓÓ- 7
,
ÓÓ7 8
destinationType
ÓÓ9 H
)
ÓÓH I
!=
ÓÓJ L
null
ÓÓM Q
;
ÓÓQ R
}
ÔÔ 	
}
 
}ÒÒ 
publicÚÚ 
readonly
ÚÚ 
struct
ÚÚ )
MultidimensionalArrayFiller
ÚÚ 2
(
ÚÚ2 3
Array
ÚÚ3 8
destination
ÚÚ9 D
)
ÚÚD E
{ÛÛ 
readonly
ÙÙ 
int
ÙÙ 
[
ÙÙ 
]
ÙÙ 
_indices
ÙÙ 
=
ÙÙ 
new
ÙÙ !
int
ÙÙ" %
[
ÙÙ% &
destination
ÙÙ& 1
.
ÙÙ1 2
Rank
ÙÙ2 6
]
ÙÙ6 7
;
ÙÙ7 8
public
ıı 

void
ıı 
NewValue
ıı 
(
ıı 
object
ıı 
value
ıı  %
)
ıı% &
{
ˆˆ 
var
˜˜ 
	dimension
˜˜ 
=
˜˜ 
destination
˜˜ #
.
˜˜# $
Rank
˜˜$ (
-
˜˜) *
$num
˜˜+ ,
;
˜˜, -
var
¯¯ 
changedDimension
¯¯ 
=
¯¯ 
false
¯¯ $
;
¯¯$ %
while
˘˘ 
(
˘˘ 
_indices
˘˘ 
[
˘˘ 
	dimension
˘˘ !
]
˘˘! "
==
˘˘# %
destination
˘˘& 1
.
˘˘1 2
	GetLength
˘˘2 ;
(
˘˘; <
	dimension
˘˘< E
)
˘˘E F
)
˘˘F G
{
˙˙ 	
_indices
˚˚ 
[
˚˚ 
	dimension
˚˚ 
]
˚˚ 
=
˚˚  !
$num
˚˚" #
;
˚˚# $
	dimension
¸¸ 
--
¸¸ 
;
¸¸ 
if
˝˝ 
(
˝˝ 
	dimension
˝˝ 
<
˝˝ 
$num
˝˝ 
)
˝˝ 
{
˛˛ 
throw
ˇˇ 
new
ˇˇ '
InvalidOperationException
ˇˇ 3
(
ˇˇ3 4
$str
ˇˇ4 [
+
ˇˇ\ ]
destination
ˇˇ^ i
)
ˇˇi j
;
ˇˇj k
}
ÄÄ 
_indices
ÅÅ 
[
ÅÅ 
	dimension
ÅÅ 
]
ÅÅ 
++
ÅÅ !
;
ÅÅ! "
changedDimension
ÇÇ 
=
ÇÇ 
true
ÇÇ #
;
ÇÇ# $
}
ÉÉ 	
destination
ÑÑ 
.
ÑÑ 
SetValue
ÑÑ 
(
ÑÑ 
value
ÑÑ "
,
ÑÑ" #
_indices
ÑÑ$ ,
)
ÑÑ, -
;
ÑÑ- .
if
ÖÖ 

(
ÖÖ 
changedDimension
ÖÖ 
)
ÖÖ 
{
ÜÜ 	
_indices
áá 
[
áá 
	dimension
áá 
+
áá  
$num
áá! "
]
áá" #
++
áá# %
;
áá% &
}
àà 	
else
ââ 
{
ää 	
_indices
ãã 
[
ãã 
	dimension
ãã 
]
ãã 
++
ãã !
;
ãã! "
}
åå 	
}
çç 
}éé ƒ	
TC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mappers\AssignableMapper.cs
	namespace 	

AutoMapper
 
. 
Internal 
. 
Mappers %
;% &
public 
sealed 
class 
AssignableMapper $
:% &
IObjectMapper' 4
{ 
public 

bool 
IsMatch 
( 
TypePair  
context! (
)( )
=>* ,
context- 4
.4 5
DestinationType5 D
.D E
IsAssignableFromE U
(U V
contextV ]
.] ^

SourceType^ h
)h i
;i j
public 


Expression 
MapExpression #
(# $ 
IGlobalConfiguration$ 8
configuration9 F
,F G

ProfileMapH R

profileMapS ]
,] ^
	MemberMap 
	memberMap 
, 

Expression '
sourceExpression( 8
,8 9

Expression: D
destExpressionE S
)S T
=>U W
sourceExpressionX h
;h i
} ˆ∏
BC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Mapper.cs
	namespace 	

AutoMapper
 
; 
public 
	interface 
IMapperBase 
{ 
TDestination 
Map 
< 
TDestination !
>! "
(" #
object# )
source* 0
)0 1
;1 2
TDestination 
Map 
< 
TSource 
, 
TDestination *
>* +
(+ ,
TSource, 3
source4 :
): ;
;; <
TDestination 
Map 
< 
TSource 
, 
TDestination *
>* +
(+ ,
TSource, 3
source4 :
,: ;
TDestination< H
destinationI T
)T U
;U V
object'' 

Map'' 
('' 
object'' 
source'' 
,'' 
Type'' "

sourceType''# -
,''- .
Type''/ 3
destinationType''4 C
)''C D
;''D E
object00 

Map00 
(00 
object00 
source00 
,00 
object00 $
destination00% 0
,000 1
Type002 6

sourceType007 A
,00A B
Type00C G
destinationType00H W
)00W X
;00X Y
}11 
public22 
	interface22 
IMapper22 
:22 
IMapperBase22 &
{33 
TDestination;; 
Map;; 
<;; 
TDestination;; !
>;;! "
(;;" #
object;;# )
source;;* 0
,;;0 1
Action;;2 8
<;;8 9$
IMappingOperationOptions;;9 Q
<;;Q R
object;;R X
,;;X Y
TDestination;;Z f
>;;f g
>;;g h
opts;;i m
);;m n
;;;n o
TDestinationDD 
MapDD 
<DD 
TSourceDD 
,DD 
TDestinationDD *
>DD* +
(DD+ ,
TSourceDD, 3
sourceDD4 :
,DD: ;
ActionDD< B
<DDB C$
IMappingOperationOptionsDDC [
<DD[ \
TSourceDD\ c
,DDc d
TDestinationDDe q
>DDq r
>DDr s
optsDDt x
)DDx y
;DDy z
TDestinationNN 
MapNN 
<NN 
TSourceNN 
,NN 
TDestinationNN *
>NN* +
(NN+ ,
TSourceNN, 3
sourceNN4 :
,NN: ;
TDestinationNN< H
destinationNNI T
,NNT U
ActionNNV \
<NN\ ]$
IMappingOperationOptionsNN] u
<NNu v
TSourceNNv }
,NN} ~
TDestination	NN ã
>
NNã å
>
NNå ç
opts
NNé í
)
NNí ì
;
NNì î
objectWW 

MapWW 
(WW 
objectWW 
sourceWW 
,WW 
TypeWW "

sourceTypeWW# -
,WW- .
TypeWW/ 3
destinationTypeWW4 C
,WWC D
ActionWWE K
<WWK L*
IObjectMappingOperationOptionsWWL j
>WWj k
optsWWl p
)WWp q
;WWq r
objectaa 

Mapaa 
(aa 
objectaa 
sourceaa 
,aa 
objectaa $
destinationaa% 0
,aa0 1
Typeaa2 6

sourceTypeaa7 A
,aaA B
TypeaaC G
destinationTypeaaH W
,aaW X
ActionaaY _
<aa_ `*
IObjectMappingOperationOptionsaa` ~
>aa~ 
opts
aaÄ Ñ
)
aaÑ Ö
;
aaÖ Ü"
IConfigurationProvideree !
ConfigurationProvideree 0
{ee1 2
getee3 6
;ee6 7
}ee8 9

IQueryableoo 
<oo 
TDestinationoo 
>oo 
	ProjectTooo &
<oo& '
TDestinationoo' 3
>oo3 4
(oo4 5

IQueryableoo5 ?
sourceoo@ F
,ooF G
objectooH N

parametersooO Y
=ooZ [
nulloo\ `
,oo` a
paramsoob h

Expressionooi s
<oos t
Funcoot x
<oox y
TDestination	ooy Ö
,
ooÖ Ü
object
ooá ç
>
ooç é
>
ooé è
[
ooè ê
]
ooê ë
membersToExpand
ooí °
)
oo° ¢
;
oo¢ £

IQueryablexx 
<xx 
TDestinationxx 
>xx 
	ProjectToxx &
<xx& '
TDestinationxx' 3
>xx3 4
(xx4 5

IQueryablexx5 ?
sourcexx@ F
,xxF G
IDictionaryxxH S
<xxS T
stringxxT Z
,xxZ [
objectxx\ b
>xxb c

parametersxxd n
,xxn o
paramsxxp v
stringxxw }
[xx} ~
]xx~ 
membersToExpand
xxÄ è
)
xxè ê
;
xxê ë

IQueryable
ÅÅ 
	ProjectTo
ÅÅ 
(
ÅÅ 

IQueryable
ÅÅ #
source
ÅÅ$ *
,
ÅÅ* +
Type
ÅÅ, 0
destinationType
ÅÅ1 @
,
ÅÅ@ A
IDictionary
ÅÅB M
<
ÅÅM N
string
ÅÅN T
,
ÅÅT U
object
ÅÅV \
>
ÅÅ\ ]

parameters
ÅÅ^ h
=
ÅÅi j
null
ÅÅk o
,
ÅÅo p
params
ÅÅq w
string
ÅÅx ~
[
ÅÅ~ 
]ÅÅ Ä
membersToExpandÅÅÅ ê
)ÅÅê ë
;ÅÅë í
}ÇÇ 
publicÉÉ 
	interface
ÉÉ 
IRuntimeMapper
ÉÉ 
:
ÉÉ  !
IMapperBase
ÉÉ" -
{ÑÑ 
}ÖÖ 
internalÜÜ 
	interface
ÜÜ	 $
IInternalRuntimeMapper
ÜÜ )
:
ÜÜ* +
IRuntimeMapper
ÜÜ, :
{áá 
TDestination
àà 
Map
àà 
<
àà 
TSource
àà 
,
àà 
TDestination
àà *
>
àà* +
(
àà+ ,
TSource
àà, 3
source
àà4 :
,
àà: ;
TDestination
àà< H
destination
ààI T
,
ààT U
ResolutionContext
ààV g
context
ààh o
,
àào p
Type
ààq u

sourceTypeààv Ä
=ààÅ Ç
nullààÉ á
,ààá à
Typeààâ ç
destinationTypeààé ù
=ààû ü
nullàà† §
,àà§ •
	MemberMapàà¶ Ø
	memberMapàà∞ π
=àà∫ ª
nullààº ¿
)àà¿ ¡
;àà¡ ¬
ResolutionContext
ââ 
DefaultContext
ââ $
{
ââ% &
get
ââ' *
;
ââ* +
}
ââ, -
Factory
ää 
ServiceCtor
ää 
{
ää 
get
ää 
;
ää 
}
ää  
}ãã 
publicåå 
sealed
åå 
class
åå 
Mapper
åå 
:
åå 
IMapper
åå $
,
åå$ %$
IInternalRuntimeMapper
åå& <
{çç 
private
éé 
readonly
éé "
IGlobalConfiguration
éé )
_configuration
éé* 8
;
éé8 9
private
èè 
readonly
èè 
Factory
èè 
_serviceCtor
èè )
;
èè) *
private
êê 
readonly
êê 
ResolutionContext
êê &
_defaultContext
êê' 6
;
êê6 7
public
ëë 

Mapper
ëë 
(
ëë $
IConfigurationProvider
ëë (
configuration
ëë) 6
)
ëë6 7
:
ëë8 9
this
ëë: >
(
ëë> ?
configuration
ëë? L
,
ëëL M
configuration
ëëN [
.
ëë[ \
Internal
ëë\ d
(
ëëd e
)
ëëe f
.
ëëf g
ServiceCtor
ëëg r
)
ëër s
{
ëët u
}
ëëv w
public
íí 

Mapper
íí 
(
íí $
IConfigurationProvider
íí (
configuration
íí) 6
,
íí6 7
Factory
íí8 ?
serviceCtor
íí@ K
)
ííK L
{
ìì #
ArgumentNullException
îî 
.
îî 
ThrowIfNull
îî )
(
îî) *
configuration
îî* 7
)
îî7 8
;
îî8 9#
ArgumentNullException
ïï 
.
ïï 
ThrowIfNull
ïï )
(
ïï) *
serviceCtor
ïï* 5
)
ïï5 6
;
ïï6 7
_configuration
ññ 
=
ññ 
(
ññ "
IGlobalConfiguration
ññ .
)
ññ. /
configuration
ññ/ <
;
ññ< =
_serviceCtor
óó 
=
óó 
serviceCtor
óó "
;
óó" #
_defaultContext
òò 
=
òò 
new
òò 
(
òò 
this
òò "
)
òò" #
;
òò# $
}
ôô 
ResolutionContext
öö $
IInternalRuntimeMapper
öö ,
.
öö, -
DefaultContext
öö- ;
=>
öö< >
_defaultContext
öö? N
;
ööN O
Factory
õõ $
IInternalRuntimeMapper
õõ "
.
õõ" #
ServiceCtor
õõ# .
=>
õõ/ 1
_serviceCtor
õõ2 >
;
õõ> ?
public
úú 
$
IConfigurationProvider
úú !#
ConfigurationProvider
úú" 7
=>
úú8 :
_configuration
úú; I
;
úúI J
public
ùù 

TDestination
ùù 
Map
ùù 
<
ùù 
TDestination
ùù (
>
ùù( )
(
ùù) *
object
ùù* 0
source
ùù1 7
)
ùù7 8
=>
ùù9 ;
Map
ùù< ?
(
ùù? @
source
ùù@ F
,
ùùF G
default
ùùH O
(
ùùO P
TDestination
ùùP \
)
ùù\ ]
)
ùù] ^
;
ùù^ _
public
ûû 

TDestination
ûû 
Map
ûû 
<
ûû 
TDestination
ûû (
>
ûû( )
(
ûû) *
object
ûû* 0
source
ûû1 7
,
ûû7 8
Action
ûû9 ?
<
ûû? @&
IMappingOperationOptions
ûû@ X
<
ûûX Y
object
ûûY _
,
ûû_ `
TDestination
ûûa m
>
ûûm n
>
ûûn o
opts
ûûp t
)
ûût u
=>
ûûv x
Map
ûûy |
(
ûû| }
sourceûû} É
,ûûÉ Ñ
defaultûûÖ å
,ûûå ç
optsûûé í
)ûûí ì
;ûûì î
public
üü 

TDestination
üü 
Map
üü 
<
üü 
TSource
üü #
,
üü# $
TDestination
üü% 1
>
üü1 2
(
üü2 3
TSource
üü3 :
source
üü; A
)
üüA B
=>
üüC E
Map
üüF I
(
üüI J
source
üüJ P
,
üüP Q
default
üüR Y
(
üüY Z
TDestination
üüZ f
)
üüf g
)
üüg h
;
üüh i
public
†† 

TDestination
†† 
Map
†† 
<
†† 
TSource
†† #
,
††# $
TDestination
††% 1
>
††1 2
(
††2 3
TSource
††3 :
source
††; A
,
††A B
Action
††C I
<
††I J&
IMappingOperationOptions
††J b
<
††b c
TSource
††c j
,
††j k
TDestination
††l x
>
††x y
>
††y z
opts
††{ 
)†† Ä
=>††Å É
Map
°° 
(
°° 
source
°° 
,
°° 
default
°° 
,
°° 
opts
°° !
)
°°! "
;
°°" #
public
¢¢ 

TDestination
¢¢ 
Map
¢¢ 
<
¢¢ 
TSource
¢¢ #
,
¢¢# $
TDestination
¢¢% 1
>
¢¢1 2
(
¢¢2 3
TSource
¢¢3 :
source
¢¢; A
,
¢¢A B
TDestination
¢¢C O
destination
¢¢P [
)
¢¢[ \
=>
¢¢] _
MapCore
££ 
(
££ 
source
££ 
,
££ 
destination
££ #
,
££# $
_defaultContext
££% 4
)
££4 5
;
££5 6
public
§§ 

TDestination
§§ 
Map
§§ 
<
§§ 
TSource
§§ #
,
§§# $
TDestination
§§% 1
>
§§1 2
(
§§2 3
TSource
§§3 :
source
§§; A
,
§§A B
TDestination
§§C O
destination
§§P [
,
§§[ \
Action
§§] c
<
§§c d&
IMappingOperationOptions
§§d |
<
§§| }
TSource§§} Ñ
,§§Ñ Ö
TDestination§§Ü í
>§§í ì
>§§ì î
opts§§ï ô
)§§ô ö
=>§§õ ù
MapWithOptions
•• 
(
•• 
source
•• 
,
•• 
destination
•• *
,
••* +
opts
••, 0
)
••0 1
;
••1 2
public
¶¶ 

object
¶¶ 
Map
¶¶ 
(
¶¶ 
object
¶¶ 
source
¶¶ #
,
¶¶# $
Type
¶¶% )

sourceType
¶¶* 4
,
¶¶4 5
Type
¶¶6 :
destinationType
¶¶; J
)
¶¶J K
=>
¶¶L N
Map
¶¶O R
(
¶¶R S
source
¶¶S Y
,
¶¶Y Z
null
¶¶[ _
,
¶¶_ `

sourceType
¶¶a k
,
¶¶k l
destinationType
¶¶m |
)
¶¶| }
;
¶¶} ~
public
ßß 

object
ßß 
Map
ßß 
(
ßß 
object
ßß 
source
ßß #
,
ßß# $
Type
ßß% )

sourceType
ßß* 4
,
ßß4 5
Type
ßß6 :
destinationType
ßß; J
,
ßßJ K
Action
ßßL R
<
ßßR S,
IObjectMappingOperationOptions
ßßS q
>
ßßq r
opts
ßßs w
)
ßßw x
=>
ßßy {
Map
®® 
(
®® 
source
®® 
,
®® 
null
®® 
,
®® 

sourceType
®® $
,
®®$ %
destinationType
®®& 5
,
®®5 6
opts
®®7 ;
)
®®; <
;
®®< =
public
©© 

object
©© 
Map
©© 
(
©© 
object
©© 
source
©© #
,
©©# $
object
©©% +
destination
©©, 7
,
©©7 8
Type
©©9 =

sourceType
©©> H
,
©©H I
Type
©©J N
destinationType
©©O ^
)
©©^ _
=>
©©` b
MapCore
™™ 
(
™™ 
source
™™ 
,
™™ 
destination
™™ #
,
™™# $
_defaultContext
™™% 4
,
™™4 5

sourceType
™™6 @
,
™™@ A
destinationType
™™B Q
)
™™Q R
;
™™R S
public
´´ 

object
´´ 
Map
´´ 
(
´´ 
object
´´ 
source
´´ #
,
´´# $
object
´´% +
destination
´´, 7
,
´´7 8
Type
´´9 =

sourceType
´´> H
,
´´H I
Type
´´J N
destinationType
´´O ^
,
´´^ _
Action
´´` f
<
´´f g-
IObjectMappingOperationOptions´´g Ö
>´´Ö Ü
opts´´á ã
)´´ã å
=>´´ç è
MapWithOptions
¨¨ 
(
¨¨ 
source
¨¨ 
,
¨¨ 
destination
¨¨ *
,
¨¨* +
opts
¨¨, 0
,
¨¨0 1

sourceType
¨¨2 <
,
¨¨< =
destinationType
¨¨> M
)
¨¨M N
;
¨¨N O
public
≠≠ 


IQueryable
≠≠ 
<
≠≠ 
TDestination
≠≠ "
>
≠≠" #
	ProjectTo
≠≠$ -
<
≠≠- .
TDestination
≠≠. :
>
≠≠: ;
(
≠≠; <

IQueryable
≠≠< F
source
≠≠G M
,
≠≠M N
object
≠≠O U

parameters
≠≠V `
,
≠≠` a
params
≠≠b h

Expression
≠≠i s
<
≠≠s t
Func
≠≠t x
<
≠≠x y
TDestination≠≠y Ö
,≠≠Ö Ü
object≠≠á ç
>≠≠ç é
>≠≠é è
[≠≠è ê
]≠≠ê ë
membersToExpand≠≠í °
)≠≠° ¢
=>
ÆÆ 

source
ÆÆ 
.
ÆÆ 
	ProjectTo
ÆÆ 
(
ÆÆ #
ConfigurationProvider
ÆÆ 1
,
ÆÆ1 2

parameters
ÆÆ3 =
,
ÆÆ= >
membersToExpand
ÆÆ? N
)
ÆÆN O
;
ÆÆO P
public
ØØ 


IQueryable
ØØ 
<
ØØ 
TDestination
ØØ "
>
ØØ" #
	ProjectTo
ØØ$ -
<
ØØ- .
TDestination
ØØ. :
>
ØØ: ;
(
ØØ; <

IQueryable
ØØ< F
source
ØØG M
,
ØØM N
IDictionary
ØØO Z
<
ØØZ [
string
ØØ[ a
,
ØØa b
object
ØØc i
>
ØØi j

parameters
ØØk u
,
ØØu v
params
ØØw }
stringØØ~ Ñ
[ØØÑ Ö
]ØØÖ Ü
membersToExpandØØá ñ
)ØØñ ó
=>
∞∞ 

source
∞∞ 
.
∞∞ 
	ProjectTo
∞∞ 
<
∞∞ 
TDestination
∞∞ (
>
∞∞( )
(
∞∞) *#
ConfigurationProvider
∞∞* ?
,
∞∞? @

parameters
∞∞A K
,
∞∞K L
membersToExpand
∞∞M \
)
∞∞\ ]
;
∞∞] ^
public
±± 


IQueryable
±± 
	ProjectTo
±± 
(
±±  

IQueryable
±±  *
source
±±+ 1
,
±±1 2
Type
±±3 7
destinationType
±±8 G
,
±±G H
IDictionary
±±I T
<
±±T U
string
±±U [
,
±±[ \
object
±±] c
>
±±c d

parameters
±±e o
,
±±o p
params
±±q w
string
±±x ~
[
±±~ 
]±± Ä
membersToExpand±±Å ê
)±±ê ë
=>
≤≤ 

source
≤≤ 
.
≤≤ 
	ProjectTo
≤≤ 
(
≤≤ 
destinationType
≤≤ +
,
≤≤+ ,#
ConfigurationProvider
≤≤- B
,
≤≤B C

parameters
≤≤D N
,
≤≤N O
membersToExpand
≤≤P _
)
≤≤_ `
;
≤≤` a
TDestination
≥≥ $
IInternalRuntimeMapper
≥≥ '
.
≥≥' (
Map
≥≥( +
<
≥≥+ ,
TSource
≥≥, 3
,
≥≥3 4
TDestination
≥≥5 A
>
≥≥A B
(
≥≥B C
TSource
≥≥C J
source
≥≥K Q
,
≥≥Q R
TDestination
≥≥S _
destination
≥≥` k
,
≥≥k l
ResolutionContext
¥¥ 
context
¥¥ !
,
¥¥! "
Type
¥¥# '

sourceType
¥¥( 2
,
¥¥2 3
Type
¥¥4 8
destinationType
¥¥9 H
,
¥¥H I
	MemberMap
¥¥J S
	memberMap
¥¥T ]
)
¥¥] ^
=>
¥¥_ a
MapCore
µµ 
(
µµ 
source
µµ 
,
µµ 
destination
µµ #
,
µµ# $
context
µµ% ,
,
µµ, -

sourceType
µµ. 8
,
µµ8 9
destinationType
µµ: I
,
µµI J
	memberMap
µµK T
)
µµT U
;
µµU V
private
∂∂ 
TDestination
∂∂ 
MapWithOptions
∂∂ '
<
∂∂' (
TSource
∂∂( /
,
∂∂/ 0
TDestination
∂∂1 =
>
∂∂= >
(
∂∂> ?
TSource
∂∂? F
source
∂∂G M
,
∂∂M N
TDestination
∂∂O [
destination
∂∂\ g
,
∂∂g h
Action
∂∂i o
<
∂∂o p'
IMappingOperationOptions∂∂p à
<∂∂à â
TSource∂∂â ê
,∂∂ê ë
TDestination∂∂í û
>∂∂û ü
>∂∂ü †
opts∂∂° •
,∂∂• ¶
Type
∑∑ 

sourceType
∑∑ 
=
∑∑ 
null
∑∑ 
,
∑∑ 
Type
∑∑  $
destinationType
∑∑% 4
=
∑∑5 6
null
∑∑7 ;
)
∑∑; <
{
∏∏ %
MappingOperationOptions
ππ 
<
ππ  
TSource
ππ  '
,
ππ' (
TDestination
ππ) 5
>
ππ5 6
typedOptions
ππ7 C
=
ππD E
new
ππF I
(
ππI J
_serviceCtor
ππJ V
)
ππV W
;
ππW X
opts
∫∫ 
(
∫∫ 
typedOptions
∫∫ 
)
∫∫ 
;
∫∫ 
typedOptions
ªª 
.
ªª 
BeforeMapAction
ªª $
?
ªª$ %
.
ªª% &
Invoke
ªª& ,
(
ªª, -
source
ªª- 3
,
ªª3 4
destination
ªª5 @
)
ªª@ A
;
ªªA B
destination
ºº 
=
ºº 
MapCore
ºº 
(
ºº 
source
ºº $
,
ºº$ %
destination
ºº& 1
,
ºº1 2
new
ºº3 6
(
ºº6 7
this
ºº7 ;
,
ºº; <
typedOptions
ºº= I
)
ººI J
,
ººJ K

sourceType
ººL V
,
ººV W
destinationType
ººX g
)
ººg h
;
ººh i
typedOptions
ΩΩ 
.
ΩΩ 
AfterMapAction
ΩΩ #
?
ΩΩ# $
.
ΩΩ$ %
Invoke
ΩΩ% +
(
ΩΩ+ ,
source
ΩΩ, 2
,
ΩΩ2 3
destination
ΩΩ4 ?
)
ΩΩ? @
;
ΩΩ@ A
return
ææ 
destination
ææ 
;
ææ 
}
øø 
private
¿¿ 
TDestination
¿¿ 
MapCore
¿¿  
<
¿¿  !
TSource
¿¿! (
,
¿¿( )
TDestination
¿¿* 6
>
¿¿6 7
(
¿¿7 8
TSource
¡¡ 
source
¡¡ 
,
¡¡ 
TDestination
¡¡ $
destination
¡¡% 0
,
¡¡0 1
ResolutionContext
¡¡2 C
context
¡¡D K
,
¡¡K L
Type
¡¡M Q

sourceType
¡¡R \
=
¡¡] ^
null
¡¡_ c
,
¡¡c d
Type
¡¡e i
destinationType
¡¡j y
=
¡¡z {
null¡¡| Ä
,¡¡Ä Å
	MemberMap¡¡Ç ã
	memberMap¡¡å ï
=¡¡ñ ó
null¡¡ò ú
)¡¡ú ù
{
¬¬ 
TypePair
√√ 
requestedTypes
√√ 
=
√√  !
new
√√" %
(
√√% &
typeof
√√& ,
(
√√, -
TSource
√√- 4
)
√√4 5
,
√√5 6
typeof
√√7 =
(
√√= >
TDestination
√√> J
)
√√J K
)
√√K L
;
√√L M
TypePair
ƒƒ 
runtimeTypes
ƒƒ 
=
ƒƒ 
new
ƒƒ  #
(
ƒƒ# $
source
ƒƒ$ *
?
ƒƒ* +
.
ƒƒ+ ,
GetType
ƒƒ, 3
(
ƒƒ3 4
)
ƒƒ4 5
??
ƒƒ6 8

sourceType
ƒƒ9 C
??
ƒƒD F
typeof
ƒƒG M
(
ƒƒM N
TSource
ƒƒN U
)
ƒƒU V
,
ƒƒV W
destination
ƒƒX c
?
ƒƒc d
.
ƒƒd e
GetType
ƒƒe l
(
ƒƒl m
)
ƒƒm n
??
ƒƒo q
destinationTypeƒƒr Å
??ƒƒÇ Ñ
typeofƒƒÖ ã
(ƒƒã å
TDestinationƒƒå ò
)ƒƒò ô
)ƒƒô ö
;ƒƒö õ

MapRequest
≈≈ 

mapRequest
≈≈ 
=
≈≈ 
new
≈≈  #
(
≈≈# $
requestedTypes
≈≈$ 2
,
≈≈2 3
runtimeTypes
≈≈4 @
,
≈≈@ A
	memberMap
≈≈B K
)
≈≈K L
;
≈≈L M
return
∆∆ 
_configuration
∆∆ 
.
∆∆ 
GetExecutionPlan
∆∆ .
<
∆∆. /
TSource
∆∆/ 6
,
∆∆6 7
TDestination
∆∆8 D
>
∆∆D E
(
∆∆E F

mapRequest
∆∆F P
)
∆∆P Q
(
∆∆Q R
source
∆∆R X
,
∆∆X Y
destination
∆∆Z e
,
∆∆e f
context
∆∆g n
)
∆∆n o
;
∆∆o p
}
«« 
}»» ¶0
MC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\TypePair.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
[ 
DebuggerDisplay 
( 
$str	 †
)
† °
]
° ¢
public 
readonly 
record 
struct 

MapRequest (
(( )
TypePair) 1
RequestedTypes2 @
,@ A
TypePairB J
RuntimeTypesK W
,W X
	MemberMapY b
	MemberMapc l
)l m
{ 
public 


MapRequest 
( 
TypePair 
types $
)$ %
:& '
this( ,
(, -
types- 2
,2 3
types4 9
,9 :
	MemberMap; D
.D E
InstanceE M
)M N
{O P
}Q R
public 

bool 
Equals 
( 

MapRequest !
other" '
)' (
=>) +
RequestedTypes, :
.: ;
Equals; A
(A B
otherB G
.G H
RequestedTypesH V
)V W
&&X Z
RuntimeTypes[ g
.g h
Equalsh n
(n o
othero t
.t u
RuntimeTypes	u Å
)
Å Ç
;
Ç É
public 

override 
int 
GetHashCode #
(# $
)$ %
=>& (
HashCode) 1
.1 2
Combine2 9
(9 :
RequestedTypes: H
,H I
RuntimeTypesJ V
)V W
;W X
} 
[		 
DebuggerDisplay		 
(		 
$str		 <
)		< =
]		= >
public

 
readonly

 
record

 
struct

 
TypePair

 &
(

& '
Type

' +

SourceType

, 6
,

6 7
Type

8 <
DestinationType

= L
)

L M
{ 
public 

bool $
IsConstructedGenericType (
=>) +

SourceType, 6
.6 7$
IsConstructedGenericType7 O
||P R
DestinationTypeS b
.b c$
IsConstructedGenericTypec {
;{ |
public 

bool %
ContainsGenericParameters )
=>* ,

SourceType- 7
.7 8%
ContainsGenericParameters8 Q
||R T
DestinationTypeU d
.d e%
ContainsGenericParameterse ~
;~ 
public 

TypePair 
CloseGenericTypes %
(% &
TypePair& .
closedTypes/ :
): ;
{ 
var 
sourceArguments 
= 
closedTypes )
.) *

SourceType* 4
.4 5 
GenericTypeArguments5 I
;I J
var  
destinationArguments  
=! "
closedTypes# .
.. /
DestinationType/ >
.> ? 
GenericTypeArguments? S
;S T
if 

(
 
sourceArguments 
. 
Length !
==" $
$num% &
)& '
{ 	
sourceArguments 
=  
destinationArguments 2
;2 3
} 	
else 
if 
(  
destinationArguments $
.$ %
Length% +
==, .
$num/ 0
)0 1
{ 	 
destinationArguments  
=! "
sourceArguments# 2
;2 3
} 	
var 
closedSourceType 
= 

SourceType )
.) *#
IsGenericTypeDefinition* A
?B C

SourceTypeD N
.N O
MakeGenericTypeO ^
(^ _
sourceArguments_ n
)n o
:p q

SourceTyper |
;| }
var !
closedDestinationType !
=" #
DestinationType$ 3
.3 4#
IsGenericTypeDefinition4 K
?L M
DestinationTypeN ]
.] ^
MakeGenericType^ m
(m n!
destinationArguments	n Ç
)
Ç É
:
Ñ Ö
DestinationType
Ü ï
;
ï ñ
return 
new 
( 
closedSourceType #
,# $!
closedDestinationType% :
): ;
;; <
} 
public 

TypePair 
Reverse 
( 
) 
=>  
new! $
($ %
DestinationType% 4
,4 5

SourceType6 @
)@ A
;A B
public 

Type 
ITypeConverter 
( 
)  
=>! #%
ContainsGenericParameters$ =
?> ?
null@ D
:E F
typeofG M
(M N
ITypeConverterN \
<\ ]
,] ^
>^ _
)_ `
.` a
MakeGenericTypea p
(p q

SourceTypeq {
,{ |
DestinationType	} å
)
å ç
;
ç é
public   

TypePair   &
GetTypeDefinitionIfGeneric   .
(  . /
)  / 0
=>  1 3
new  4 7
(  7 8&
GetTypeDefinitionIfGeneric  8 R
(  R S

SourceType  S ]
)  ] ^
,  ^ _&
GetTypeDefinitionIfGeneric  ` z
(  z {
DestinationType	  { ä
)
  ä ã
)
  ã å
;
  å ç
static!! 

Type!! &
GetTypeDefinitionIfGeneric!! *
(!!* +
Type!!+ /
type!!0 4
)!!4 5
=>!!6 8
type!!9 =
.!!= >
IsGenericType!!> K
?!!L M
type!!N R
.!!R S$
GetGenericTypeDefinition!!S k
(!!k l
)!!l m
:!!n o
type!!p t
;!!t u
}"" áÉ
SC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\TypeExtensions.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
public 
static 
class 
TypeExtensions "
{ 
public 

const 
BindingFlags 
InstanceFlags +
=, -
BindingFlags. :
.: ;
Instance; C
|D E
BindingFlagsF R
.R S
PublicS Y
|Z [
BindingFlags\ h
.h i
	NonPublici r
|s t
BindingFlags	u Å
.
Å Ç
DeclaredOnly
Ç é
;
é è
public 

const 
BindingFlags 
StaticFlags )
=* +
BindingFlags, 8
.8 9
Static9 ?
|@ A
BindingFlagsB N
.N O
PublicO U
|V W
BindingFlagsX d
.d e
	NonPublice n
|o p
BindingFlagsq }
.} ~
DeclaredOnly	~ ä
;
ä ã
public		 

static		 

MethodInfo		 
StaticGenericMethod		 0
(		0 1
this		1 5
Type		6 :
type		; ?
,		? @
string		A G

methodName		H R
,		R S
int		T W
parametersCount		X g
)		g h
{

 
foreach 
( 

MethodInfo 
foundMethod '
in( *
type+ /
./ 0
	GetMember0 9
(9 :

methodName: D
,D E
MemberTypesF Q
.Q R
MethodR X
,X Y
StaticFlagsZ e
&f g
~h i
BindingFlagsi u
.u v
	NonPublicv 
)	 Ä
)
Ä Å
{ 	
if 
( 
foundMethod 
. %
IsGenericMethodDefinition 5
&&6 8
foundMethod9 D
.D E
GetParametersE R
(R S
)S T
.T U
LengthU [
==\ ^
parametersCount_ n
)n o
{ 
return 
foundMethod "
;" #
} 
} 	
throw 
new '
ArgumentOutOfRangeException -
(- .
nameof. 4
(4 5

methodName5 ?
)? @
,@ A
$"B D
$strD `
{` a
typea e
}e f
$strf g
{g h

methodNameh r
}r s
$strs t
{t u
parametersCount	u Ñ
}
Ñ Ö
$str
Ö í
"
í ì
)
ì î
;
î ï
} 
public 

static 
void 
CheckIsDerivedFrom )
() *
this* .
Type/ 3
derivedType4 ?
,? @
TypeA E
baseTypeF N
)N O
{ 
if 

( 
! 
baseType 
. 
IsAssignableFrom &
(& '
derivedType' 2
)2 3
&&4 6
!7 8
derivedType8 C
.C D#
IsGenericTypeDefinitionD [
&&\ ^
!_ `
baseType` h
.h i$
IsGenericTypeDefinition	i Ä
)
Ä Å
{ 	
throw 
new '
ArgumentOutOfRangeException 1
(1 2
nameof2 8
(8 9
derivedType9 D
)D E
,E F
$"G I
{I J
derivedTypeJ U
}U V
$strV k
{k l
baseTypel t
}t u
$stru v
"v w
)w x
;x y
} 	
} 
public 

static 
bool 
	IsDynamic  
(  !
this! %
Type& *
type+ /
)/ 0
=>1 3
typeof4 :
(: ;&
IDynamicMetaObjectProvider; U
)U V
.V W
IsAssignableFromW g
(g h
typeh l
)l m
;m n
public 

static 
IEnumerable 
< 
Type "
>" #$
BaseClassesAndInterfaces$ <
(< =
this= A
TypeB F
typeG K
)K L
{   
var!! 
currentType!! 
=!! 
type!! 
;!! 
while"" 
("" 
("" 
currentType"" 
="" 
currentType"" )
."") *
BaseType""* 2
)""2 3
!=""4 6
null""7 ;
)""; <
{## 	
yield$$ 
return$$ 
currentType$$ $
;$$$ %
}%% 	
foreach&& 
(&& 
var&& 
interfaceType&& "
in&&# %
type&&& *
.&&* +
GetInterfaces&&+ 8
(&&8 9
)&&9 :
)&&: ;
{'' 	
yield(( 
return(( 
interfaceType(( &
;((& '
})) 	
}** 
public,, 

static,, 
PropertyInfo,,  
GetInheritedProperty,, 3
(,,3 4
this,,4 8
Type,,9 =
type,,> B
,,,B C
string,,D J
name,,K O
),,O P
=>,,Q S
type,,T X
.,,X Y
GetProperty,,Y d
(,,d e
name,,e i
,,,i j
InstanceFlags,,k x
),,x y
??,,z |
type	,,} Å
.
,,Å Ç
GetBaseProperty
,,Ç ë
(
,,ë í
name
,,í ñ
)
,,ñ ó
;
,,ó ò
static-- 

PropertyInfo-- 
GetBaseProperty-- '
(--' (
this--( ,
Type--- 1
type--2 6
,--6 7
string--8 >
name--? C
)--C D
=>--E G
type.. 
... $
BaseClassesAndInterfaces.. %
(..% &
)..& '
...' (
Select..( .
(... /
t../ 0
=>..1 3
t..4 5
...5 6
GetProperty..6 A
(..A B
name..B F
,..F G
InstanceFlags..H U
)..U V
)..V W
...W X
FirstOrDefault..X f
(..f g
p..g h
=>..i k
p..l m
!=..n p
null..q u
)..u v
;..v w
public// 

static// 
	FieldInfo// 
GetInheritedField// -
(//- .
this//. 2
Type//3 7
type//8 <
,//< =
string//> D
name//E I
)//I J
=>//K M
type//N R
.//R S
GetField//S [
(//[ \
name//\ `
,//` a
InstanceFlags//b o
)//o p
??//q s
type//t x
.//x y
GetBaseField	//y Ö
(
//Ö Ü
name
//Ü ä
)
//ä ã
;
//ã å
static00 

	FieldInfo00 
GetBaseField00 !
(00! "
this00" &
Type00' +
type00, 0
,000 1
string002 8
name009 =
)00= >
=>00? A
type11 
.11 $
BaseClassesAndInterfaces11 %
(11% &
)11& '
.11' (
Select11( .
(11. /
t11/ 0
=>111 3
t114 5
.115 6
GetField116 >
(11> ?
name11? C
,11C D
InstanceFlags11E R
)11R S
)11S T
.11T U
FirstOrDefault11U c
(11c d
f11d e
=>11f h
f11i j
!=11k m
null11n r
)11r s
;11s t
public22 

static22 

MethodInfo22 
GetInheritedMethod22 /
(22/ 0
this220 4
Type225 9
type22: >
,22> ?
string22@ F
name22G K
)22K L
=>22M O
type22P T
.22T U
GetInstanceMethod22U f
(22f g
name22g k
)22k l
??22m o
type22p t
.22t u
GetBaseMethod	22u Ç
(
22Ç É
name
22É á
)
22á à
??
22â ã
throw33 
new33 '
ArgumentOutOfRangeException33 -
(33- .
nameof33. 4
(334 5
name335 9
)339 :
,33: ;
$"33< >
$str33> Q
{33Q R
name33R V
}33V W
$str33W `
{33` a
type33a e
}33e f
$str33f g
"33g h
)33h i
;33i j
static44 


MethodInfo44 
GetBaseMethod44 #
(44# $
this44$ (
Type44) -
type44. 2
,442 3
string444 :
name44; ?
)44? @
=>44A C
type55 
.55 $
BaseClassesAndInterfaces55 %
(55% &
)55& '
.55' (
Select55( .
(55. /
t55/ 0
=>551 3
t554 5
.555 6
GetInstanceMethod556 G
(55G H
name55H L
)55L M
)55M N
.55N O
FirstOrDefault55O ]
(55] ^
m55^ _
=>55` b
m55c d
!=55e g
null55h l
)55l m
;55m n
public77 

static77 

MemberInfo77 
GetFieldOrProperty77 /
(77/ 0
this770 4
Type775 9
type77: >
,77> ?
string77@ F
name77G K
)77K L
=>88 

type88 
.88  
GetInheritedProperty88 $
(88$ %
name88% )
)88) *
??88+ -
(88. /

MemberInfo88/ 9
)889 :
type88: >
.88> ?
GetInheritedField88? P
(88P Q
name88Q U
)88U V
??88W Y
throw88Z _
new88` c'
ArgumentOutOfRangeException88d 
(	88 Ä
nameof
88Ä Ü
(
88Ü á
name
88á ã
)
88ã å
,
88å ç
$"
88é ê
$str
88ê £
{
88£ §
name
88§ ®
}
88® ©
$str
88© ≤
{
88≤ ≥
type
88≥ ∑
}
88∑ ∏
$str
88∏ π
"
88π ∫
)
88∫ ª
;
88ª º
public:: 

static:: 
bool:: 
IsNullableType:: %
(::% &
this::& *
Type::+ /
type::0 4
)::4 5
=>::6 8
type::9 =
.::= >
IsGenericType::> K
(::K L
typeof::L R
(::R S
Nullable::S [
<::[ \
>::\ ]
)::] ^
)::^ _
;::_ `
public<< 

static<< 
Type<< 
GetICollectionType<< )
(<<) *
this<<* .
Type<</ 3
type<<4 8
)<<8 9
=><<: <
type<<= A
.<<A B
GetGenericInterface<<B U
(<<U V
typeof<<V \
(<<\ ]
ICollection<<] h
<<<h i
><<i j
)<<j k
)<<k l
;<<l m
public>> 

static>> 
bool>> 
IsCollection>> #
(>># $
this>>$ (
Type>>) -
type>>. 2
)>>2 3
=>>>4 6
type>>7 ;
!=>>< >
typeof>>? E
(>>E F
string>>F L
)>>L M
&&>>N P
typeof>>Q W
(>>W X
IEnumerable>>X c
)>>c d
.>>d e
IsAssignableFrom>>e u
(>>u v
type>>v z
)>>z {
;>>{ |
public@@ 

static@@ 
bool@@ 

IsListType@@ !
(@@! "
this@@" &
Type@@' +
type@@, 0
)@@0 1
=>@@2 4
typeof@@5 ;
(@@; <
IList@@< A
)@@A B
.@@B C
IsAssignableFrom@@C S
(@@S T
type@@T X
)@@X Y
;@@Y Z
publicBB 

staticBB 
boolBB 
IsGenericTypeBB $
(BB$ %
thisBB% )
TypeBB* .
typeBB/ 3
,BB3 4
TypeBB5 9
genericTypeBB: E
)BBE F
=>BBG I
typeBBJ N
.BBN O
IsGenericTypeBBO \
&&BB] _
typeBB` d
.BBd e$
GetGenericTypeDefinitionBBe }
(BB} ~
)BB~ 
==
BBÄ Ç
genericType
BBÉ é
;
BBé è
publicDD 

staticDD 
TypeDD 
GetIEnumerableTypeDD )
(DD) *
thisDD* .
TypeDD/ 3
typeDD4 8
)DD8 9
=>DD: <
typeDD= A
.DDA B
GetGenericInterfaceDDB U
(DDU V
typeofDDV \
(DD\ ]
IEnumerableDD] h
<DDh i
>DDi j
)DDj k
)DDk l
;DDl m
publicFF 

staticFF 
TypeFF 
GetGenericInterfaceFF *
(FF* +
thisFF+ /
TypeFF0 4
typeFF5 9
,FF9 :
TypeFF; ?
genericInterfaceFF@ P
)FFP Q
{GG 
ifHH 

(HH 
typeHH 
.HH 
IsGenericTypeHH 
(HH 
genericInterfaceHH /
)HH/ 0
)HH0 1
{II 	
returnJJ 
typeJJ 
;JJ 
}KK 	
varLL 

interfacesLL 
=LL 
typeLL 
.LL 
GetInterfacesLL +
(LL+ ,
)LL, -
;LL- .
forMM 
(MM 
intMM 
indexMM 
=MM 

interfacesMM #
.MM# $
LengthMM$ *
-MM+ ,
$numMM- .
;MM. /
indexMM0 5
>=MM6 8
$numMM9 :
;MM: ;
indexMM< A
--MMA C
)MMC D
{NN 	
varOO 
interfaceTypeOO 
=OO 

interfacesOO  *
[OO* +
indexOO+ 0
]OO0 1
;OO1 2
ifPP 
(PP 
interfaceTypePP 
.PP 
IsGenericTypePP +
(PP+ ,
genericInterfacePP, <
)PP< =
)PP= >
{QQ 
returnRR 
interfaceTypeRR $
;RR$ %
}SS 
}TT 	
returnUU 
nullUU 
;UU 
}VV 
publicXX 

staticXX 
ConstructorInfoXX !
[XX! "
]XX" ##
GetDeclaredConstructorsXX$ ;
(XX; <
thisXX< @
TypeXXA E
typeXXF J
)XXJ K
=>XXL N
typeXXO S
.XXS T
GetConstructorsXXT c
(XXc d
InstanceFlagsXXd q
)XXq r
;XXr s
publicZZ 

staticZZ 
intZZ "
GenericParametersCountZZ ,
(ZZ, -
thisZZ- 1
TypeZZ2 6
typeZZ7 ;
)ZZ; <
=>ZZ= ?
typeZZ@ D
.ZZD E
GetTypeInfoZZE P
(ZZP Q
)ZZQ R
.ZZR S!
GenericTypeParametersZZS h
.ZZh i
LengthZZi o
;ZZo p
public\\ 

static\\ 
IEnumerable\\ 
<\\ 
Type\\ "
>\\" #
GetTypeInheritance\\$ 6
(\\6 7
this\\7 ;
Type\\< @
type\\A E
)\\E F
{]] 
while^^ 
(^^ 
type^^ 
!=^^ 
null^^ 
)^^ 
{__ 	
yield`` 
return`` 
type`` 
;`` 
typeaa 
=aa 
typeaa 
.aa 
BaseTypeaa  
;aa  !
}bb 	
}cc 
publicee 

staticee 

MethodInfoee 
GetStaticMethodee ,
(ee, -
thisee- 1
Typeee2 6
typeee7 ;
,ee; <
stringee= C
nameeeD H
)eeH I
=>eeJ L
typeeeM Q
.eeQ R
	GetMethodeeR [
(ee[ \
nameee\ `
,ee` a
StaticFlagseeb m
)eem n
;een o
publicff 

staticff 

MethodInfoff 
GetInstanceMethodff .
(ff. /
thisff/ 3
Typeff4 8
typeff9 =
,ff= >
stringff? E
nameffF J
)ffJ K
=>ffL N
(gg 	

MethodInfogg	 
)gg 
typegg 
.gg 
	GetMembergg "
(gg" #
namegg# '
,gg' (
MemberTypesgg) 4
.gg4 5
Methodgg5 ;
,gg; <
InstanceFlagsgg= J
)ggJ K
.ggK L
FirstOrDefaultggL Z
(ggZ [
)gg[ \
;gg\ ]
}hh öﬂ
PC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\TypeDetails.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
[ 
DebuggerDisplay 
( 
$str 
) 
] 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 
TypeDetails 
(  
Type  $
type% )
,) *

ProfileMap+ 5
config6 <
)< =
{ 
public		 

Type		 
Type		 
{		 
get		 
;		 
}		 
=		 
type		  $
;		$ %
public

 


ProfileMap

 
Config

 
{

 
get

 "
;

" #
}

$ %
=

& '
config

( .
;

. /
private 

Dictionary 
< 
string 
, 

MemberInfo )
>) *
_nameToMember+ 8
;8 9
private !
ConstructorParameters !
[! "
]" #
_constructors$ 1
;1 2
private 

MemberInfo 
[ 
] 
_readAccessors '
;' (
private 

MemberInfo 
[ 
] 
_writeAccessors (
;( )
private !
ConstructorParameters !
[! "
]" #
GetConstructors$ 3
(3 4
)4 5
=>6 8
GetConstructors 
( 
Type 
, 
Config $
)$ %
.% &
Where& +
(+ ,
c, -
=>- /
c/ 0
.0 1
ParametersCount1 @
>A B
$numC D
)D E
.E F
OrderByDescendingF W
(W X
cX Y
=>Z \
c] ^
.^ _
ParametersCount_ n
)n o
.o p
ToArrayp w
(w x
)x y
;y z
public 

static 
IEnumerable 
< !
ConstructorParameters 3
>3 4
GetConstructors5 D
(D E
TypeE I
typeJ N
,N O

ProfileMapP Z

profileMap[ e
)e f
=>g i
type 
. #
GetDeclaredConstructors $
($ %
)% &
.& '
Where' ,
(, -

profileMap- 7
.7 8 
ShouldUseConstructor8 L
)L M
.M N
SelectN T
(T U
cU V
=>W Y
newZ ]!
ConstructorParameters^ s
(s t
ct u
)u v
)v w
;w x
public 


MemberInfo 
	GetMember 
(  
string  &
name' +
)+ ,
{ 
if 

( 
_nameToMember 
== 
null !
)! "
{ 	
SetNameToMember 
( 
) 
; 
} 	
if 

( 
_nameToMember 
. 
TryGetValue %
(% &
name& *
,* +
out, /
var0 3
member4 :
): ;
&&< >
Config? E
.E F 
MethodMappingEnabledF Z
&&[ ]
member^ d
ise g
GenericMethodh u
genericMethod	v É
)
É Ñ
{ 	
return 
genericMethod  
.  !
Close! &
(& '
)' (
;( )
} 	
return 
member 
; 
void 
SetNameToMember 
( 
) 
{ 	
_nameToMember   
=   
new   
(    
ReadAccessors    -
.  - .
Length  . 4
,  4 5
StringComparer  6 D
.  D E
OrdinalIgnoreCase  E V
)  V W
;  W X
IEnumerable!! 
<!! 

MemberInfo!! "
>!!" #
	accessors!!$ -
=!!. /
ReadAccessors!!0 =
;!!= >
if"" 
("" 
Config"" 
.""  
MethodMappingEnabled"" +
)""+ ,
{## 
	accessors$$ 
=$$ 

AddMethods$$ &
($$& '
	accessors$$' 0
)$$0 1
;$$1 2
}%% 
foreach&& 
(&& 
var&& 
member&& 
in&&  "
	accessors&&# ,
)&&, -
{'' 
_nameToMember(( 
.(( 
TryAdd(( $
((($ %
member((% +
.((+ ,
Name((, 0
,((0 1
member((2 8
)((8 9
;((9 :
if)) 
()) 
Config)) 
.)) 
	Postfixes)) $
.))$ %
Count))% *
==))+ -
$num)). /
&&))0 2
Config))3 9
.))9 :
Prefixes)): B
.))B C
Count))C H
==))I K
$num))L M
)))M N
{** 
continue++ 
;++ 
},, 
CheckPrePostfixes-- !
(--! "
member--" (
)--( )
;--) *
}.. 
}// 	
IEnumerable00 
<00 

MemberInfo00 
>00 

AddMethods00  *
(00* +
IEnumerable00+ 6
<006 7

MemberInfo007 A
>00A B
	accessors00C L
)00L M
{11 	
var22 
publicNoArgMethods22 "
=22# $!
GetPublicNoArgMethods22% :
(22: ;
)22; <
;22< =
var33 !
noArgExtensionMethods33 %
=33& '$
GetNoArgExtensionMethods33( @
(33@ A
Config33A G
.33G H"
SourceExtensionMethods33H ^
.33^ _
Where33_ d
(33d e
m33e f
=>33g i
!44 
_nameToMember44 
.44 
ContainsKey44 *
(44* +
m44+ ,
.44, -
Name44- 1
)441 2
&&443 5
Config446 <
.44< =
ShouldMapMethod44= L
(44L M
m44M N
)44N O
)44O P
)44P Q
;44Q R
return55 
	accessors55 
.55 
Concat55 #
(55# $
publicNoArgMethods55$ 6
)556 7
.557 8
Concat558 >
(55> ?!
noArgExtensionMethods55? T
)55T U
;55U V
}66 	
IEnumerable77 
<77 

MethodInfo77 
>77 !
GetPublicNoArgMethods77  5
(775 6
)776 7
=>778 :
Type77; ?
.77? @

GetMethods77@ J
(77J K
BindingFlags77K W
.77W X
Instance77X `
|77a b
BindingFlags77c o
.77o p
Public77p v
)77v w
.77w x
Where77x }
(77} ~
m77~ 
=>
77Ä Ç
m88 
.88 
DeclaringType88 
!=88 
typeof88 %
(88% &
object88& ,
)88, -
&&88. 0
m881 2
.882 3

ReturnType883 =
!=88> @
typeof88A G
(88G H
void88H L
)88L M
&&88N P
!88Q R
m88R S
.88S T%
IsGenericMethodDefinition88T m
&&88n p
!88q r
_nameToMember88r 
.	88 Ä
ContainsKey
88Ä ã
(
88ã å
m
88å ç
.
88ç é
Name
88é í
)
88í ì
&&
88î ñ
Config99 
.99 
ShouldMapMethod99 "
(99" #
m99# $
)99$ %
&&99& (
m99) *
.99* +
GetParameters99+ 8
(998 9
)999 :
.99: ;
Length99; A
==99B D
$num99E F
)99F G
;99G H
void:: 
CheckPrePostfixes:: 
(:: 

MemberInfo:: )
member::* 0
)::0 1
{;; 	
foreach<< 
(<< 
var<< 

memberName<< #
in<<$ &
PossibleNames<<' 4
(<<4 5
member<<5 ;
.<<; <
Name<<< @
,<<@ A
Config<<B H
.<<H I
Prefixes<<I Q
,<<Q R
Config<<S Y
.<<Y Z
	Postfixes<<Z c
)<<c d
)<<d e
{== 
_nameToMember>> 
.>> 
TryAdd>> $
(>>$ %

memberName>>% /
,>>/ 0
member>>1 7
)>>7 8
;>>8 9
}?? 
}@@ 	
IEnumerableAA 
<AA 

MemberInfoAA 
>AA $
GetNoArgExtensionMethodsAA  8
(AA8 9
IEnumerableAA9 D
<AAD E

MethodInfoAAE O
>AAO P'
sourceExtensionMethodSearchAAQ l
)AAl m
{BB 	
varCC 
extensionMethodsCC  
=CC! "
(CC# $
IEnumerableCC$ /
<CC/ 0

MemberInfoCC0 :
>CC: ;
)CC; <'
sourceExtensionMethodSearchDD +
.DD+ ,
WhereDD, 1
(DD1 2
methodDD2 8
=>DD9 ;
!DD< =
methodDD= C
.DDC D%
ContainsGenericParametersDDD ]
&&DD^ `
methodDDa g
.DDg h
FirstParameterTypeDDh z
(DDz {
)DD{ |
.DD| }
IsAssignableFrom	DD} ç
(
DDç é
Type
DDé í
)
DDí ì
)
DDì î
;
DDî ï
varEE 
genericInterfacesEE !
=EE" #
TypeEE$ (
.EE( )
GetInterfacesEE) 6
(EE6 7
)EE7 8
.EE8 9
WhereEE9 >
(EE> ?
tEE? @
=>EEA C
tEED E
.EEE F
IsGenericTypeEEF S
)EES T
;EET U
ifFF 
(FF 
TypeFF 
.FF 
IsInterfaceFF  
&&FF! #
TypeFF$ (
.FF( )
IsGenericTypeFF) 6
)FF6 7
{GG 
genericInterfacesHH !
=HH" #
genericInterfacesHH$ 5
.HH5 6
PrependHH6 =
(HH= >
TypeHH> B
)HHB C
;HHC D
}II 
ifJJ 
(JJ 
!JJ 
genericInterfacesJJ "
.JJ" #
AnyJJ# &
(JJ& '
)JJ' (
)JJ( )
{KK 
returnLL 
extensionMethodsLL '
;LL' (
}MM 
varNN 
definitionsNN 
=NN 
genericInterfacesNN /
.NN/ 0
GroupByNN0 7
(NN7 8
tNN8 9
=>NN: <
tNN= >
.NN> ?$
GetGenericTypeDefinitionNN? W
(NNW X
)NNX Y
)NNY Z
.NNZ [
ToDictionaryNN[ g
(NNg h
gNNh i
=>NNj l
gNNm n
.NNn o
KeyNNo r
,NNr s
gNNt u
=>NNv x
gNNy z
.NNz {
First	NN{ Ä
(
NNÄ Å
)
NNÅ Ç
)
NNÇ É
;
NNÉ Ñ
returnOO 
extensionMethodsOO #
.OO# $
ConcatOO$ *
(OO* +
fromPP 
methodPP 
inPP '
sourceExtensionMethodSearchPP :
letQQ 

targetTypeQQ 
=QQ  
methodQQ! '
.QQ' (
FirstParameterTypeQQ( :
(QQ: ;
)QQ; <
whereRR 

targetTypeRR  
.RR  !
IsInterfaceRR! ,
&&RR- /

targetTypeRR0 :
.RR: ;%
ContainsGenericParametersRR; T
letSS 
genericInterfaceSS $
=SS% &
definitionsSS' 2
.SS2 3
GetValueOrDefaultSS3 D
(SSD E

targetTypeSSE O
.SSO P$
GetGenericTypeDefinitionSSP h
(SSh i
)SSi j
)SSj k
whereTT 
genericInterfaceTT &
!=TT' )
nullTT* .
selectUU 
newUU 
GenericMethodUU (
(UU( )
methodUU) /
,UU/ 0
genericInterfaceUU1 A
)UUA B
)UUB C
;UUC D
}VV 	
}WW 
sealedXX 

classXX 
GenericMethodXX 
(XX 

MethodInfoXX )
genericMethodXX* 7
,XX7 8
TypeXX9 =
genericInterfaceXX> N
)XXN O
:XXP Q

MemberInfoXXR \
{YY 
readonlyZZ 

MethodInfoZZ 
_genericMethodZZ *
=ZZ+ ,
genericMethodZZ- :
;ZZ: ;
readonly[[ 
Type[[ 
_genericInterface[[ '
=[[( )
genericInterface[[* :
;[[: ;

MethodInfo\\ 
_closedMethod\\  
=\\! "
ObjectToString\\# 1
;\\1 2
public]] 

MethodInfo]] 
Close]] 
(]]  
)]]  !
{^^ 	
if__ 
(__ 
_closedMethod__ 
==__  
ObjectToString__! /
)__/ 0
{`` 
trydd 
{ee 
_closedMethodff !
=ff" #
_genericMethodff$ 2
.ff2 3
MakeGenericMethodff3 D
(ffD E
_genericInterfaceffE V
.ffV W 
GenericTypeArgumentsffW k
)ffk l
;ffl m
}gg 
catchhh 
(hh 
ArgumentExceptionhh (
)hh( )
{ii 
_closedMethodjj !
=jj" #
nulljj$ (
;jj( )
}kk 
}ll 
returnmm 
_closedMethodmm  
;mm  !
}nn 	
publicoo 
overrideoo 
Typeoo 
DeclaringTypeoo *
=>oo+ -
throwoo. 3
newoo4 7#
NotImplementedExceptionoo8 O
(ooO P
)ooP Q
;ooQ R
publicpp 
overridepp 
MemberTypespp #

MemberTypepp$ .
=>pp/ 1
throwpp2 7
newpp8 ;#
NotImplementedExceptionpp< S
(ppS T
)ppT U
;ppU V
publicqq 
overrideqq 
stringqq 
Nameqq #
=>qq$ &
_genericMethodqq' 5
.qq5 6
Nameqq6 :
;qq: ;
publicrr 
overriderr 
stringrr 
ToStringrr '
(rr' (
)rr( )
=>rr* ,
Namerr- 1
;rr1 2
publicss 
overridess 
Typess 
ReflectedTypess *
=>ss+ -
throwss. 3
newss4 7#
NotImplementedExceptionss8 O
(ssO P
)ssP Q
;ssQ R
publictt 
overridett 
objecttt 
[tt 
]tt  
GetCustomAttributestt! 4
(tt4 5
booltt5 9
inherittt: A
)ttA B
=>ttC E
throwttF K
newttL O#
NotImplementedExceptionttP g
(ttg h
)tth i
;tti j
publicuu 
overrideuu 
objectuu 
[uu 
]uu  
GetCustomAttributesuu! 4
(uu4 5
Typeuu5 9
attributeTypeuu: G
,uuG H
booluuI M
inherituuN U
)uuU V
=>uuW Y
throwuuZ _
newuu` c#
NotImplementedExceptionuud {
(uu{ |
)uu| }
;uu} ~
publicvv 
overridevv 
boolvv 
	IsDefinedvv &
(vv& '
Typevv' +
attributeTypevv, 9
,vv9 :
boolvv; ?
inheritvv@ G
)vvG H
=>vvI K
throwvvL Q
newvvR U#
NotImplementedExceptionvvV m
(vvm n
)vvn o
;vvo p
}ww 
publicxx 

staticxx 
stringxx 
[xx 
]xx 
PossibleNamesxx (
(xx( )
stringxx) /

memberNamexx0 :
,xx: ;
Listxx< @
<xx@ A
stringxxA G
>xxG H
prefixesxxI Q
,xxQ R
ListxxS W
<xxW X
stringxxX ^
>xx^ _
	postfixesxx` i
)xxi j
{yy 
Listzz 
<zz 
stringzz 
>zz 
resultzz 
=zz 
nullzz "
;zz" #
foreach{{ 
({{ 
var{{ 
prefix{{ 
in{{ 
prefixes{{ '
){{' (
{|| 	
if}} 
(}} 
!}} 

memberName}} 
.}} 

StartsWith}} &
(}}& '
prefix}}' -
,}}- .
StringComparison}}/ ?
.}}? @
OrdinalIgnoreCase}}@ Q
)}}Q R
)}}R S
{~~ 
continue 
; 
}
ÄÄ 
var
ÅÅ 
withoutPrefix
ÅÅ 
=
ÅÅ 

memberName
ÅÅ  *
[
ÅÅ* +
prefix
ÅÅ+ 1
.
ÅÅ1 2
Length
ÅÅ2 8
..
ÅÅ8 :
]
ÅÅ: ;
;
ÅÅ; <
result
ÇÇ 
??=
ÇÇ 
[
ÇÇ 
]
ÇÇ 
;
ÇÇ 
result
ÉÉ 
.
ÉÉ 
Add
ÉÉ 
(
ÉÉ 
withoutPrefix
ÉÉ $
)
ÉÉ$ %
;
ÉÉ% &
	PostFixes
ÑÑ 
(
ÑÑ 
ref
ÑÑ 
result
ÑÑ  
,
ÑÑ  !
	postfixes
ÑÑ" +
,
ÑÑ+ ,
withoutPrefix
ÑÑ- :
)
ÑÑ: ;
;
ÑÑ; <
}
ÖÖ 	
	PostFixes
ÜÜ 
(
ÜÜ 
ref
ÜÜ 
result
ÜÜ 
,
ÜÜ 
	postfixes
ÜÜ '
,
ÜÜ' (

memberName
ÜÜ) 3
)
ÜÜ3 4
;
ÜÜ4 5
return
áá 
result
áá 
==
áá 
null
áá 
?
áá 
[
áá  !
]
áá! "
:
áá# $
[
áá% &
..
áá& (
result
áá( .
]
áá. /
;
áá/ 0
static
àà 
void
àà 
	PostFixes
àà 
(
àà 
ref
àà !
List
àà" &
<
àà& '
string
àà' -
>
àà- .
result
àà/ 5
,
àà5 6
List
àà7 ;
<
àà; <
string
àà< B
>
ààB C
	postfixes
ààD M
,
ààM N
string
ààO U
name
ààV Z
)
ààZ [
{
ââ 	
foreach
ää 
(
ää 
var
ää 
postfix
ää  
in
ää! #
	postfixes
ää$ -
)
ää- .
{
ãã 
if
åå 
(
åå 
!
åå 
name
åå 
.
åå 
EndsWith
åå "
(
åå" #
postfix
åå# *
,
åå* +
StringComparison
åå, <
.
åå< =
OrdinalIgnoreCase
åå= N
)
ååN O
)
ååO P
{
çç 
continue
éé 
;
éé 
}
èè 
result
êê 
??=
êê 
[
êê 
]
êê 
;
êê 
result
ëë 
.
ëë 
Add
ëë 
(
ëë 
name
ëë 
[
ëë  
..
ëë  "
^
ëë" #
postfix
ëë# *
.
ëë* +
Length
ëë+ 1
]
ëë1 2
)
ëë2 3
;
ëë3 4
}
íí 
}
ìì 	
}
îî 
public
ïï 


MemberInfo
ïï 
[
ïï 
]
ïï 
ReadAccessors
ïï %
=>
ïï& (
_readAccessors
ïï) 7
??=
ïï8 ; 
BuildReadAccessors
ïï< N
(
ïïN O
)
ïïO P
;
ïïP Q
public
ññ 


MemberInfo
ññ 
[
ññ 
]
ññ 
WriteAccessors
ññ &
=>
ññ' )
_writeAccessors
ññ* 9
??=
ññ: =!
BuildWriteAccessors
ññ> Q
(
ññQ R
)
ññR S
;
ññS T
public
óó 
#
ConstructorParameters
óó  
[
óó  !
]
óó! "
Constructors
óó# /
=>
óó0 2
_constructors
óó3 @
??=
óóA D
GetConstructors
óóE T
(
óóT U
)
óóU V
;
óóV W
private
òò 

MemberInfo
òò 
[
òò 
]
òò  
BuildReadAccessors
òò +
(
òò+ ,
)
òò, -
{
ôô 
IEnumerable
õõ 
<
õõ 

MemberInfo
õõ 
>
õõ 
members
õõ  '
=
õõ( )
GetProperties
õõ* 7
(
õõ7 8
PropertyReadable
õõ8 H
)
õõH I
.
úú 
GroupBy
úú 
(
úú 
x
úú 
=>
úú 
x
úú 
.
úú 
Name
úú  
)
úú  !
.
ùù 
Select
ùù 
(
ùù 
x
ùù 
=>
ùù 
x
ùù 
.
ùù 
First
ùù  
(
ùù  !
)
ùù! "
)
ùù" #
;
ùù# $
if
ûû 

(
ûû 
Config
ûû 
.
ûû !
FieldMappingEnabled
ûû &
)
ûû& '
{
üü 	
members
†† 
=
†† 
members
†† 
.
†† 
Concat
†† $
(
††$ %
	GetFields
††% .
(
††. /
FieldReadable
††/ <
)
††< =
)
††= >
;
††> ?
}
°° 	
return
¢¢ 
[
¢¢ 
..
¢¢ 
members
¢¢ 
]
¢¢ 
;
¢¢ 
}
££ 
private
§§ 

MemberInfo
§§ 
[
§§ 
]
§§ !
BuildWriteAccessors
§§ ,
(
§§, -
)
§§- .
{
•• 
IEnumerable
ßß 
<
ßß 

MemberInfo
ßß 
>
ßß 
members
ßß  '
=
ßß( )
GetProperties
ßß* 7
(
ßß7 8
PropertyWritable
ßß8 H
)
ßßH I
.
®® 
GroupBy
®® 
(
®® 
x
®® 
=>
®® 
x
®® 
.
®® 
Name
®®  
)
®®  !
.
©© 
Select
©© 
(
©© 
x
©© 
=>
©© 
x
©© 
.
©© 
FirstOrDefault
©© )
(
©©) *
y
©©* +
=>
©©, .
y
©©/ 0
.
©©0 1
CanWrite
©©1 9
&&
©©: <
y
©©= >
.
©©> ?
CanRead
©©? F
)
©©F G
??
©©H J
x
©©K L
.
©©L M
First
©©M R
(
©©R S
)
©©S T
)
©©T U
;
©©U V
if
™™ 

(
™™ 
Config
™™ 
.
™™ !
FieldMappingEnabled
™™ &
)
™™& '
{
´´ 	
members
¨¨ 
=
¨¨ 
members
¨¨ 
.
¨¨ 
Concat
¨¨ $
(
¨¨$ %
	GetFields
¨¨% .
(
¨¨. /
FieldWritable
¨¨/ <
)
¨¨< =
)
¨¨= >
;
¨¨> ?
}
≠≠ 	
return
ÆÆ 
[
ÆÆ 
..
ÆÆ 
members
ÆÆ 
]
ÆÆ 
;
ÆÆ 
}
ØØ 
private
∞∞ 
static
∞∞ 
bool
∞∞ 
PropertyReadable
∞∞ (
(
∞∞( )
PropertyInfo
∞∞) 5
propertyInfo
∞∞6 B
)
∞∞B C
=>
∞∞D F
propertyInfo
∞∞G S
.
∞∞S T
CanRead
∞∞T [
;
∞∞[ \
private
±± 
static
±± 
bool
±± 
FieldReadable
±± %
(
±±% &
	FieldInfo
±±& /
	fieldInfo
±±0 9
)
±±9 :
=>
±±; =
true
±±> B
;
±±B C
private
≤≤ 
static
≤≤ 
bool
≤≤ 
PropertyWritable
≤≤ (
(
≤≤( )
PropertyInfo
≤≤) 5
propertyInfo
≤≤6 B
)
≤≤B C
=>
≤≤D F
propertyInfo
≤≤G S
.
≤≤S T
CanWrite
≤≤T \
||
≤≤] _
propertyInfo
≤≤` l
.
≤≤l m
PropertyType
≤≤m y
.
≤≤y z
IsCollection≤≤z Ü
(≤≤Ü á
)≤≤á à
;≤≤à â
private
≥≥ 
static
≥≥ 
bool
≥≥ 
FieldWritable
≥≥ %
(
≥≥% &
	FieldInfo
≥≥& /
	fieldInfo
≥≥0 9
)
≥≥9 :
=>
≥≥; =
!
≥≥> ?
	fieldInfo
≥≥? H
.
≥≥H I

IsInitOnly
≥≥I S
;
≥≥S T
private
¥¥ 
IEnumerable
¥¥ 
<
¥¥ 
Type
¥¥ 
>
¥¥  
GetTypeInheritance
¥¥ 0
(
¥¥0 1
)
¥¥1 2
=>
¥¥3 5
Type
¥¥6 :
.
¥¥: ;
IsInterface
¥¥; F
?
¥¥G H
Type
¥¥I M
.
¥¥M N
GetInterfaces
¥¥N [
(
¥¥[ \
)
¥¥\ ]
.
¥¥] ^
Prepend
¥¥^ e
(
¥¥e f
Type
¥¥f j
)
¥¥j k
:
¥¥l m
Type
¥¥n r
.
¥¥r s!
GetTypeInheritance¥¥s Ö
(¥¥Ö Ü
)¥¥Ü á
;¥¥á à
private
µµ 
IEnumerable
µµ 
<
µµ 
PropertyInfo
µµ $
>
µµ$ %
GetProperties
µµ& 3
(
µµ3 4
Func
µµ4 8
<
µµ8 9
PropertyInfo
µµ9 E
,
µµE F
bool
µµG K
>
µµK L"
propertyAvailableFor
µµM a
)
µµa b
=>
µµc e 
GetTypeInheritance
∂∂ 
(
∂∂ 
)
∂∂ 
.
∂∂ 

SelectMany
∂∂ '
(
∂∂' (
type
∂∂( ,
=>
∂∂- /
type
∂∂0 4
.
∂∂4 5
GetProperties
∂∂5 B
(
∂∂B C
TypeExtensions
∂∂C Q
.
∂∂Q R
InstanceFlags
∂∂R _
)
∂∂_ `
.
∂∂` a
Where
∂∂a f
(
∂∂f g
property
∂∂g o
=>
∂∂p r#
propertyAvailableFor∂∂s á
(∂∂á à
property∂∂à ê
)∂∂ê ë
&&∂∂í î
Config∂∂ï õ
.∂∂õ ú!
ShouldMapProperty∂∂ú ≠
(∂∂≠ Æ
property∂∂Æ ∂
)∂∂∂ ∑
)∂∂∑ ∏
)∂∂∏ π
;∂∂π ∫
private
∑∑ 
IEnumerable
∑∑ 
<
∑∑ 

MemberInfo
∑∑ "
>
∑∑" #
	GetFields
∑∑$ -
(
∑∑- .
Func
∑∑. 2
<
∑∑2 3
	FieldInfo
∑∑3 <
,
∑∑< =
bool
∑∑> B
>
∑∑B C
fieldAvailableFor
∑∑D U
)
∑∑U V
=>
∑∑W Y 
GetTypeInheritance
∏∏ 
(
∏∏ 
)
∏∏ 
.
∏∏ 

SelectMany
∏∏ '
(
∏∏' (
type
∏∏( ,
=>
∏∏- /
type
∏∏0 4
.
∏∏4 5
	GetFields
∏∏5 >
(
∏∏> ?
TypeExtensions
∏∏? M
.
∏∏M N
InstanceFlags
∏∏N [
)
∏∏[ \
.
∏∏\ ]
Where
∏∏] b
(
∏∏b c
field
∏∏c h
=>
∏∏i k
fieldAvailableFor
∏∏l }
(
∏∏} ~
field∏∏~ É
)∏∏É Ñ
&&∏∏Ö á
Config∏∏à é
.∏∏é è
ShouldMapField∏∏è ù
(∏∏ù û
field∏∏û £
)∏∏£ §
)∏∏§ •
)∏∏• ¶
;∏∏¶ ß
}ππ 
public∫∫ 
readonly
∫∫ 
record
∫∫ 
struct
∫∫ #
ConstructorParameters
∫∫ 3
(
∫∫3 4
ConstructorInfo
∫∫4 C
Constructor
∫∫D O
,
∫∫O P
ParameterInfo
∫∫Q ^
[
∫∫^ _
]
∫∫_ `

Parameters
∫∫a k
)
∫∫k l
{ªª 
public
ºº 
#
ConstructorParameters
ºº  
(
ºº  !
ConstructorInfo
ºº! 0
constructor
ºº1 <
)
ºº< =
:
ºº> ?
this
ºº@ D
(
ººD E
constructor
ººE P
,
ººP Q
constructor
ººR ]
.
ºº] ^
GetParameters
ºº^ k
(
ººk l
)
ººl m
)
ººm n
{
ººn o
}
ººo p
public
ΩΩ 

int
ΩΩ 
ParametersCount
ΩΩ 
=>
ΩΩ !

Parameters
ΩΩ" ,
.
ΩΩ, -
Length
ΩΩ- 3
;
ΩΩ3 4
public
ææ 

bool
ææ #
AllParametersOptional
ææ %
(
ææ% &
)
ææ& '
=>
ææ( *

Parameters
ææ+ 5
.
ææ5 6
All
ææ6 9
(
ææ9 :
p
ææ: ;
=>
ææ< >
p
ææ? @
.
ææ@ A

IsOptional
ææA K
)
ææK L
;
ææL M
}øø ‚~
UC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\ReflectionHelper.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
static 
class 
ReflectionHelper $
{ 
public 

static 
Type 
FirstParameterType )
() *
this* .

MethodBase/ 9
method: @
)@ A
=>B D
methodE K
.K L
GetParametersL Y
(Y Z
)Z [
[[ \
$num\ ]
]] ^
.^ _
ParameterType_ l
;l m
public 

static 
Type 
GetElementType %
(% &
Type& *
type+ /
)/ 0
=>1 3
type4 8
.8 9
IsArray9 @
?A B
typeC G
.G H
GetElementTypeH V
(V W
)W X
:Y Z$
GetEnumerableElementType[ s
(s t
typet x
)x y
;y z
public 

static 
Type $
GetEnumerableElementType /
(/ 0
Type0 4
type5 9
)9 :
=>; =
type> B
.B C
GetIEnumerableTypeC U
(U V
)V W
?W X
.X Y 
GenericTypeArgumentsY m
[m n
$numn o
]o p
??q s
typeoft z
(z {
object	{ Å
)
Å Ç
;
Ç É
public 

static 
TypeMap 
[ 
] 
GetIncludedTypeMaps /
(/ 0
this0 4 
IGlobalConfiguration5 I
configurationJ W
,W X
TypeMapY `
typeMapa h
)h i
=>j l
configuration		 
.		 
GetIncludedTypeMaps		 )
(		) *
typeMap		* 1
.		1 2 
IncludedDerivedTypes		2 F
)		F G
;		G H
public

 

static

 
bool

 
IsPublic

 
(

  
this

  $
PropertyInfo

% 1
propertyInfo

2 >
)

> ?
=>

@ B
(

C D
propertyInfo

D P
.

P Q
GetGetMethod

Q ]
(

] ^
)

^ _
??

` b
propertyInfo

c o
.

o p
GetSetMethod

p |
(

| }
)

} ~
)

~ 
!=


Ä Ç
null


É á
;


á à
public 

static 
bool 
Has 
< 

TAttribute %
>% &
(& '
this' +

MemberInfo, 6
member7 =
)= >
where? D

TAttributeE O
:P Q
	AttributeR [
=>\ ^
member_ e
.e f
	IsDefinedf o
(o p
typeofp v
(v w

TAttribute	w Å
)
Å Ç
)
Ç É
;
É Ñ
public 

static 
bool 
CanBeSet 
(  
this  $

MemberInfo% /
member0 6
)6 7
=>8 :
member; A
isB D
PropertyInfoE Q
propertyR Z
?[ \
property] e
.e f
CanWritef n
:o p
!q r
(r s
(s t
	FieldInfot }
)} ~
member	~ Ñ
)
Ñ Ö
.
Ö Ü

IsInitOnly
Ü ê
;
ê ë
public 

static 

Expression 
GetDefaultValue ,
(, -
this- 1
ParameterInfo2 ?
	parameter@ I
,I J 
IGlobalConfigurationK _
configuration` m
)m n
=>o q
	parameter 
is 
{ 
DefaultValue #
:# $
null% )
,) *
ParameterType+ 8
:8 9
{: ;
IsValueType< G
:G H
trueI M
}N O
typeP T
}U V
?W X
configurationY f
.f g
Defaultg n
(n o
typeo s
)s t
:u v
ToTypew }
(} ~
Constant	~ Ü
(
Ü á
	parameter
á ê
.
ê ë
DefaultValue
ë ù
)
ù û
,
û ü
	parameter
† ©
.
© ™
ParameterType
™ ∑
)
∑ ∏
;
∏ π
public 

static 
object 
	MapMember "
(" #
this# '
ResolutionContext( 9
context: A
,A B

MemberInfoC M
memberN T
,T U
objectV \
source] c
,c d
objecte k
destinationl w
=x y
nullz ~
)~ 
{ 
var 

memberType 
= 
GetMemberType &
(& '
member' -
)- .
;. /
var 
	destValue 
= 
destination #
==$ &
null' +
?, -
null. 2
:3 4
GetMemberValue5 C
(C D
memberD J
,J K
destinationL W
)W X
;X Y
return 
context 
. 
Map 
( 
source !
,! "
	destValue# ,
,, -
null. 2
,2 3

memberType4 >
,> ?
	MemberMap@ I
.I J
InstanceJ R
)R S
;S T
} 
public 

static 
void 
SetMemberValue %
(% &
this& *

MemberInfo+ 5
propertyOrField6 E
,E F
objectG M
targetN T
,T U
objectV \
value] b
)b c
{ 
if 

( 
propertyOrField 
is 
PropertyInfo +
property, 4
)4 5
{ 	
if 
( 
property 
. 
CanWrite !
)! "
{ 
property 
. 
SetValue !
(! "
target" (
,( )
value* /
,/ 0
null1 5
)5 6
;6 7
} 
return 
; 
} 	
if 

( 
propertyOrField 
is 
	FieldInfo (
field) .
). /
{   	
if!! 
(!! 
!!! 
field!! 
.!! 

IsInitOnly!! !
)!!! "
{"" 
field## 
.## 
SetValue## 
(## 
target## %
,##% &
value##' ,
)##, -
;##- .
}$$ 
return%% 
;%% 
}&& 	
throw'' 
Expected'' 
('' 
propertyOrField'' &
)''& '
;''' (
}(( 
private)) 
static)) '
ArgumentOutOfRangeException)) .
Expected))/ 7
())7 8

MemberInfo))8 B
propertyOrField))C R
)))R S
=>))T V
new))W Z
())Z [
nameof))[ a
())a b
propertyOrField))b q
)))q r
,))r s
$str	))t ò
+
))ô ö
propertyOrField
))õ ™
)
))™ ´
;
))´ ¨
public** 

static** 
object** 
GetMemberValue** '
(**' (
this**( ,

MemberInfo**- 7
propertyOrField**8 G
,**G H
object**I O
target**P V
)**V W
=>**X Z
propertyOrField**[ j
switch**k q
{++ 
PropertyInfo,, 
property,, 
=>,,  
property,,! )
.,,) *
GetValue,,* 2
(,,2 3
target,,3 9
,,,9 :
null,,; ?
),,? @
,,,@ A
	FieldInfo-- 
field-- 
=>-- 
field--  
.--  !
GetValue--! )
(--) *
target--* 0
)--0 1
,--1 2
_.. 	
=>..
 
throw.. 
Expected.. 
(.. 
propertyOrField.. +
)..+ ,
}// 
;// 
public00 

static00 

MemberInfo00 
[00 
]00 
GetMemberPath00 ,
(00, -
Type00- 1
type002 6
,006 7
string008 >
fullMemberName00? M
,00M N
TypeMap00O V
typeMap00W ^
=00_ `
null00a e
)00e f
=>00g i
GetMemberPath11 
(11 
type11 
,11 
fullMemberName11 *
.11* +
Split11+ 0
(110 1
$char111 4
)114 5
,115 6
typeMap117 >
)11> ?
;11? @
public22 

static22 

MemberInfo22 
[22 
]22 
GetMemberPath22 ,
(22, -
Type22- 1
type222 6
,226 7
string228 >
[22> ?
]22? @
memberNames22A L
,22L M
TypeMap22N U
typeMap22V ]
=22^ _
null22` d
)22d e
{33 
var44 
sourceDetails44 
=44 
typeMap44 #
?44# $
.44$ %
SourceTypeDetails44% 6
;446 7
if55 

(55 
sourceDetails55 
!=55 
null55 !
&&55" $
memberNames55% 0
.550 1
Length551 7
==558 :
$num55; <
)55< =
{66 	
return77 
[77 
sourceDetails77 !
.77! "
	GetMember77" +
(77+ ,
memberNames77, 7
[777 8
$num778 9
]779 :
)77: ;
]77; <
;77< =
}88 	
var99 
members99 
=99 
new99 

MemberInfo99 $
[99$ %
memberNames99% 0
.990 1
Length991 7
]997 8
;998 9
Type:: 
previousType:: 
=:: 
type::  
;::  !
for;; 
(;; 
int;; 
index;; 
=;; 
$num;; 
;;; 
index;;  
<;;! "
memberNames;;# .
.;;. /
Length;;/ 5
;;;5 6
index;;7 <
++;;< >
);;> ?
{<< 	
var== 
currentType== 
=== 
GetCurrentType== ,
(==, -
previousType==- 9
)==9 :
;==: ;
var>> 

memberName>> 
=>> 
memberNames>> (
[>>( )
index>>) .
]>>. /
;>>/ 0
var?? 
property?? 
=?? 
currentType?? &
.??& ' 
GetInheritedProperty??' ;
(??; <

memberName??< F
)??F G
;??G H
if@@ 
(@@ 
property@@ 
!=@@ 
null@@  
)@@  !
{AA 
previousTypeBB 
=BB 
propertyBB '
.BB' (
PropertyTypeBB( 4
;BB4 5
membersCC 
[CC 
indexCC 
]CC 
=CC  
propertyCC! )
;CC) *
}DD 
elseEE 
ifEE 
(EE 
currentTypeEE  
.EE  !
GetInheritedFieldEE! 2
(EE2 3

memberNameEE3 =
)EE= >
isEE? A
	FieldInfoEEB K
fieldEEL Q
)EEQ R
{FF 
previousTypeGG 
=GG 
fieldGG $
.GG$ %
	FieldTypeGG% .
;GG. /
membersHH 
[HH 
indexHH 
]HH 
=HH  
fieldHH! &
;HH& '
}II 
elseJJ 
{KK 
varLL 
methodLL 
=LL 
currentTypeLL (
.LL( )
GetInheritedMethodLL) ;
(LL; <

memberNameLL< F
)LLF G
;LLG H
previousTypeMM 
=MM 
methodMM %
.MM% &

ReturnTypeMM& 0
;MM0 1
membersNN 
[NN 
indexNN 
]NN 
=NN  
methodNN! '
;NN' (
}OO 
}PP 	
returnQQ 
membersQQ 
;QQ 
staticRR 
TypeRR 
GetCurrentTypeRR "
(RR" #
TypeRR# '
typeRR( ,
)RR, -
=>RR. 0
typeRR1 5
.RR5 6
IsGenericTypeRR6 C
&&RRD F
typeRRG K
.RRK L
IsCollectionRRL X
(RRX Y
)RRY Z
?RR[ \
typeRR] a
.RRa b 
GenericTypeArgumentsRRb v
[RRv w
$numRRw x
]RRx y
:RRz {
type	RR| Ä
;
RRÄ Å
}SS 
publicTT 

staticTT 

MemberInfoTT 
FindPropertyTT )
(TT) *
LambdaExpressionTT* :
lambdaExpressionTT; K
)TTK L
{UU 

ExpressionVV 
expressionToCheckVV $
=VV% &
lambdaExpressionVV' 7
.VV7 8
BodyVV8 <
;VV< =
whileWW 
(WW 
trueWW 
)WW 
{XX 	
switchYY 
(YY 
expressionToCheckYY %
)YY% &
{ZZ 
case[[ 
MemberExpression[[ %
{[[& '
Member[[( .
:[[. /
var[[0 3
member[[4 :
,[[: ;

Expression[[< F
.[[F G
NodeType[[G O
:[[O P
ExpressionType[[Q _
.[[_ `
	Parameter[[` i
or[[j l
ExpressionType[[m {
.[[{ |
Convert	[[| É
}
[[Ñ Ö
:
[[Ö Ü
return\\ 
member\\ !
;\\! "
case]] 
UnaryExpression]] $
{]]% &
Operand]]' .
:]]. /
var]]0 3
operand]]4 ;
}]]< =
:]]= >
expressionToCheck^^ %
=^^& '
operand^^( /
;^^/ 0
break__ 
;__ 
default`` 
:`` 
throwaa 
newaa 
ArgumentExceptionaa /
(aa/ 0
$"bb 
$strbb &
{bb& '
lambdaExpressionbb' 7
}bb7 8
$str	bb8 ⁄
"
bb⁄ €
,
bb€ ‹
nameofcc 
(cc 
lambdaExpressioncc /
)cc/ 0
)cc0 1
;cc1 2
}dd 
}ee 	
}ff 
publicgg 

staticgg 
Typegg 
GetMemberTypegg $
(gg$ %
thisgg% )

MemberInfogg* 4
membergg5 ;
)gg; <
=>gg= ?
membergg@ F
switchggG M
{hh 
PropertyInfoii 
propertyii 
=>ii  
propertyii! )
.ii) *
PropertyTypeii* 6
,ii6 7

MethodInfojj 
methodjj 
=>jj 
methodjj #
.jj# $

ReturnTypejj$ .
,jj. /
	FieldInfokk 
fieldkk 
=>kk 
fieldkk  
.kk  !
	FieldTypekk! *
,kk* +
nullll 
=>ll 
throwll 
newll !
ArgumentNullExceptionll /
(ll/ 0
nameofll0 6
(ll6 7
memberll7 =
)ll= >
)ll> ?
,ll? @
_mm 	
=>mm
 
throwmm 
newmm '
ArgumentOutOfRangeExceptionmm 2
(mm2 3
nameofmm3 9
(mm9 :
membermm: @
)mm@ A
)mmA B
}nn 
;nn 
}oo ú7
TC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\PrimitiveHelper.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
static 
class 
PrimitiveHelper #
{ 
public 

static 
bool 
TryAdd 
< 
T 
>  
(  !
this! %
List& *
<* +
T+ ,
>, -
list. 2
,2 3
T4 5
value6 ;
); <
{		 
if

 

(

 
!

 
list

 
.

 
Contains

 
(

 
value

  
)

  !
)

! "
{ 	
list 
. 
Add 
( 
value 
) 
; 
return 
true 
; 
} 	
return 
false 
; 
} 
public 

static 
List 
< 
T 
> 
TryAdd  
<  !
T! "
>" #
(# $
this$ (
List) -
<- .
T. /
>/ 0
list1 5
,5 6
IEnumerable7 B
<B C
TC D
>D E
valuesF L
)L M
{ 
foreach 
( 
var 
value 
in 
values $
)$ %
{ 	
list 
. 
TryAdd 
( 
value 
) 
; 
} 	
return 
list 
; 
} 
public 

static 
ReadOnlyCollection $
<$ %
T% &
>& '

ToReadOnly( 2
<2 3
T3 4
>4 5
(5 6
this6 :
T; <
item= A
)A B
whereC H
TI J
:K L

ExpressionM W
=>X Z
new[ ^%
ReadOnlyCollectionBuilder_ x
<x y
Ty z
>z {
{{ |
item	} Å
}
Ç É
.
É Ñ"
ToReadOnlyCollection
Ñ ò
(
ò ô
)
ô ö
;
ö õ
public 

static 
IReadOnlyCollection %
<% &
T& '
>' (
	NullCheck) 2
<2 3
T3 4
>4 5
(5 6
this6 :
IReadOnlyCollection; N
<N O
TO P
>P Q
sourceR X
)X Y
=>Z \
source] c
??d f
[g h
]h i
;i j
public 

static 
IEnumerable 
< 
T 
>  
Concat! '
<' (
T( )
>) *
(* +
this+ /
IReadOnlyCollection0 C
<C D
TD E
>E F

collectionG Q
,Q R
IReadOnlyCollectionS f
<f g
Tg h
>h i
otherCollectionj y
)y z
{ 
if 

( 
otherCollection 
== 
null #
||$ &
otherCollection' 6
.6 7
Count7 <
=== ?
$num@ A
)A B
{ 	
return 

collection 
; 
}   	
if!! 

(!! 

collection!! 
.!! 
Count!! 
==!! 
$num!!  !
)!!! "
{"" 	
return## 
otherCollection## "
;##" #
}$$ 	
return%% 

Enumerable%% 
.%% 
Concat%%  
(%%  !

collection%%! +
,%%+ ,
otherCollection%%- <
)%%< =
;%%= >
}&& 
public'' 

static'' 
void'' 
CheckIsDerivedFrom'' )
('') *
this''* .
TypePair''/ 7
types''8 =
,''= >
TypePair''? G
	baseTypes''H Q
)''Q R
{(( 
types)) 
.)) 

SourceType)) 
.)) 
CheckIsDerivedFrom)) +
())+ ,
	baseTypes)), 5
.))5 6

SourceType))6 @
)))@ A
;))A B
types** 
.** 
DestinationType** 
.** 
CheckIsDerivedFrom** 0
(**0 1
	baseTypes**1 :
.**: ;
DestinationType**; J
)**J K
;**K L
}++ 
public,, 

static,, 
bool,, 
IsCollection,, #
(,,# $
this,,$ (
TypePair,,) 1
context,,2 9
),,9 :
=>,,; =
context,,> E
.,,E F

SourceType,,F P
.,,P Q
IsCollection,,Q ]
(,,] ^
),,^ _
&&,,` b
context,,c j
.,,j k
DestinationType,,k z
.,,z {
IsCollection	,,{ á
(
,,á à
)
,,à â
;
,,â ä
public-- 

static-- 
bool-- 
IsEnumToEnum-- #
(--# $
this--$ (
TypePair--) 1
context--2 9
)--9 :
=>--; =
context--> E
.--E F

SourceType--F P
.--P Q
IsEnum--Q W
&&--X Z
context--[ b
.--b c
DestinationType--c r
.--r s
IsEnum--s y
;--y z
public.. 

static.. 
bool.. "
IsUnderlyingTypeToEnum.. -
(..- .
this... 2
TypePair..3 ;
context..< C
)..C D
=>..E G
context// 
.// 
DestinationType// 
.//  
IsEnum//  &
&&//' )
context//* 1
.//1 2

SourceType//2 <
.//< =
IsAssignableFrom//= M
(//M N
Enum//N R
.//R S
GetUnderlyingType//S d
(//d e
context//e l
.//l m
DestinationType//m |
)//| }
)//} ~
;//~ 
public00 

static00 
bool00 "
IsEnumToUnderlyingType00 -
(00- .
this00. 2
TypePair003 ;
context00< C
)00C D
=>00E G
context11 
.11 

SourceType11 
.11 
IsEnum11 !
&&11" $
context11% ,
.11, -
DestinationType11- <
.11< =
IsAssignableFrom11= M
(11M N
Enum11N R
.11R S
GetUnderlyingType11S d
(11d e
context11e l
.11l m

SourceType11m w
)11w x
)11x y
;11y z
}22 ∫#
OC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\MemberPath.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
readonly 
record 
struct 

MemberPath (
(( )

MemberInfo) 3
[3 4
]4 5
Members6 =
)= >
{ 
public 

static 
readonly 

MemberPath %
Empty& +
=, -
new. 1
(1 2
Members2 9
:9 :
[; <
]< =
)= >
;> ?
public 


MemberPath 
( 
Stack 
< 
Member "
>" #
members$ +
)+ ,
:- .
this/ 3
(3 4
members4 ;
.; <
ToMemberInfos< I
(I J
)J K
)K L
{L M
}M N
public 


MemberInfo 
Last 
=> 
Members %
[% &
^& '
$num' (
]( )
;) *
public 


MemberInfo 
First 
=> 
Members &
[& '
$num' (
]( )
;) *
public		 

int		 
Length		 
=>		 
Members		  
.		  !
Length		! '
;		' (
public

 

bool

 
Equals

 
(

 

MemberPath

 !
other

" '
)

' (
=>

) +
Members

, 3
.

3 4
SequenceEqual

4 A
(

A B
other

B G
.

G H
Members

H O
)

O P
;

P Q
public 

override 
int 
GetHashCode #
(# $
)$ %
{ 
HashCode 
hashCode 
= 
new 
(  
)  !
;! "
foreach 
( 
var 
member 
in 
Members %
)% &
{ 	
hashCode 
. 
Add 
( 
member 
)  
;  !
} 	
return 
hashCode 
. 

ToHashCode "
(" #
)# $
;$ %
} 
public 

override 
string 
ToString #
(# $
)$ %
=>& (
string) /
./ 0
Join0 4
(4 5
$str5 8
,8 9
Members: A
.A B
SelectB H
(H I
miI K
=>L N
miO Q
.Q R
NameR V
)V W
)W X
;X Y
public 

bool 

StartsWith 
( 

MemberPath %
path& *
)* +
{ 
if 

( 
path 
. 
Length 
> 
Length  
)  !
{ 	
return 
false 
; 
} 	
for 
( 
int 
index 
= 
$num 
; 
index !
<" #
path$ (
.( )
Length) /
;/ 0
index1 6
++6 8
)8 9
{ 	
if 
( 
Members 
[ 
index 
] 
!= !
path" &
.& '
Members' .
[. /
index/ 4
]4 5
)5 6
{ 
return 
false 
; 
}   
}!! 	
return"" 
true"" 
;"" 
}## 
public$$ 


MemberPath$$ 
Concat$$ 
($$ 
IEnumerable$$ (
<$$( )

MemberInfo$$) 3
>$$3 4
memberInfos$$5 @
)$$@ A
=>$$B D
new$$E H
($$H I
[$$I J
..$$J L
Members$$L S
.$$S T
Concat$$T Z
($$Z [
memberInfos$$[ f
)$$f g
]$$g h
)$$h i
;$$i j
}%% Ê
`C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\LockingConcurrentDictionary.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
public 
readonly 
struct '
LockingConcurrentDictionary 2
<2 3
TKey3 7
,7 8
TValue9 ?
>? @
(@ A
FuncA E
<E F
TKeyF J
,J K
TValueL R
>R S
valueFactoryT `
,` a
intb e
capacityf n
=o p
$numq s
)s t
{ 
private 
readonly 
Func 
< 
TKey 
, 
Lazy  $
<$ %
TValue% +
>+ ,
>, -
_valueFactory. ;
=< =
key> A
=>B D
newE H
(H I
(I J
)J K
=>L N
valueFactoryO [
([ \
key\ _
)_ `
)` a
;a b
private 
readonly  
ConcurrentDictionary )
<) *
TKey* .
,. /
Lazy0 4
<4 5
TValue5 ;
>; <
>< =
_dictionary> I
=J K
newL O
(O P
EnvironmentP [
.[ \
ProcessorCount\ j
,j k
capacityl t
)t u
;u v
public 

TValue 
GetOrAdd 
( 
in 
TKey "
key# &
)& '
=>( *
_dictionary+ 6
.6 7
GetOrAdd7 ?
(? @
key@ C
,C D
_valueFactoryE R
)R S
.S T
ValueT Y
;Y Z
public 

bool 
	IsDefault 
=> 
_dictionary (
==) +
null, 0
;0 1
}		 ä\
PC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Internal\InternalApi.cs
	namespace 	

AutoMapper
 
. 
Internal 
; 
[		 
EditorBrowsable		 
(		  
EditorBrowsableState		 %
.		% &
Never		& +
)		+ ,
]		, -
public

 
static

 
class

 
InternalApi

 
{ 
public 

static  
IGlobalConfiguration &
Internal' /
(/ 0
this0 4"
IConfigurationProvider5 K
configurationL Y
)Y Z
=>[ ]
(^ _ 
IGlobalConfiguration_ s
)s t
configuration	t Å
;
Å Ç
public 

static *
IGlobalConfigurationExpression 0
Internal1 9
(9 :
this: >*
IMapperConfigurationExpression? ]
configuration^ k
)k l
=>m o
(p q+
IGlobalConfigurationExpression	q è
)
è ê
configuration
ê ù
;
ù û
public 

static &
IProfileExpressionInternal ,
Internal- 5
(5 6
this6 :
IProfileExpression; M
profileN U
)U V
=>W Y
(Z [&
IProfileExpressionInternal[ u
)u v
profilev }
;} ~
} 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
	interface *
IGlobalConfigurationExpression /
:0 1*
IMapperConfigurationExpression2 P
,P Q&
IProfileExpressionInternalR l
{ 
Func 
< 	
Type	 
, 
object 
> 
ServiceCtor "
{# $
get% (
;( )
}* +
IReadOnlyCollection 
< !
IProfileConfiguration -
>- .
Profiles/ 7
{8 9
get: =
;= >
}? @
Features 
< 
IGlobalFeature 
> 
Features %
{& '
get( +
;+ ,
}- .
List 
< 	
IObjectMapper	 
> 
Mappers 
{  !
get" %
;% &
}' (
void!! 
	Validator!!	 
(!! 
	Validator!! 
	validator!! &
)!!& '
;!!' (
int&& !
MaxExecutionPlanDepth&& 
{&& 
get&&  #
;&&# $
set&&% (
;&&( )
}&&* +
List'' 
<'' 	
	Validator''	 
>'' 

Validators'' 
{''  
get''! $
;''$ %
}''& '
List(( 
<(( 	
IProjectionMapper((	 
>(( 
ProjectionMappers(( -
{((. /
get((0 3
;((3 4
}((5 6
int-- $
RecursiveQueriesMaxDepth--  
{--! "
get--# &
;--& '
set--( +
;--+ ,
}--- .
}.. 
[// 
EditorBrowsable// 
(//  
EditorBrowsableState// %
.//% &
Never//& +
)//+ ,
]//, -
public00 
	interface00  
IGlobalConfiguration00 %
:00& '"
IConfigurationProvider00( >
{11 
TypeMap22 $
ResolveAssociatedTypeMap22 $
(22$ %
TypePair22% -
types22. 3
)223 4
;224 5
IReadOnlyCollection77 
<77 
TypeMap77 
>77  
GetAllTypeMaps77! /
(77/ 0
)770 1
;771 2
TypeMap>> 
FindTypeMapFor>> 
(>> 
Type>> 

sourceType>>  *
,>>* +
Type>>, 0
destinationType>>1 @
)>>@ A
;>>A B
TypeMapDD 
FindTypeMapForDD 
(DD 
TypePairDD #
typePairDD$ ,
)DD, -
;DD- .
TypeMapKK 
FindTypeMapForKK 
<KK 
TSourceKK "
,KK" #
TDestinationKK$ 0
>KK0 1
(KK1 2
)KK2 3
;KK3 4
TypeMapRR 
ResolveTypeMapRR 
(RR 
TypeRR 

sourceTypeRR  *
,RR* +
TypeRR, 0
destinationTypeRR1 @
)RR@ A
;RRA B
TypeMapXX 
ResolveTypeMapXX 
(XX 
TypePairXX #
typePairXX$ ,
)XX, -
;XX- .
void]] &
AssertConfigurationIsValid]]	 #
(]]# $
TypeMap]]$ +
typeMap]], 3
)]]3 4
;]]4 5
voidbb &
AssertConfigurationIsValidbb	 #
(bb# $
stringbb$ *
profileNamebb+ 6
)bb6 7
;bb7 8
voidgg &
AssertConfigurationIsValidgg	 #
<gg# $
TProfilegg$ ,
>gg, -
(gg- .
)gg. /
wheregg0 5
TProfilegg6 >
:gg? @
ProfileggA H
,ggH I
newggJ M
(ggM N
)ggN O
;ggO P
IEnumerablell 
<ll 
IObjectMapperll 
>ll 

GetMappersll )
(ll) *
)ll* +
;ll+ ,
Featuresqq 
<qq 
IRuntimeFeatureqq 
>qq 
Featuresqq &
{qq' (
getqq) ,
;qq, -
}qq. /
IObjectMapperww 

FindMapperww 
(ww 
TypePairww %
typesww& +
)ww+ ,
;ww, -
IProjectionBuilderxx 
ProjectionBuilderxx (
{xx) *
getxx+ .
;xx. /
}xx0 1
Funcyy 
<yy 	
TSourceyy	 
,yy 
TDestinationyy 
,yy 
ResolutionContextyy  1
,yy1 2
TDestinationyy3 ?
>yy? @
GetExecutionPlanyyA Q
<yyQ R
TSourceyyR Y
,yyY Z
TDestinationyy[ g
>yyg h
(yyh i
inyyi k

MapRequestyyl v

mapRequest	yyw Å
)
yyÅ Ç
;
yyÇ É
voidzz 
RegisterTypeMapzz	 
(zz 
TypeMapzz  
typeMapzz! (
)zz( )
;zz) *
LambdaExpression
ÇÇ  
BuildExecutionPlan
ÇÇ '
(
ÇÇ' (
in
ÇÇ( *

MapRequest
ÇÇ+ 5

mapRequest
ÇÇ6 @
)
ÇÇ@ A
;
ÇÇA B
bool
áá 2
$EnableNullPropagationForQueryMapping
áá	 -
{
áá. /
get
áá0 3
;
áá3 4
}
áá5 6
Func
ãã 
<
ãã 	
Type
ãã	 
,
ãã 
object
ãã 
>
ãã 
ServiceCtor
ãã "
{
ãã# $
get
ãã% (
;
ãã( )
}
ãã* +
int
åå #
MaxExecutionPlanDepth
åå 
{
åå 
get
åå  #
;
åå# $
}
åå% &
int
çç &
RecursiveQueriesMaxDepth
çç  
{
çç! "
get
çç# &
;
çç& '
}
çç( )

ProfileMap
éé 
[
éé 
]
éé 
Profiles
éé 
{
éé 
get
éé 
;
éé  
}
éé! "
TypeMap
èè  
GetIncludedTypeMap
èè 
(
èè 
TypePair
èè '
typePair
èè( 0
)
èè0 1
;
èè1 2
TypeMap
êê  
GetIncludedTypeMap
êê 
(
êê 
Type
êê #

sourceType
êê$ .
,
êê. /
Type
êê0 4
destinationType
êê5 D
)
êêD E
;
êêE F
TypeMap
ëë 
[
ëë 
]
ëë !
GetIncludedTypeMaps
ëë !
(
ëë! "!
IReadOnlyCollection
ëë" 5
<
ëë5 6
TypePair
ëë6 >
>
ëë> ?
includedTypes
ëë@ M
)
ëëM N
;
ëëN O
void
íí 
RegisterAsMap
íí	 
(
íí "
TypeMapConfiguration
íí +"
typeMapConfiguration
íí, @
)
íí@ A
;
ííA B!
ParameterExpression
ìì 
[
ìì 
]
ìì 

Parameters
ìì $
{
ìì% &
get
ìì' *
;
ìì* +
}
ìì, -
List
îî 
<
îî 	

MemberInfo
îî	 
>
îî 
SourceMembers
îî "
{
îî# $
get
îî% (
;
îî( )
}
îî* +
List
ïï 
<
ïï 	!
ParameterExpression
ïï	 
>
ïï 
	Variables
ïï '
{
ïï( )
get
ïï* -
;
ïï- .
}
ïï/ 0
List
ññ 
<
ññ 	

Expression
ññ	 
>
ññ 
Expressions
ññ  
{
ññ! "
get
ññ# &
;
ññ& '
}
ññ( )
HashSet
óó 
<
óó 
TypeMap
óó 
>
óó 
TypeMapsPath
óó !
{
óó" #
get
óó$ '
;
óó' (
}
óó) *

CatchBlock
òò 
[
òò 
]
òò 
Catches
òò 
{
òò 
get
òò 
;
òò 
}
òò  !
DefaultExpression
ôô 

GetDefault
ôô  
(
ôô  !
Type
ôô! %
type
ôô& *
)
ôô* +
;
ôô+ ,%
ParameterReplaceVisitor
öö %
ParameterReplaceVisitor
öö 3
(
öö3 4
)
öö4 5
;
öö5 6,
ConvertParameterReplaceVisitor
õõ ",
ConvertParameterReplaceVisitor
õõ# A
(
õõA B
)
õõB C
;
õõC D
}úú 
[ùù 
EditorBrowsable
ùù 
(
ùù "
EditorBrowsableState
ùù %
.
ùù% &
Never
ùù& +
)
ùù+ ,
]
ùù, -
publicûû 
	interface
ûû (
IProfileExpressionInternal
ûû +
:
ûû, - 
IProfileExpression
ûû. @
{üü 
List
†† 
<
†† 	
string
††	 
>
†† 
Prefixes
†† 
{
†† 
get
†† 
;
††  
}
††! "
List
°° 
<
°° 	
string
°°	 
>
°° 
	Postfixes
°° 
{
°° 
get
°°  
;
°°  !
}
°°" #!
MemberConfiguration
¢¢ !
MemberConfiguration
¢¢ +
{
¢¢, -
get
¢¢. 1
;
¢¢1 2
}
¢¢3 4
bool
ßß 
?
ßß 	2
$EnableNullPropagationForQueryMapping
ßß
 .
{
ßß/ 0
get
ßß1 4
;
ßß4 5
set
ßß6 9
;
ßß9 :
}
ßß; <
bool
´´ 
?
´´ 	"
MethodMappingEnabled
´´
 
{
´´  
get
´´! $
;
´´$ %
set
´´& )
;
´´) *
}
´´+ ,
bool
ØØ 
?
ØØ 	!
FieldMappingEnabled
ØØ
 
{
ØØ 
get
ØØ  #
;
ØØ# $
set
ØØ% (
;
ØØ( )
}
ØØ* +
void
¥¥ 

ForAllMaps
¥¥	 
(
¥¥ 
Action
¥¥ 
<
¥¥ 
TypeMap
¥¥ "
,
¥¥" # 
IMappingExpression
¥¥$ 6
>
¥¥6 7
configuration
¥¥8 E
)
¥¥E F
;
¥¥F G
void
∫∫  
ForAllPropertyMaps
∫∫	 
(
∫∫ 
Func
∫∫  
<
∫∫  !
PropertyMap
∫∫! ,
,
∫∫, -
bool
∫∫. 2
>
∫∫2 3
	condition
∫∫4 =
,
∫∫= >
Action
∫∫? E
<
∫∫E F
PropertyMap
∫∫F Q
,
∫∫Q R,
IMemberConfigurationExpression
∫∫S q
>
∫∫q r
memberOptions∫∫s Ä
)∫∫Ä Å
;∫∫Å Ç
}ªª √G
DC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Features.cs
	namespace 	

AutoMapper
 
. 
Features 
; 
public 
	interface 
IGlobalFeature 
{ 
void 
	Configure	 
(  
IGlobalConfiguration '
configuration( 5
)5 6
;6 7
} 
public 
	interface 
IMappingFeature  
{ 
void 
	Configure	 
( 
TypeMap 
typeMap "
)" #
;# $
IMappingFeature		 
Reverse		 
(		 
)		 
;		 
}

 
public 
	interface 
IRuntimeFeature  
{ 
void 
Seal	 
(  
IGlobalConfiguration "
configuration# 0
)0 1
;1 2
} 
public 
class 
Features 
< 
TFeature 
> 
{ 
private 
List 
< 
TFeature 
> 
	_features $
;$ %
public 

int 
Count 
=> 
	_features !
?! "
." #
Count# (
??) +
$num, -
;- .
public 

TFeatureToFind 
Get 
< 
TFeatureToFind ,
>, -
(- .
). /
where0 5
TFeatureToFind6 D
:E F
TFeatureG O
{ 
var 
index 
= 
IndexOf 
( 
typeof "
(" #
TFeatureToFind# 1
)1 2
)2 3
;3 4
return 
index 
< 
Count 
? 
(  
TFeatureToFind  .
). /
	_features/ 8
[8 9
index9 >
]> ?
:@ A
defaultB I
;I J
} 
public!! 

void!! 
Set!! 
(!! 
TFeature!! 
feature!! $
)!!$ %
{"" 
var## 
index## 
=## 
IndexOf## 
(## 
feature## #
.### $
GetType##$ +
(##+ ,
)##, -
)##- .
;##. /
if$$ 

($$ 
index$$ 
<$$ 
Count$$ 
)$$ 
{%% 	
	_features&& 
[&& 
index&& 
]&& 
=&& 
feature&& &
;&&& '
}'' 	
else(( 
{)) 	
	_features** 
??=** 
[** 
]** 
;** 
	_features++ 
.++ 
Add++ 
(++ 
feature++ !
)++! "
;++" #
},, 	
}-- 
private.. 
int.. 
IndexOf.. 
(.. 
Type.. 
featureType.. (
)..( )
{// 
int00 
index00 
=00 
$num00 
;00 
for11 
(11 
;11 
index11 
<11 
Count11 
&&11 
	_features11  )
[11) *
index11* /
]11/ 0
.110 1
GetType111 8
(118 9
)119 :
!=11; =
featureType11> I
;11I J
index11K P
++11P R
)11R S
;11S T
return22 
index22 
;22 
}33 
public44 

List44 
<44 
TFeature44 
>44 
.44 

Enumerator44 $
GetEnumerator44% 2
(442 3
)443 4
=>445 7
	_features448 A
.44A B
GetEnumerator44B O
(44O P
)44P Q
;44Q R
}55 
public66 
static66 
class66 
FeatureExtensions66 %
{77 
public88 

static88 *
IMapperConfigurationExpression88 0

SetFeature881 ;
(88; <
this88< @*
IMapperConfigurationExpression88A _
configuration88` m
,88m n
IGlobalFeature88o }
feature	88~ Ö
)
88Ö Ü
{99 
configuration:: 
.:: 
Internal:: 
(:: 
)::  
.::  !
Features::! )
.::) *
Set::* -
(::- .
feature::. 5
)::5 6
;::6 7
return;; 
configuration;; 
;;; 
}<< 
public== 

static== 
IMappingExpression== $
<==$ %
TSource==% ,
,==, -
TDestination==. :
>==: ;

SetFeature==< F
<==F G
TSource==G N
,==N O
TDestination==P \
>==\ ]
(==] ^
this==^ b
IMappingExpression==c u
<==u v
TSource==v }
,==} ~
TDestination	== ã
>
==ã å
mapping
==ç î
,
==î ï
IMappingFeature
==ñ •
feature
==¶ ≠
)
==≠ Æ
{>> 
mapping?? 
.?? 
Features?? 
.?? 
Set?? 
(?? 
feature?? $
)??$ %
;??% &
return@@ 
mapping@@ 
;@@ 
}AA 
internalBB 
staticBB 
voidBB 
	ConfigureBB "
(BB" #
thisBB# '
FeaturesBB( 0
<BB0 1
IGlobalFeatureBB1 ?
>BB? @
featuresBBA I
,BBI J
MapperConfigurationBBK ^
mapperConfigurationBB_ r
)BBr s
{CC 
ifDD 

(DD 
featuresDD 
.DD 
CountDD 
==DD 
$numDD 
)DD  
{EE 	
returnFF 
;FF 
}GG 	
foreachHH 
(HH 
varHH 
featureHH 
inHH 
featuresHH  (
)HH( )
{II 	
featureJJ 
.JJ 
	ConfigureJJ 
(JJ 
mapperConfigurationJJ 1
)JJ1 2
;JJ2 3
}KK 	
}LL 
publicMM 

staticMM 
voidMM 
	ReverseToMM  
(MM  !
thisMM! %
FeaturesMM& .
<MM. /
IMappingFeatureMM/ >
>MM> ?
featuresMM@ H
,MMH I
FeaturesMMJ R
<MMR S
IMappingFeatureMMS b
>MMb c
reversedFeaturesMMd t
)MMt u
{NN 
ifOO 

(OO 
featuresOO 
.OO 
CountOO 
==OO 
$numOO 
)OO  
{PP 	
returnQQ 
;QQ 
}RR 	
foreachSS 
(SS 
varSS 
featureSS 
inSS 
featuresSS  (
)SS( )
{TT 	
varUU 
reverseUU 
=UU 
featureUU !
.UU! "
ReverseUU" )
(UU) *
)UU* +
;UU+ ,
ifVV 
(VV 
reverseVV 
!=VV 
nullVV 
)VV  
{WW 
reversedFeaturesXX  
.XX  !
SetXX! $
(XX$ %
reverseXX% ,
)XX, -
;XX- .
}YY 
}ZZ 	
}[[ 
internal\\ 
static\\ 
void\\ 
	Configure\\ "
(\\" #
this\\# '
Features\\( 0
<\\0 1
IMappingFeature\\1 @
>\\@ A
features\\B J
,\\J K
TypeMap\\L S
typeMap\\T [
)\\[ \
{]] 
if^^ 

(^^ 
features^^ 
.^^ 
Count^^ 
==^^ 
$num^^ 
)^^  
{__ 	
return`` 
;`` 
}aa 	
foreachbb 
(bb 
varbb 
featurebb 
inbb 
featuresbb  (
)bb( )
{cc 	
featuredd 
.dd 
	Configuredd 
(dd 
typeMapdd %
)dd% &
;dd& '
}ee 	
}ff 
internalgg 
staticgg 
voidgg 
Sealgg 
(gg 
thisgg "
Featuresgg# +
<gg+ ,
IRuntimeFeaturegg, ;
>gg; <
featuresgg= E
,ggE F 
IGlobalConfigurationggG [
configurationgg\ i
)ggi j
{hh 
ifii 

(ii 
featuresii 
.ii 
Countii 
==ii 
$numii 
)ii  
{jj 	
returnkk 
;kk 
}ll 	
foreachmm 
(mm 
varmm 
featuremm 
inmm 
featuresmm  (
)mm( )
{nn 	
featureoo 
.oo 
Sealoo 
(oo 
configurationoo &
)oo& '
;oo' (
}pp 	
}qq 
}rr Â∫
XC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Execution\TypeMapPlanBuilder.cs
	namespace 	

AutoMapper
 
. 
	Execution 
; 
public 
ref 

struct 
TypeMapPlanBuilder $
($ % 
IGlobalConfiguration% 9
configuration: G
,G H
TypeMapI P
typeMapQ X
)X Y
{ 
static 

readonly 

MethodInfo 
MappingError +
=, -
typeof. 4
(4 5
TypeMapPlanBuilder5 G
)G H
.H I
GetStaticMethodI X
(X Y
nameofY _
(_ `
MemberMappingError` r
)r s
)s t
;t u
static 

readonly 

MethodInfo 
IncTypeDepthInfo /
=0 1
typeof2 8
(8 9
ResolutionContext9 J
)J K
.K L
GetInstanceMethodL ]
(] ^
nameof^ d
(d e
ResolutionContexte v
.v w
IncrementTypeDepth	w â
)
â ä
)
ä ã
;
ã å
static 

readonly 

MethodInfo 
DecTypeDepthInfo /
=0 1
typeof2 8
(8 9
ResolutionContext9 J
)J K
.K L
GetInstanceMethodL ]
(] ^
nameof^ d
(d e
ResolutionContexte v
.v w
DecrementTypeDepth	w â
)
â ä
)
ä ã
;
ã å
static 

readonly 

MethodInfo "
CacheDestinationMethod 5
=6 7
typeof8 >
(> ?
ResolutionContext? P
)P Q
.Q R
GetInstanceMethodR c
(c d
nameofd j
(j k
ResolutionContextk |
.| }
CacheDestination	} ç
)
ç é
)
é è
;
è ê
static 

readonly 

MethodInfo  
GetDestinationMethod 3
=4 5
typeof6 <
(< =
ResolutionContext= N
)N O
.O P
GetInstanceMethodP a
(a b
nameofb h
(h i
ResolutionContexti z
.z {
GetDestination	{ â
)
â ä
)
ä ã
;
ã å
readonly		  
IGlobalConfiguration		 !
_configuration		" 0
=		1 2
configuration		3 @
;		@ A
readonly

 
ParameterExpression

  
_destination

! -
=

. /
Variable

0 8
(

8 9
typeMap

9 @
.

@ A
DestinationType

A P
,

P Q
$str

R f
)

f g
;

g h
readonly 
ParameterExpression  
_initialDestination! 4
=5 6
	Parameter7 @
(@ A
typeMapA H
.H I
DestinationTypeI X
,X Y
$strZ g
)g h
;h i
readonly 
ParameterExpression  
[  !
]! "
_parameters# .
=/ 0
configuration1 >
.> ?

Parameters? I
??J L
[M N
nullN R
,R S
nullT X
,X Y
ContextParameterZ j
]j k
;k l
readonly 
TypeMap 
_typeMap 
= 
typeMap  '
;' (
readonly 
ParameterExpression  
_source! (
=) *
	Parameter+ 4
(4 5
typeMap5 <
.< =

SourceType= G
,G H
$strI Q
)Q R
;R S
List 
< 	
ParameterExpression	 
> 

_variables (
=) *
configuration+ 8
.8 9
	Variables9 B
;B C
List 
< 	

Expression	 
> 
_expressions !
=" #
configuration$ 1
.1 2
Expressions2 =
;= >

CatchBlock 
[ 
] 
_catches 
= 
configuration )
.) *
Catches* 1
;1 2
public 

Type 
DestinationType 
=>  "
_destination# /
./ 0
Type0 4
;4 5
private 
static &
AutoMapperMappingException -
MemberMappingError. @
(@ A
	ExceptionA J
innerExceptionK Y
,Y Z
	MemberMap[ d
	memberMape n
)n o
=>p r
news v
(v w
$str	w ç
,
ç é
innerException
è ù
,
ù û
	memberMap
ü ®
)
® ©
;
© ™
ParameterExpression 
[ 
] 
GetParameters '
(' (
ParameterExpression( ;
first< A
=B C
nullD H
,H I
ParameterExpressionJ ]
second^ d
=e f
nullg k
)k l
{ 
_parameters 
[ 
$num 
] 
= 
first 
?? !
_source" )
;) *
_parameters 
[ 
$num 
] 
= 
second 
??  "
_destination# /
;/ 0
return 
_parameters 
; 
} 
public 

LambdaExpression 
CreateMapperLambda .
(. /
)/ 0
{ 
var 

parameters 
= 
GetParameters &
(& '
second' -
:- .
_initialDestination/ B
)B C
;C D
var 
customExpression 
= 
_typeMap '
.' (
TypeConverter( 5
?5 6
.6 7
GetExpression7 D
(D E
_configurationE S
,S T

parametersU _
)_ `
;` a
if 

( 
customExpression 
!= 
null  $
)$ %
{ 	
return   
Lambda   
(   
customExpression   *
,  * +

parameters  , 6
)  6 7
;  7 8
}!! 	

_variables"" 
??="" 
["" 
]"" 
;"" 
_expressions## 
??=## 
[## 
]## 
;## 
_catches$$ 
??=$$ 
[$$ 
null$$ 
]$$ 
;$$ 
var%% 
typeMapsPath%% 
=%% 
_configuration%% )
.%%) *
TypeMapsPath%%* 6
;%%6 7
Clear&& 
(&& 
ref&& 
typeMapsPath&& 
)&& 
;&&  
CheckForCycles'' 
('' 
_configuration'' %
,''% &
_typeMap''' /
,''/ 0
typeMapsPath''1 =
)''= >
;''> ?
var(( !
createDestinationFunc(( !
=((" #!
CreateDestinationFunc(($ 9
(((9 :
)((: ;
;((; <
var)) 
assignmentFunc)) 
=))  
CreateAssignmentFunc)) 1
())1 2!
createDestinationFunc))2 G
)))G H
;))H I
var** 

mapperFunc** 
=** 
CreateMapperFunc** )
(**) *
assignmentFunc*** 8
)**8 9
;**9 :

_variables++ 
.++ 
Clear++ 
(++ 
)++ 
;++ 
_expressions,, 
.,, 
Clear,, 
(,, 
),, 
;,, 
if-- 

(-- 
_typeMap-- 
.-- #
IncludedMembersTypeMaps-- ,
.--, -
Count--- 2
>--3 4
$num--5 6
)--6 7
{.. 	
IncludeMembers// 
(// 
)// 
;// 
}00 	
var11 
checkContext11 
=11 
CheckContext11 '
(11' (
_typeMap11( 0
)110 1
;111 2
if22 

(22 
checkContext22 
!=22 
null22  
)22  !
{33 	
_expressions44 
.44 
Add44 
(44 
checkContext44 )
)44) *
;44* +
}55 	
_expressions66 
.66 
Add66 
(66 

mapperFunc66 #
)66# $
;66$ %

_variables77 
.77 
Add77 
(77 
_destination77 #
)77# $
;77$ %

mapperFunc88 
=88 
Block88 
(88 

_variables88 %
,88% &
_expressions88' 3
)883 4
;884 5
return99 
Lambda99 
(99 
_configuration99 $
.99$ %
NullCheckSource99% 4
(994 5
_typeMap995 =
.99= >
Profile99> E
,99E F
_source99G N
,99N O
_initialDestination99P c
,99c d

mapperFunc99e o
,99o p
null99q u
)99u v
,99v w
GetParameters	99x Ö
(
99Ö Ü
second
99Ü å
:
99å ç!
_initialDestination
99é °
)
99° ¢
)
99¢ £
;
99£ §
static:: 
void:: 
Clear:: 
(:: 
ref:: 
HashSet:: %
<::% &
TypeMap::& -
>::- .
typeMapsPath::/ ;
)::; <
{;; 	
if<< 
(<< 
typeMapsPath<< 
==<< 
null<<  $
)<<$ %
{== 
typeMapsPath>> 
=>> 
[>>  
]>>  !
;>>! "
}?? 
else@@ 
{AA 
typeMapsPathBB 
.BB 
ClearBB "
(BB" #
)BB# $
;BB$ %
}CC 
}DD 	
}EE 
voidFF 
IncludeMembersFF	 
(FF 
)FF 
{GG 
foreachHH 
(HH 
varHH 
includedMapHH  
inHH! #
_typeMapHH$ ,
.HH, -#
IncludedMembersTypeMapsHH- D
)HHD E
{II 	
varJJ 
variableJJ 
=JJ 
includedMapJJ &
.JJ& '
VariableJJ' /
;JJ/ 0

_variablesKK 
.KK 
AddKK 
(KK 
variableKK #
)KK# $
;KK$ %
_expressionsLL 
.LL 
AddLL 
(LL 
AssignLL #
(LL# $
variableLL$ ,
,LL, -
_configurationLL. <
.LL< =
ReplaceParametersLL= N
(LLN O
includedMapLLO Z
.LLZ [
MemberExpressionLL[ k
,LLk l
_sourceLLm t
)LLt u
.LLu v
	NullCheckLLv 
(	LL Ä
null
LLÄ Ñ
)
LLÑ Ö
)
LLÖ Ü
)
LLÜ á
;
LLá à
}MM 	
}NN 
privateOO 
staticOO 
voidOO 
CheckForCyclesOO &
(OO& ' 
IGlobalConfigurationOO' ;
configurationOO< I
,OOI J
TypeMapOOK R
typeMapOOS Z
,OOZ [
HashSetOO\ c
<OOc d
TypeMapOOd k
>OOk l
typeMapsPathOOm y
)OOy z
{PP 
typeMapsPathQQ 
.QQ 
AddQQ 
(QQ 
typeMapQQ  
)QQ  !
;QQ! "
foreachRR 
(RR 
varRR 
	memberMapRR 
inRR !

MemberMapsRR" ,
(RR, -
)RR- .
)RR. /
{SS 	
varTT 
memberTypeMapTT 
=TT  
ResolveMemberTypeMapTT  4
(TT4 5
	memberMapTT5 >
)TT> ?
;TT? @
ifUU 
(UU 
memberTypeMapUU 
==UU  
nullUU! %
||UU& (
memberTypeMapUU) 6
.UU6 7
HasTypeConverterUU7 G
)UUG H
{VV 
continueWW 
;WW 
}XX 
ifYY 
(YY 
	memberMapYY 
.YY 
InlineYY  
&&YY! #
(YY$ %
memberTypeMapYY% 2
.YY2 3
PreserveReferencesYY3 E
||YYF H
typeMapsPathYYI U
.YYU V
CountYYV [
==YY\ ^
configurationYY_ l
.YYl m"
MaxExecutionPlanDepth	YYm Ç
)
YYÇ É
)
YYÉ Ñ
{ZZ 
	memberMap[[ 
.[[ 
Inline[[  
=[[! "
false[[# (
;[[( )
TraceInline\\ 
(\\ 
typeMap\\ #
,\\# $
	memberMap\\% .
)\\. /
;\\/ 0
}]] 
if^^ 
(^^ 
memberTypeMap^^ 
.^^ 
PreserveReferences^^ 0
||^^1 3
memberTypeMap^^4 A
.^^A B
MapExpression^^B O
!=^^P R
null^^S W
)^^W X
{__ 
continue`` 
;`` 
}aa 
ifbb 
(bb 
typeMapsPathbb 
.bb 
Containsbb %
(bb% &
memberTypeMapbb& 3
)bb3 4
)bb4 5
{cc 
ifdd 
(dd 
memberTypeMapdd !
.dd! "

SourceTypedd" ,
.dd, -
IsValueTypedd- 8
||dd9 ;
memberTypeMapdd< I
.ddI J
DestinationTypeddJ Y
.ddY Z
IsValueTypeddZ e
)dde f
{ee 
ifff 
(ff 
memberTypeMapff %
.ff% &
MaxDepthff& .
==ff/ 1
$numff2 3
)ff3 4
{gg 
memberTypeMaphh %
.hh% &
MaxDepthhh& .
=hh/ 0
$numhh1 3
;hh3 4
}ii 
continuejj 
;jj 
}kk 
memberTypeMapll 
.ll 
PreserveReferencesll 0
=ll1 2
truell3 7
;ll7 8
Tracemm 
(mm 
typeMapmm 
,mm 
memberTypeMapmm ,
,mm, -
	memberMapmm. 7
)mm7 8
;mm8 9
ifnn 
(nn 
	memberMapnn 
.nn 
Inlinenn $
)nn$ %
{oo 
	memberMappp 
.pp 
Inlinepp $
=pp% &
falsepp' ,
;pp, -
TraceInlineqq 
(qq  
typeMapqq  '
,qq' (
	memberMapqq) 2
)qq2 3
;qq3 4
}rr 
foreachss 
(ss 
varss 
derivedTypeMapss +
inss, .
configurationss/ <
.ss< =
GetIncludedTypeMapsss= P
(ssP Q
memberTypeMapssQ ^
)ss^ _
)ss_ `
{tt 
derivedTypeMapuu "
.uu" #
PreserveReferencesuu# 5
=uu6 7
trueuu8 <
;uu< =
Tracevv 
(vv 
typeMapvv !
,vv! "
derivedTypeMapvv# 1
,vv1 2
	memberMapvv3 <
)vv< =
;vv= >
}ww 
}xx 
CheckForCyclesyy 
(yy 
configurationyy (
,yy( )
memberTypeMapyy* 7
,yy7 8
typeMapsPathyy9 E
)yyE F
;yyF G
}zz 	
typeMapsPath{{ 
.{{ 
Remove{{ 
({{ 
typeMap{{ #
){{# $
;{{$ %
return|| 
;|| 
IEnumerable}} 
<}} 
	MemberMap}} 
>}} 

MemberMaps}} )
(}}) *
)}}* +
{~~ 	
var 

memberMaps 
= 
typeMap $
.$ %

MemberMaps% /
;/ 0
return
ÄÄ 
typeMap
ÄÄ 
.
ÄÄ &
HasDerivedTypesToInclude
ÄÄ 3
?
ÄÄ4 5

memberMaps
ÅÅ 
.
ÅÅ 
Concat
ÅÅ !
(
ÅÅ! "
configuration
ÅÅ" /
.
ÅÅ/ 0!
GetIncludedTypeMaps
ÅÅ0 C
(
ÅÅC D
typeMap
ÅÅD K
)
ÅÅK L
.
ÅÅL M

SelectMany
ÅÅM W
(
ÅÅW X
tm
ÅÅX Z
=>
ÅÅ[ ]
tm
ÅÅ^ `
.
ÅÅ` a

MemberMaps
ÅÅa k
)
ÅÅk l
)
ÅÅl m
:
ÅÅn o

memberMaps
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
TypeMap
ÑÑ "
ResolveMemberTypeMap
ÑÑ $
(
ÑÑ$ %
	MemberMap
ÑÑ% .
	memberMap
ÑÑ/ 8
)
ÑÑ8 9
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ 
!
ÜÜ 
	memberMap
ÜÜ 
.
ÜÜ 
CanResolveValue
ÜÜ *
)
ÜÜ* +
{
áá 
return
àà 
null
àà 
;
àà 
}
ââ 
var
ää 
types
ää 
=
ää 
	memberMap
ää !
.
ää! "
Types
ää" '
(
ää' (
)
ää( )
;
ää) *
return
ãã 
types
ãã 
.
ãã '
ContainsGenericParameters
ãã 2
?
ãã3 4
null
ãã5 9
:
ãã: ;
configuration
ãã< I
.
ããI J&
ResolveAssociatedTypeMap
ããJ b
(
ããb c
types
ããc h
)
ããh i
;
ããi j
}
åå 	
[
çç 	
Conditional
çç	 
(
çç 
$str
çç 
)
çç 
]
çç 
static
éé 
void
éé 
Trace
éé 
(
éé 
TypeMap
éé !
typeMap
éé" )
,
éé) *
TypeMap
éé+ 2
memberTypeMap
éé3 @
,
éé@ A
	MemberMap
ééB K
	memberMap
ééL U
)
ééU V
=>
ééW Y
Debug
èè 
.
èè 
	WriteLine
èè 
(
èè 
$"
èè 
$str
èè :
{
èè: ;
	memberMap
èè; D
.
èèD E
DestinationName
èèE T
}
èèT U
$str
èèU V
{
èèV W
typeMap
èèW ^
.
èè^ _

SourceType
èè_ i
}
èèi j
$str
èèj m
{
èèm n
typeMap
èèn u
.
èèu v
DestinationTypeèèv Ö
}èèÖ Ü
$strèèÜ ä
{èèä ã
memberTypeMapèèã ò
.èèò ô

SourceTypeèèô £
}èè£ §
$strèè§ ß
{èèß ®
memberTypeMapèè® µ
.èèµ ∂
DestinationTypeèè∂ ≈
}èè≈ ∆
"èè∆ «
)èè« »
;èè» …
[
êê 	
Conditional
êê	 
(
êê 
$str
êê 
)
êê 
]
êê 
static
ëë 
void
ëë 
TraceInline
ëë 
(
ëë  
TypeMap
ëë  '
typeMap
ëë( /
,
ëë/ 0
	MemberMap
ëë1 :
	memberMap
ëë; D
)
ëëD E
=>
ëëF H
Debug
íí 
.
íí 
	WriteLine
íí 
(
íí 
$"
íí 
$str
íí 0
{
íí0 1
	memberMap
íí1 :
.
íí: ;
DestinationName
íí; J
}
ííJ K
$str
ííK O
{
ííO P
typeMap
ííP W
.
ííW X

SourceType
ííX b
}
ííb c
$str
ííc f
{
ííf g
typeMap
ííg n
.
íín o
DestinationType
íío ~
}
íí~ 
"íí Ä
)ííÄ Å
;ííÅ Ç
}
ìì 
private
îî 

Expression
îî #
CreateDestinationFunc
îî ,
(
îî, -
)
îî- .
{
ïï 
var
ññ 
newDestFunc
ññ 
=
ññ &
CreateNewDestinationFunc
ññ 2
(
ññ2 3
)
ññ3 4
;
ññ4 5
var
óó 
getDest
óó 
=
óó 
DestinationType
óó %
.
óó% &
IsValueType
óó& 1
?
óó2 3
newDestFunc
óó4 ?
:
óó@ A
Coalesce
óóB J
(
óóJ K!
_initialDestination
óóK ^
,
óó^ _
ToType
óó` f
(
óóf g
newDestFunc
óóg r
,
óór s
DestinationTypeóót É
)óóÉ Ñ
)óóÑ Ö
;óóÖ Ü
var
òò 
destinationFunc
òò 
=
òò 
Assign
òò $
(
òò$ %
_destination
òò% 1
,
òò1 2
getDest
òò3 :
)
òò: ;
;
òò; <
return
ôô 
_typeMap
ôô 
.
ôô  
PreserveReferences
ôô *
?
ôô+ ,
Block
öö 
(
öö 
destinationFunc
öö !
,
öö! "
Call
öö# '
(
öö' (
ContextParameter
öö( 8
,
öö8 9$
CacheDestinationMethod
öö: P
,
ööP Q
_source
ööR Y
,
ööY Z
Constant
öö[ c
(
ööc d
DestinationType
ööd s
)
öös t
,
ööt u
_destinationööv Ç
)ööÇ É
,ööÉ Ñ
_destinationööÖ ë
)ööë í
:ööì î
destinationFunc
õõ 
;
õõ 
}
úú 

Expression
ùù 
ReplaceParameters
ùù  
(
ùù  !
LambdaExpression
ùù! 1
lambda
ùù2 8
)
ùù8 9
=>
ùù: <
_configuration
ùù= K
.
ùùK L
ReplaceParameters
ùùL ]
(
ùù] ^
lambda
ùù^ d
,
ùùd e
GetParameters
ùùf s
(
ùùs t
)
ùùt u
)
ùùu v
;
ùùv w
private
ûû 

Expression
ûû "
CreateAssignmentFunc
ûû +
(
ûû+ ,

Expression
ûû, 6
createDestination
ûû7 H
)
ûûH I
{
üü 
List
†† 
<
†† 

Expression
†† 
>
†† 
actions
††  
=
††! "
[
††# $
createDestination
††$ 5
]
††5 6
;
††6 7

Expression
°° 
typeMapExpression
°° $
=
°°% &
null
°°' +
;
°°+ ,
var
¢¢ 
hasMaxDepth
¢¢ 
=
¢¢ 
_typeMap
¢¢ "
.
¢¢" #
MaxDepth
¢¢# +
>
¢¢, -
$num
¢¢. /
;
¢¢/ 0
if
££ 

(
££ 
hasMaxDepth
££ 
)
££ 
{
§§ 	
typeMapExpression
•• 
=
•• 
Constant
••  (
(
••( )
_typeMap
••) 1
)
••1 2
;
••2 3
actions
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
Call
¶¶ 
(
¶¶ 
ContextParameter
¶¶ -
,
¶¶- .
IncTypeDepthInfo
¶¶/ ?
,
¶¶? @
typeMapExpression
¶¶A R
)
¶¶R S
)
¶¶S T
;
¶¶T U
}
ßß 	
AddBeforeMap
®® 
(
®® 
actions
®® 
)
®® 
;
®® 
AddPropertyMaps
©© 
(
©© 
actions
©© 
)
©©  
;
©©  !
AddPathMaps
™™ 
(
™™ 
actions
™™ 
)
™™ 
;
™™ 
AddAfterMap
´´ 
(
´´ 
actions
´´ 
)
´´ 
;
´´ 
if
¨¨ 

(
¨¨ 
hasMaxDepth
¨¨ 
)
¨¨ 
{
≠≠ 	
actions
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ 
Call
ÆÆ 
(
ÆÆ 
ContextParameter
ÆÆ -
,
ÆÆ- .
DecTypeDepthInfo
ÆÆ/ ?
,
ÆÆ? @
typeMapExpression
ÆÆA R
)
ÆÆR S
)
ÆÆS T
;
ÆÆT U
}
ØØ 	
actions
∞∞ 
.
∞∞ 
Add
∞∞ 
(
∞∞ 
_destination
∞∞  
)
∞∞  !
;
∞∞! "
return
±± 
Block
±± 
(
±± 
actions
±± 
)
±± 
;
±± 
}
≤≤ 
private
≥≥ 
void
≥≥ 
AddAfterMap
≥≥ 
(
≥≥ 
List
≥≥ !
<
≥≥! "

Expression
≥≥" ,
>
≥≥, -
actions
≥≥. 5
)
≥≥5 6
{
¥¥ 
var
µµ 
afterMap
µµ 
=
µµ 
_typeMap
µµ 
.
µµ  
AfterMapActions
µµ  /
;
µµ/ 0
if
∂∂ 

(
∂∂ 
afterMap
∂∂ 
.
∂∂ 
Count
∂∂ 
==
∂∂ 
$num
∂∂ 
)
∂∂  
{
∑∑ 	
return
∏∏ 
;
∏∏ 
}
ππ 	
foreach
∫∫ 
(
∫∫ 
var
∫∫ 
afterMapAction
∫∫ #
in
∫∫$ &
afterMap
∫∫' /
)
∫∫/ 0
{
ªª 	
actions
ºº 
.
ºº 
Add
ºº 
(
ºº 
ReplaceParameters
ºº )
(
ºº) *
afterMapAction
ºº* 8
)
ºº8 9
)
ºº9 :
;
ºº: ;
}
ΩΩ 	
}
ææ 
private
øø 
void
øø 
AddPathMaps
øø 
(
øø 
List
øø !
<
øø! "

Expression
øø" ,
>
øø, -
actions
øø. 5
)
øø5 6
{
¿¿ 
var
¡¡ 
pathMaps
¡¡ 
=
¡¡ 
_typeMap
¡¡ 
.
¡¡  
PathMaps
¡¡  (
;
¡¡( )
if
¬¬ 

(
¬¬ 
pathMaps
¬¬ 
.
¬¬ 
Count
¬¬ 
==
¬¬ 
$num
¬¬ 
)
¬¬  
{
√√ 	
return
ƒƒ 
;
ƒƒ 
}
≈≈ 	
foreach
∆∆ 
(
∆∆ 
var
∆∆ 
pathMap
∆∆ 
in
∆∆ 
pathMaps
∆∆  (
)
∆∆( )
{
«« 	
if
»» 
(
»» 
pathMap
»» 
.
»» 
Ignored
»» 
)
»»  
{
…… 
continue
   
;
   
}
ÀÀ 
actions
ÃÃ 
.
ÃÃ 
Add
ÃÃ 
(
ÃÃ 

TryPathMap
ÃÃ "
(
ÃÃ" #
pathMap
ÃÃ# *
)
ÃÃ* +
)
ÃÃ+ ,
;
ÃÃ, -
}
ÕÕ 	
}
ŒŒ 
private
œœ 
void
œœ 
AddBeforeMap
œœ 
(
œœ 
List
œœ "
<
œœ" #

Expression
œœ# -
>
œœ- .
actions
œœ/ 6
)
œœ6 7
{
–– 
var
—— 
	beforeMap
—— 
=
—— 
_typeMap
——  
.
——  !
BeforeMapActions
——! 1
;
——1 2
if
““ 

(
““ 
	beforeMap
““ 
.
““ 
Count
““ 
==
““ 
$num
““  
)
““  !
{
”” 	
return
‘‘ 
;
‘‘ 
}
’’ 	
foreach
÷÷ 
(
÷÷ 
var
÷÷ 
beforeMapAction
÷÷ $
in
÷÷% '
	beforeMap
÷÷( 1
)
÷÷1 2
{
◊◊ 	
actions
ÿÿ 
.
ÿÿ 
Add
ÿÿ 
(
ÿÿ 
ReplaceParameters
ÿÿ )
(
ÿÿ) *
beforeMapAction
ÿÿ* 9
)
ÿÿ9 :
)
ÿÿ: ;
;
ÿÿ; <
}
ŸŸ 	
}
⁄⁄ 
private
€€ 
void
€€ 
AddPropertyMaps
€€  
(
€€  !
List
€€! %
<
€€% &

Expression
€€& 0
>
€€0 1
actions
€€2 9
)
€€9 :
{
‹‹ 
var
›› 
propertyMaps
›› 
=
›› 
_typeMap
›› #
.
››# $!
OrderedPropertyMaps
››$ 7
(
››7 8
)
››8 9
;
››9 :
if
ﬁﬁ 

(
ﬁﬁ 
propertyMaps
ﬁﬁ 
==
ﬁﬁ 
null
ﬁﬁ  
)
ﬁﬁ  !
{
ﬂﬂ 	
return
‡‡ 
;
‡‡ 
}
·· 	
foreach
‚‚ 
(
‚‚ 
var
‚‚ 
propertyMap
‚‚  
in
‚‚! #
propertyMaps
‚‚$ 0
)
‚‚0 1
{
„„ 	
if
‰‰ 
(
‰‰ 
!
‰‰ 
propertyMap
‰‰ 
.
‰‰ 
CanResolveValue
‰‰ ,
)
‰‰, -
{
ÂÂ 
continue
ÊÊ 
;
ÊÊ 
}
ÁÁ 
var
ËË 
property
ËË 
=
ËË 
TryMemberMap
ËË '
(
ËË' (
propertyMap
ËË( 3
,
ËË3 4#
CreatePropertyMapFunc
ËË5 J
(
ËËJ K
propertyMap
ËËK V
,
ËËV W
_destination
ËËX d
,
ËËd e
propertyMap
ËËf q
.
ËËq r 
DestinationMemberËËr É
)ËËÉ Ñ
)ËËÑ Ö
;ËËÖ Ü
if
ÈÈ 
(
ÈÈ 
_typeMap
ÈÈ 
.
ÈÈ )
ConstructorParameterMatches
ÈÈ 4
(
ÈÈ4 5
propertyMap
ÈÈ5 @
.
ÈÈ@ A
DestinationName
ÈÈA P
)
ÈÈP Q
)
ÈÈQ R
{
ÍÍ 
property
ÎÎ 
=
ÎÎ !
_initialDestination
ÎÎ .
.
ÎÎ. /

IfNullElse
ÎÎ/ 9
(
ÎÎ9 :
_configuration
ÎÎ: H
.
ÎÎH I
Default
ÎÎI P
(
ÎÎP Q
property
ÎÎQ Y
.
ÎÎY Z
Type
ÎÎZ ^
)
ÎÎ^ _
,
ÎÎ_ `
property
ÎÎa i
)
ÎÎi j
;
ÎÎj k
}
ÏÏ 
actions
ÌÌ 
.
ÌÌ 
Add
ÌÌ 
(
ÌÌ 
property
ÌÌ  
)
ÌÌ  !
;
ÌÌ! "
}
ÓÓ 	
}
ÔÔ 
private
 

Expression
 

TryPathMap
 !
(
! "
PathMap
" )
pathMap
* 1
)
1 2
{
ÒÒ 
var
ÚÚ 
destination
ÚÚ 
=
ÚÚ 
(
ÚÚ 
(
ÚÚ 
MemberExpression
ÚÚ ,
)
ÚÚ, -
_configuration
ÚÚ- ;
.
ÚÚ; <&
ConvertReplaceParameters
ÚÚ< T
(
ÚÚT U
pathMap
ÚÚU \
.
ÚÚ\ ]#
DestinationExpression
ÚÚ] r
,
ÚÚr s
_destinationÚÚt Ä
)ÚÚÄ Å
)ÚÚÅ Ç
.ÚÚÇ É

ExpressionÚÚÉ ç
;ÚÚç é
var
ÛÛ 
pathMapFunc
ÛÛ 
=
ÛÛ #
CreatePropertyMapFunc
ÛÛ /
(
ÛÛ/ 0
pathMap
ÛÛ0 7
,
ÛÛ7 8
destination
ÛÛ9 D
,
ÛÛD E
pathMap
ÛÛF M
.
ÛÛM N

MemberPath
ÛÛN X
.
ÛÛX Y
Last
ÛÛY ]
)
ÛÛ] ^
;
ÛÛ^ _
_expressions
ÙÙ 
.
ÙÙ 
Clear
ÙÙ 
(
ÙÙ 
)
ÙÙ 
;
ÙÙ 
foreach
ıı 
(
ıı 
var
ıı 
member
ıı 
in
ıı 
destination
ıı *
.
ıı* +"
GetMemberExpressions
ıı+ ?
(
ıı? @
)
ıı@ A
)
ııA B
{
ˆˆ 	
var
˜˜ 
setter
˜˜ 
=
˜˜ 
	GetSetter
˜˜ "
(
˜˜" #
member
˜˜# )
)
˜˜) *
;
˜˜* +
var
¯¯ 
ifNull
¯¯ 
=
¯¯ 
setter
¯¯ 
==
¯¯  "
null
¯¯# '
?
˘˘ 
Throw
˘˘ 
(
˘˘ 
Constant
˘˘  
(
˘˘  !
new
˘˘! $$
NullReferenceException
˘˘% ;
(
˘˘; <
$"
˘˘< >
{
˘˘> ?
member
˘˘? E
}
˘˘E F
$str
˘˘F s
"
˘˘s t
)
˘˘t u
)
˘˘u v
,
˘˘v w
member
˘˘x ~
.
˘˘~ 
Type˘˘ É
)˘˘É Ñ
:
˙˙ 
(
˙˙ 

Expression
˙˙ 
)
˙˙ 
Assign
˙˙ $
(
˙˙$ %
setter
˙˙% +
,
˙˙+ ,
ObjectFactory
˙˙- :
.
˙˙: ;+
GenerateConstructorExpression
˙˙; X
(
˙˙X Y
member
˙˙Y _
.
˙˙_ `
Type
˙˙` d
,
˙˙d e
_configuration
˙˙f t
)
˙˙t u
)
˙˙u v
;
˙˙v w
_expressions
˚˚ 
.
˚˚ 
Add
˚˚ 
(
˚˚ 
member
˚˚ #
.
˚˚# $

IfNullElse
˚˚$ .
(
˚˚. /
ifNull
˚˚/ 5
,
˚˚5 6
_configuration
˚˚7 E
.
˚˚E F
Default
˚˚F M
(
˚˚M N
member
˚˚N T
.
˚˚T U
Type
˚˚U Y
)
˚˚Y Z
)
˚˚Z [
)
˚˚[ \
;
˚˚\ ]
}
¸¸ 	
_expressions
˝˝ 
.
˝˝ 
Add
˝˝ 
(
˝˝ 
pathMapFunc
˝˝ $
)
˝˝$ %
;
˝˝% &
return
˛˛ 
TryMemberMap
˛˛ 
(
˛˛ 
pathMap
˛˛ #
,
˛˛# $
Block
˛˛% *
(
˛˛* +
_expressions
˛˛+ 7
)
˛˛7 8
)
˛˛8 9
;
˛˛9 :
static
ˇˇ 

Expression
ˇˇ 
	GetSetter
ˇˇ #
(
ˇˇ# $
MemberExpression
ˇˇ$ 4
memberExpression
ˇˇ5 E
)
ˇˇE F
=>
ˇˇG I
memberExpression
ˇˇJ Z
.
ˇˇZ [
Member
ˇˇ[ a
switch
ˇˇb h
{
ÄÄ 	
PropertyInfo
ÅÅ 
{
ÅÅ 
CanWrite
ÅÅ #
:
ÅÅ# $
true
ÅÅ% )
}
ÅÅ* +
property
ÅÅ, 4
=>
ÅÅ5 7
Property
ÅÅ8 @
(
ÅÅ@ A
memberExpression
ÅÅA Q
.
ÅÅQ R

Expression
ÅÅR \
,
ÅÅ\ ]
property
ÅÅ^ f
)
ÅÅf g
,
ÅÅg h
	FieldInfo
ÇÇ 
{
ÇÇ 

IsInitOnly
ÇÇ "
:
ÇÇ" #
false
ÇÇ$ )
}
ÇÇ* +
field
ÇÇ, 1
=>
ÇÇ2 4
Field
ÇÇ5 :
(
ÇÇ: ;
memberExpression
ÇÇ; K
.
ÇÇK L

Expression
ÇÇL V
,
ÇÇV W
field
ÇÇX ]
)
ÇÇ] ^
,
ÇÇ^ _
_
ÉÉ 
=>
ÉÉ 
null
ÉÉ 
,
ÉÉ 
}
ÑÑ 	
;
ÑÑ	 

}
ÖÖ 
private
ÜÜ 

Expression
ÜÜ 
CreateMapperFunc
ÜÜ '
(
ÜÜ' (

Expression
ÜÜ( 2
assignmentFunc
ÜÜ3 A
)
ÜÜA B
{
áá 
var
àà 

mapperFunc
àà 
=
àà 
assignmentFunc
àà '
;
àà' (
var
ââ 
overMaxDepth
ââ 
=
ââ 
OverMaxDepth
ââ '
(
ââ' (
_typeMap
ââ( 0
)
ââ0 1
;
ââ1 2
if
ää 

(
ää 
overMaxDepth
ää 
!=
ää 
null
ää  
)
ää  !
{
ãã 	

mapperFunc
åå 
=
åå 
	Condition
åå "
(
åå" #
overMaxDepth
åå# /
,
åå/ 0
_configuration
åå1 ?
.
åå? @
Default
åå@ G
(
ååG H
DestinationType
ååH W
)
ååW X
,
ååX Y

mapperFunc
ååZ d
)
ååd e
;
ååe f
}
çç 	
return
éé "
CheckReferencesCache
éé #
(
éé# $

mapperFunc
éé$ .
)
éé. /
;
éé/ 0
}
èè 
private
êê 

Expression
êê "
CheckReferencesCache
êê +
(
êê+ ,

Expression
êê, 6
valueBuilder
êê7 C
)
êêC D
{
ëë 
if
íí 

(
íí
 
!
íí 
_typeMap
íí 
.
íí  
PreserveReferences
íí '
)
íí' (
{
ìì 	
return
îî 
valueBuilder
îî 
;
îî  
}
ïï 	
var
ññ "
getCachedDestination
ññ  
=
ññ! "
Call
ññ# '
(
ññ' (
ContextParameter
ññ( 8
,
ññ8 9"
GetDestinationMethod
ññ: N
,
ññN O
_source
ññP W
,
ññW X
Constant
ññY a
(
ñña b
DestinationType
ññb q
)
ññq r
)
ññr s
;
ññs t
return
óó 
Coalesce
óó 
(
óó 
ToType
óó 
(
óó "
getCachedDestination
óó 3
,
óó3 4
DestinationType
óó5 D
)
óóD E
,
óóE F
valueBuilder
óóG S
)
óóS T
;
óóT U
}
òò 
private
ôô 

Expression
ôô &
CreateNewDestinationFunc
ôô /
(
ôô/ 0
)
ôô0 1
=>
ôô2 4
_typeMap
ôô5 =
switch
ôô> D
{
öö 
{
õõ 	 
CustomCtorFunction
õõ
 
:
õõ 
LambdaExpression
õõ . 
constructUsingFunc
õõ/ A
}
õõB C
=>
õõD F
_configuration
õõG U
.
õõU V
ReplaceParameters
õõV g
(
õõg h 
constructUsingFunc
õõh z
,
õõz {
GetParametersõõ| â
(õõâ ä
secondõõä ê
:õõê ë 
ContextParameterõõí ¢
)õõ¢ £
)õõ£ §
,õõ§ •
{
úú 	
ConstructorMap
úú
 
:
úú 
{
úú 

CanResolve
úú &
:
úú& '
true
úú( ,
}
úú- .
constructorMap
úú/ =
}
úú> ?
=>
úú@ B 
ConstructorMapping
úúC U
(
úúU V
constructorMap
úúV d
)
úúd e
,
úúe f
{
ùù 	
DestinationType
ùù
 
:
ùù 
{
ùù 
IsInterface
ùù (
:
ùù( )
true
ùù* .
}
ùù/ 0
interfaceType
ùù1 >
}
ùù? @
=>
ùùA C
Throw
ùùD I
(
ùùI J
Constant
ùùJ R
(
ùùR S
new
ùùS V(
AutoMapperMappingException
ùùW q
(
ùùq r
$strùùr å
+ùùå ç
interfaceTypeùùç ö
,ùùö õ
nullùùú †
,ùù† °
_typeMapùù¢ ™
)ùù™ ´
)ùù´ ¨
,ùù¨ ≠
interfaceTypeùùÆ ª
)ùùª º
,ùùº Ω
_
ûû 	
=>
ûû
 
ObjectFactory
ûû 
.
ûû +
GenerateConstructorExpression
ûû 8
(
ûû8 9
DestinationType
ûû9 H
,
ûûH I
_configuration
ûûJ X
)
ûûX Y
}
üü 
;
üü 
private
†† 

Expression
††  
ConstructorMapping
†† )
(
††) *
ConstructorMap
††* 8
constructorMap
††9 G
)
††G H
{
°° 
List
¢¢ 
<
¢¢ !
ParameterExpression
¢¢  
>
¢¢  !
	variables
¢¢" +
=
¢¢, -
[
¢¢. /
]
¢¢/ 0
;
¢¢0 1
List
££ 
<
££ 

Expression
££ 
>
££ 
body
££ 
=
££ 
[
££  !
]
££! "
;
££" #
foreach
§§ 
(
§§ 
var
§§ 
	parameter
§§ 
in
§§ !
constructorMap
§§" 0
.
§§0 1

CtorParams
§§1 ;
)
§§; <
{
•• 	
var
¶¶ 
variable
¶¶ 
=
¶¶ 
Variable
¶¶ #
(
¶¶# $
	parameter
¶¶$ -
.
¶¶- .
DestinationType
¶¶. =
,
¶¶= >
	parameter
¶¶? H
.
¶¶H I
DestinationName
¶¶I X
)
¶¶X Y
;
¶¶Y Z
	variables
ßß 
.
ßß 
Add
ßß 
(
ßß 
variable
ßß "
)
ßß" #
;
ßß# $
body
®® 
.
®® 
Add
®® 
(
®® 
Assign
®® 
(
®® 
variable
®® $
,
®®$ %2
$CreateConstructorParameterExpression
®®& J
(
®®J K
	parameter
®®K T
)
®®T U
)
®®U V
)
®®V W
;
®®W X
}
©© 	
body
™™ 
.
™™ 
Add
™™ 
(
™™ "
CheckReferencesCache
™™ %
(
™™% &
New
™™& )
(
™™) *
constructorMap
™™* 8
.
™™8 9
Ctor
™™9 =
,
™™= >
	variables
™™? H
)
™™H I
)
™™I J
)
™™J K
;
™™K L
return
´´ 
Block
´´ 
(
´´ 
	variables
´´ 
,
´´ 
body
´´  $
)
´´$ %
;
´´% &
}
¨¨ 
private
≠≠ 

Expression
≠≠ 2
$CreateConstructorParameterExpression
≠≠ ;
(
≠≠; <%
ConstructorParameterMap
≠≠< S
ctorParamMap
≠≠T `
)
≠≠` a
{
ÆÆ 
var
ØØ 
defaultValue
ØØ 
=
ØØ 
ctorParamMap
ØØ '
.
ØØ' (
DefaultValue
ØØ( 4
(
ØØ4 5
_configuration
ØØ5 C
)
ØØC D
;
ØØD E
var
∞∞ 
customSource
∞∞ 
=
∞∞ 
GetCustomSource
∞∞ *
(
∞∞* +
ctorParamMap
∞∞+ 7
)
∞∞7 8
;
∞∞8 9
var
±±  
resolvedExpression
±± 
=
±±  $
BuildValueResolverFunc
±±! 7
(
±±7 8
ctorParamMap
±±8 D
,
±±D E
customSource
±±F R
,
±±R S
defaultValue
±±T `
)
±±` a
;
±±a b
var
≤≤ 
resolvedValue
≤≤ 
=
≤≤ 
Variable
≤≤ $
(
≤≤$ % 
resolvedExpression
≤≤% 7
.
≤≤7 8
Type
≤≤8 <
,
≤≤< =
$str
≤≤> M
)
≤≤M N
;
≤≤N O
var
≥≥ 
	mapMember
≥≥ 
=
≥≥ 
	MapMember
≥≥ !
(
≥≥! "
ctorParamMap
≥≥" .
,
≥≥. /
resolvedValue
≥≥0 =
,
≥≥= >
defaultValue
≥≥? K
)
≥≥K L
;
≥≥L M

_variables
¥¥ 
.
¥¥ 
Clear
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥ 

_variables
µµ 
.
µµ 
Add
µµ 
(
µµ 
resolvedValue
µµ $
)
µµ$ %
;
µµ% &
_expressions
∂∂ 
.
∂∂ 
Clear
∂∂ 
(
∂∂ 
)
∂∂ 
;
∂∂ 
_expressions
∑∑ 
.
∑∑ 
Add
∑∑ 
(
∑∑ 
Assign
∑∑ 
(
∑∑  
resolvedValue
∑∑  -
,
∑∑- . 
resolvedExpression
∑∑/ A
)
∑∑A B
)
∑∑B C
;
∑∑C D
_expressions
∏∏ 
.
∏∏ 
Add
∏∏ 
(
∏∏ 
	mapMember
∏∏ "
)
∏∏" #
;
∏∏# $
return
ππ 
TryMemberMap
ππ 
(
ππ 
ctorParamMap
ππ (
,
ππ( )
Block
ππ* /
(
ππ/ 0

_variables
ππ0 :
,
ππ: ;
_expressions
ππ< H
)
ππH I
)
ππI J
;
ππJ K
}
∫∫ 
private
ªª 

Expression
ªª 
TryMemberMap
ªª #
(
ªª# $
	MemberMap
ªª$ -
	memberMap
ªª. 7
,
ªª7 8

Expression
ªª9 C!
memberMapExpression
ªªD W
)
ªªW X
{
ºº 
var
ΩΩ 
newException
ΩΩ 
=
ΩΩ 
Call
ΩΩ 
(
ΩΩ  
MappingError
ΩΩ  ,
,
ΩΩ, - 
ExceptionParameter
ΩΩ. @
,
ΩΩ@ A
Constant
ΩΩB J
(
ΩΩJ K
	memberMap
ΩΩK T
)
ΩΩT U
)
ΩΩU V
;
ΩΩV W
_catches
ææ 
[
ææ 
$num
ææ 
]
ææ 
=
ææ 
Catch
ææ 
(
ææ  
ExceptionParameter
ææ .
,
ææ. /
Throw
ææ0 5
(
ææ5 6
newException
ææ6 B
,
ææB C!
memberMapExpression
ææD W
.
ææW X
Type
ææX \
)
ææ\ ]
)
ææ] ^
;
ææ^ _
return
øø 
TryCatch
øø 
(
øø !
memberMapExpression
øø +
,
øø+ ,
_catches
øø- 5
)
øø5 6
;
øø6 7
}
¿¿ 
private
¡¡ 

Expression
¡¡ #
CreatePropertyMapFunc
¡¡ ,
(
¡¡, -
	MemberMap
¡¡- 6
	memberMap
¡¡7 @
,
¡¡@ A

Expression
¡¡B L
destination
¡¡M X
,
¡¡X Y

MemberInfo
¡¡Z d
destinationMember
¡¡e v
)
¡¡v w
{
¬¬ 

Expression
√√ %
destinationMemberAccess
√√ *
,
√√* +%
destinationMemberGetter
√√, C
;
√√C D
bool
ƒƒ '
destinationMemberReadOnly
ƒƒ &
;
ƒƒ& '
if
≈≈ 

(
≈≈ 
destinationMember
≈≈ 
is
≈≈  
PropertyInfo
≈≈! -!
destinationProperty
≈≈. A
)
≈≈A B
{
∆∆ 	%
destinationMemberAccess
«« #
=
««$ %
Property
««& .
(
««. /
destination
««/ :
,
««: ;!
destinationProperty
««< O
)
««O P
;
««P Q'
destinationMemberReadOnly
»» %
=
»»& '
!
»»( )!
destinationProperty
»») <
.
»»< =
CanWrite
»»= E
;
»»E F%
destinationMemberGetter
…… #
=
……$ %!
destinationProperty
……& 9
.
……9 :
CanRead
……: A
?
……B C%
destinationMemberAccess
……D [
:
……\ ]
_configuration
……^ l
.
……l m
Default
……m t
(
……t u
	memberMap
……u ~
.
……~ 
DestinationType…… é
)……é è
;……è ê
}
   	
else
ÀÀ 
{
ÃÃ 	
var
ÕÕ 
destinationField
ÕÕ  
=
ÕÕ! "
(
ÕÕ# $
	FieldInfo
ÕÕ$ -
)
ÕÕ- .
destinationMember
ÕÕ. ?
;
ÕÕ? @%
destinationMemberAccess
ŒŒ #
=
ŒŒ$ %
Field
ŒŒ& +
(
ŒŒ+ ,
destination
ŒŒ, 7
,
ŒŒ7 8
destinationField
ŒŒ9 I
)
ŒŒI J
;
ŒŒJ K'
destinationMemberReadOnly
œœ %
=
œœ& '
destinationField
œœ( 8
.
œœ8 9

IsInitOnly
œœ9 C
;
œœC D%
destinationMemberGetter
–– #
=
––$ %%
destinationMemberAccess
––& =
;
––= >
}
—— 	
var
““ 
customSource
““ 
=
““ 
GetCustomSource
““ *
(
““* +
	memberMap
““+ 4
)
““4 5
;
““5 6
var
”” 
valueResolver
”” 
=
”” $
BuildValueResolverFunc
”” 2
(
””2 3
	memberMap
””3 <
,
””< =
customSource
””> J
,
””J K%
destinationMemberGetter
””L c
)
””c d
;
””d e
var
‘‘ #
resolvedValueVariable
‘‘ !
=
‘‘" #
Variable
‘‘$ ,
(
‘‘, -
valueResolver
‘‘- :
.
‘‘: ;
Type
‘‘; ?
,
‘‘? @
$str
‘‘A P
)
‘‘P Q
;
‘‘Q R
var
’’ $
destinationMemberValue
’’ "
=
’’# $$
DestinationMemberValue
’’% ;
(
’’; <
	memberMap
’’< E
,
’’E F%
destinationMemberGetter
’’G ^
,
’’^ _'
destinationMemberReadOnly
’’` y
)
’’y z
;
’’z {
var
÷÷ 
mappedMember
÷÷ 
=
÷÷ 
	MapMember
÷÷ $
(
÷÷$ %
	memberMap
÷÷% .
,
÷÷. /#
resolvedValueVariable
÷÷0 E
,
÷÷E F$
destinationMemberValue
÷÷G ]
)
÷÷] ^
;
÷÷^ _
var
◊◊ "
mappedMemberVariable
◊◊  
=
◊◊! "
SetVariables
◊◊# /
(
◊◊/ 0
valueResolver
◊◊0 =
,
◊◊= >#
resolvedValueVariable
◊◊? T
,
◊◊T U
mappedMember
◊◊V b
)
◊◊b c
;
◊◊c d
var
ÿÿ 

mapperExpr
ÿÿ 
=
ÿÿ '
destinationMemberReadOnly
ÿÿ 2
?
ÿÿ3 4
(
ÿÿ5 6

Expression
ÿÿ6 @
)
ÿÿ@ A"
mappedMemberVariable
ÿÿA U
:
ÿÿV W
Assign
ÿÿX ^
(
ÿÿ^ _%
destinationMemberAccess
ÿÿ_ v
,
ÿÿv w#
mappedMemberVariableÿÿx å
)ÿÿå ç
;ÿÿç é
if
ŸŸ 

(
ŸŸ 
	memberMap
ŸŸ 
.
ŸŸ 
	Condition
ŸŸ 
!=
ŸŸ  "
null
ŸŸ# '
)
ŸŸ' (
{
⁄⁄ 	
_expressions
€€ 
.
€€ 
Add
€€ 
(
€€ 
IfThen
€€ #
(
€€# $
_configuration
‹‹ 
.
‹‹ &
ConvertReplaceParameters
‹‹ 7
(
‹‹7 8
	memberMap
‹‹8 A
.
‹‹A B
	Condition
‹‹B K
,
‹‹K L
[
‹‹M N
customSource
‹‹N Z
,
‹‹Z [
_destination
‹‹\ h
,
‹‹h i"
mappedMemberVariable
‹‹j ~
,
‹‹~ '
destinationMemberGetter‹‹Ä ó
,‹‹ó ò 
ContextParameter‹‹ô ©
]‹‹© ™
)‹‹™ ´
,‹‹´ ¨

mapperExpr
›› 
)
›› 
)
›› 
;
›› 
}
ﬁﬁ 	
else
ﬂﬂ 
if
ﬂﬂ 
(
ﬂﬂ 
!
ﬂﬂ '
destinationMemberReadOnly
ﬂﬂ +
)
ﬂﬂ+ ,
{
‡‡ 	
_expressions
·· 
.
·· 
Add
·· 
(
·· 

mapperExpr
·· '
)
··' (
;
··( )
}
‚‚ 	
if
„„ 

(
„„ 
	memberMap
„„ 
.
„„ 
PreCondition
„„ "
!=
„„# %
null
„„& *
)
„„* +
{
‰‰ 	
Precondition
ÂÂ 
(
ÂÂ 
	memberMap
ÂÂ "
,
ÂÂ" #
customSource
ÂÂ$ 0
)
ÂÂ0 1
;
ÂÂ1 2
}
ÊÊ 	
return
ÁÁ 
Block
ÁÁ 
(
ÁÁ 

_variables
ÁÁ 
,
ÁÁ  
_expressions
ÁÁ! -
)
ÁÁ- .
;
ÁÁ. /
}
ËË 

Expression
ÈÈ $
DestinationMemberValue
ÈÈ %
(
ÈÈ% &
	MemberMap
ÈÈ& /
	memberMap
ÈÈ0 9
,
ÈÈ9 :

Expression
ÈÈ; E%
destinationMemberGetter
ÈÈF ]
,
ÈÈ] ^
bool
ÈÈ_ c'
destinationMemberReadOnly
ÈÈd }
)
ÈÈ} ~
{
ÍÍ 
if
ÎÎ 

(
ÎÎ '
destinationMemberReadOnly
ÎÎ %
||
ÎÎ& (
	memberMap
ÎÎ) 2
.
ÎÎ2 3!
UseDestinationValue
ÎÎ3 F
is
ÎÎG I
true
ÎÎJ N
)
ÎÎN O
{
ÏÏ 	
return
ÌÌ %
destinationMemberGetter
ÌÌ *
;
ÌÌ* +
}
ÓÓ 	
var
ÔÔ 
defaultValue
ÔÔ 
=
ÔÔ 
_configuration
ÔÔ )
.
ÔÔ) *
Default
ÔÔ* 1
(
ÔÔ1 2
	memberMap
ÔÔ2 ;
.
ÔÔ; <
DestinationType
ÔÔ< K
)
ÔÔK L
;
ÔÔL M
return
 
DestinationType
 
.
 
IsValueType
 *
?
+ ,
defaultValue
- 9
:
: ;
	Condition
< E
(
E F
ReferenceEqual
F T
(
T U!
_initialDestination
U h
,
h i
Null
j n
)
n o
,
o p
defaultValue
q }
,
} ~&
destinationMemberGetter ñ
)ñ ó
;ó ò
}
ÒÒ 
void
ÚÚ 
Precondition
ÚÚ	 
(
ÚÚ 
	MemberMap
ÚÚ 
	memberMap
ÚÚ  )
,
ÚÚ) *!
ParameterExpression
ÚÚ+ >
customSource
ÚÚ? K
)
ÚÚK L
{
ÛÛ 
var
ÙÙ 
preCondition
ÙÙ 
=
ÙÙ 
_configuration
ÙÙ )
.
ÙÙ) *&
ConvertReplaceParameters
ÙÙ* B
(
ÙÙB C
	memberMap
ÙÙC L
.
ÙÙL M
PreCondition
ÙÙM Y
,
ÙÙY Z
GetParameters
ÙÙ[ h
(
ÙÙh i
first
ÙÙi n
:
ÙÙn o
customSource
ÙÙp |
)
ÙÙ| }
)
ÙÙ} ~
;
ÙÙ~ 
var
ıı 
ifThen
ıı 
=
ıı 
IfThen
ıı 
(
ıı 
preCondition
ıı (
,
ıı( )
Block
ıı* /
(
ıı/ 0
_expressions
ıı0 <
)
ıı< =
)
ıı= >
;
ıı> ?
_expressions
ˆˆ 
.
ˆˆ 
Clear
ˆˆ 
(
ˆˆ 
)
ˆˆ 
;
ˆˆ 
_expressions
˜˜ 
.
˜˜ 
Add
˜˜ 
(
˜˜ 
ifThen
˜˜ 
)
˜˜  
;
˜˜  !
}
¯¯ !
ParameterExpression
˘˘ 
SetVariables
˘˘ $
(
˘˘$ %

Expression
˘˘% /
valueResolver
˘˘0 =
,
˘˘= >!
ParameterExpression
˘˘? R#
resolvedValueVariable
˘˘S h
,
˘˘h i

Expression
˘˘j t
mappedMember˘˘u Å
)˘˘Å Ç
{
˙˙ 
_expressions
˚˚ 
.
˚˚ 
Clear
˚˚ 
(
˚˚ 
)
˚˚ 
;
˚˚ 

_variables
¸¸ 
.
¸¸ 
Clear
¸¸ 
(
¸¸ 
)
¸¸ 
;
¸¸ 

_variables
˝˝ 
.
˝˝ 
Add
˝˝ 
(
˝˝ #
resolvedValueVariable
˝˝ ,
)
˝˝, -
;
˝˝- .
_expressions
˛˛ 
.
˛˛ 
Add
˛˛ 
(
˛˛ 
Assign
˛˛ 
(
˛˛  #
resolvedValueVariable
˛˛  5
,
˛˛5 6
valueResolver
˛˛7 D
)
˛˛D E
)
˛˛E F
;
˛˛F G!
ParameterExpression
ˇˇ "
mappedMemberVariable
ˇˇ 0
;
ˇˇ0 1
if
ÄÄ 

(
ÄÄ 
mappedMember
ÄÄ 
==
ÄÄ #
resolvedValueVariable
ÄÄ 1
)
ÄÄ1 2
{
ÅÅ 	"
mappedMemberVariable
ÇÇ  
=
ÇÇ! "#
resolvedValueVariable
ÇÇ# 8
;
ÇÇ8 9
}
ÉÉ 	
else
ÑÑ 
{
ÖÖ 	"
mappedMemberVariable
ÜÜ  
=
ÜÜ! "
Variable
ÜÜ# +
(
ÜÜ+ ,
mappedMember
ÜÜ, 8
.
ÜÜ8 9
Type
ÜÜ9 =
,
ÜÜ= >
$str
ÜÜ? L
)
ÜÜL M
;
ÜÜM N

_variables
áá 
.
áá 
Add
áá 
(
áá "
mappedMemberVariable
áá /
)
áá/ 0
;
áá0 1
_expressions
àà 
.
àà 
Add
àà 
(
àà 
Assign
àà #
(
àà# $"
mappedMemberVariable
àà$ 8
,
àà8 9
mappedMember
àà: F
)
ààF G
)
ààG H
;
ààH I
}
ââ 	
return
ää "
mappedMemberVariable
ää #
;
ää# $
}
ãã 

Expression
åå 
	MapMember
åå 
(
åå 
	MemberMap
åå "
	memberMap
åå# ,
,
åå, -!
ParameterExpression
åå. A
resolvedValue
ååB O
,
ååO P

Expression
ååQ [$
destinationMemberValue
åå\ r
)
åår s
{
çç 
var
éé 
typePair
éé 
=
éé 
	memberMap
éé  
.
éé  !
Types
éé! &
(
éé& '
)
éé' (
;
éé( )
var
èè 
profile
èè 
=
èè 
_typeMap
èè 
.
èè 
Profile
èè &
;
èè& '
var
êê 
	mapMember
êê 
=
êê 
	memberMap
êê !
.
êê! "
Inline
êê" (
?
êê) *
_configuration
ëë 
.
ëë 
MapExpression
ëë (
(
ëë( )
profile
ëë) 0
,
ëë0 1
typePair
ëë2 :
,
ëë: ;
resolvedValue
ëë< I
,
ëëI J
	memberMap
ëëK T
,
ëëT U$
destinationMemberValue
ëëV l
)
ëël m
:
ëën o
_configuration
íí 
.
íí 
NullCheckSource
íí *
(
íí* +
profile
íí+ 2
,
íí2 3
resolvedValue
íí4 A
,
ííA B$
destinationMemberValue
ííC Y
,
ííY Z

ContextMap
íí[ e
(
ííe f
typePair
ííf n
,
íín o
resolvedValue
ííp }
,
íí} ~%
destinationMemberValueíí ï
,ííï ñ
	memberMapííó †
)íí† °
,íí° ¢
	memberMapíí£ ¨
)íí¨ ≠
;íí≠ Æ
return
ìì 
	memberMap
ìì 
.
ìì 
ApplyTransformers
ìì *
(
ìì* +
	mapMember
ìì+ 4
,
ìì4 5
_configuration
ìì6 D
)
ììD E
;
ììE F
}
îî 
private
ïï 

Expression
ïï $
BuildValueResolverFunc
ïï -
(
ïï- .
	MemberMap
ïï. 7
	memberMap
ïï8 A
,
ïïA B

Expression
ïïC M
customSource
ïïN Z
,
ïïZ [

Expression
ïï\ f
destValueExpr
ïïg t
)
ïït u
{
ññ 
var
óó 
valueResolverFunc
óó 
=
óó 
	memberMap
óó  )
.
óó) *
Resolver
óó* 2
?
óó2 3
.
óó3 4
GetExpression
óó4 A
(
óóA B
_configuration
óóB P
,
óóP Q
	memberMap
óóR [
,
óó[ \
customSource
óó] i
,
óói j
_destination
óók w
,
óów x
destValueExpróóy Ü
)óóÜ á
??óóà ä
destValueExpróóã ò
;óóò ô
if
òò 

(
òò 
	memberMap
òò 
.
òò 
NullSubstitute
òò $
!=
òò% '
null
òò( ,
)
òò, -
{
ôô 	
valueResolverFunc
öö 
=
öö 
	memberMap
öö  )
.
öö) *
NullSubstitute
öö* 8
(
öö8 9
valueResolverFunc
öö9 J
)
ööJ K
;
ööK L
}
õõ 	
else
úú 
if
úú 
(
úú 
!
úú 
	memberMap
úú 
.
úú )
AllowsNullDestinationValues
úú 7
)
úú7 8
{
ùù 	
var
ûû 
toCreate
ûû 
=
ûû 
	memberMap
ûû $
.
ûû$ %

SourceType
ûû% /
;
ûû/ 0
if
üü 
(
üü 
!
üü 
toCreate
üü 
.
üü 

IsAbstract
üü $
&&
üü% '
toCreate
üü( 0
.
üü0 1
IsClass
üü1 8
&&
üü9 ;
!
üü< =
toCreate
üü= E
.
üüE F
IsArray
üüF M
)
üüM N
{
†† 
var
°° 
ctor
°° 
=
°° 
ObjectFactory
°° (
.
°°( )+
GenerateConstructorExpression
°°) F
(
°°F G
toCreate
°°G O
,
°°O P
_configuration
°°Q _
)
°°_ `
;
°°` a
valueResolverFunc
¢¢ !
=
¢¢" #
Coalesce
¢¢$ ,
(
¢¢, -
valueResolverFunc
¢¢- >
,
¢¢> ?
ToType
¢¢@ F
(
¢¢F G
ctor
¢¢G K
,
¢¢K L
valueResolverFunc
¢¢M ^
.
¢¢^ _
Type
¢¢_ c
)
¢¢c d
)
¢¢d e
;
¢¢e f
}
££ 
}
§§ 	
return
•• 
valueResolverFunc
••  
;
••  !
}
¶¶ 
private
ßß !
ParameterExpression
ßß 
GetCustomSource
ßß  /
(
ßß/ 0
	MemberMap
ßß0 9
	memberMap
ßß: C
)
ßßC D
=>
ßßE G
	memberMap
ßßH Q
.
ßßQ R
IncludedMember
ßßR `
?
ßß` a
.
ßßa b
Variable
ßßb j
??
ßßk m
_source
ßßn u
;
ßßu v
}®® 
public©© 
	interface
©© 
IValueResolver
©© 
{™™ 

Expression
´´ 
GetExpression
´´ 
(
´´ "
IGlobalConfiguration
´´ 1
configuration
´´2 ?
,
´´? @
	MemberMap
´´A J
	memberMap
´´K T
,
´´T U

Expression
´´V `
source
´´a g
,
´´g h

Expression
´´i s
destination
´´t 
,´´ Ä

Expression´´Å ã!
destinationMember´´å ù
)´´ù û
;´´û ü

MemberInfo
¨¨ 
GetSourceMember
¨¨ 
(
¨¨ 
	MemberMap
¨¨ (
	memberMap
¨¨) 2
)
¨¨2 3
;
¨¨3 4
Type
≠≠ 
ResolvedType
≠≠	 
{
≠≠ 
get
≠≠ 
;
≠≠ 
}
≠≠ 
string
ÆÆ 

SourceMemberName
ÆÆ 
=>
ÆÆ 
null
ÆÆ #
;
ÆÆ# $
LambdaExpression
ØØ !
ProjectToExpression
ØØ (
=>
ØØ) +
null
ØØ, 0
;
ØØ0 1
IValueResolver
∞∞ 
CloseGenerics
∞∞  
(
∞∞  !
TypeMap
∞∞! (
typeMap
∞∞) 0
)
∞∞0 1
=>
∞∞2 4
this
∞∞5 9
;
∞∞9 :
}±± 
public≤≤ 
class
≤≤  
MemberPathResolver
≤≤ 
(
≤≤  

MemberInfo
≤≤  *
[
≤≤* +
]
≤≤+ ,
members
≤≤- 4
)
≤≤4 5
:
≤≤6 7
IValueResolver
≤≤8 F
{≥≥ 
private
¥¥ 
readonly
¥¥ 

MemberInfo
¥¥ 
[
¥¥  
]
¥¥  !
_members
¥¥" *
=
¥¥+ ,
members
¥¥- 4
;
¥¥4 5
public
µµ 

Type
µµ 
ResolvedType
µµ 
=>
µµ 
_members
µµ  (
?
µµ( )
[
µµ) *
^
µµ* +
$num
µµ+ ,
]
µµ, -
.
µµ- .
GetMemberType
µµ. ;
(
µµ; <
)
µµ< =
;
µµ= >
public
∂∂ 


Expression
∂∂ 
GetExpression
∂∂ #
(
∂∂# $"
IGlobalConfiguration
∂∂$ 8
configuration
∂∂9 F
,
∂∂F G
	MemberMap
∂∂H Q
	memberMap
∂∂R [
,
∂∂[ \

Expression
∂∂] g
source
∂∂h n
,
∂∂n o

Expression
∂∂p z
destination∂∂{ Ü
,∂∂Ü á

Expression∂∂à í!
destinationMember∂∂ì §
)∂∂§ •
{
∑∑ 
var
∏∏ 

expression
∏∏ 
=
∏∏ 
_members
∏∏ !
.
∏∏! "
Chain
∏∏" '
(
∏∏' (
source
∏∏( .
)
∏∏. /
;
∏∏/ 0
return
ππ 
	memberMap
ππ 
.
ππ 
IncludedMember
ππ '
==
ππ( *
null
ππ+ /
&&
ππ0 2
_members
ππ3 ;
.
ππ; <
Length
ππ< B
<
ππC D
$num
ππE F
?
ππG H

expression
ππI S
:
ππT U

expression
ππV `
.
ππ` a
	NullCheck
ππa j
(
ππj k
configuration
ππk x
,
ππx y
	memberMapππz É
,ππÉ Ñ!
destinationMemberππÖ ñ
)ππñ ó
;ππó ò
}
∫∫ 
public
ªª 


MemberInfo
ªª 
GetSourceMember
ªª %
(
ªª% &
	MemberMap
ªª& /
	memberMap
ªª0 9
)
ªª9 :
=>
ªª; =
_members
ªª> F
.
ªªF G
Length
ªªG M
==
ªªN P
$num
ªªQ R
?
ªªS T
_members
ªªU ]
[
ªª] ^
$num
ªª^ _
]
ªª_ `
:
ªªa b
null
ªªc g
;
ªªg h
public
ºº 

LambdaExpression
ºº !
ProjectToExpression
ºº /
=>
ºº0 2
_members
ºº3 ;
.
ºº; <
Lambda
ºº< B
(
ººB C
)
ººC D
;
ººD E
public
ΩΩ 

IValueResolver
ΩΩ 
CloseGenerics
ΩΩ '
(
ΩΩ' (
TypeMap
ΩΩ( /
typeMap
ΩΩ0 7
)
ΩΩ7 8
=>
ΩΩ9 ;
_members
ΩΩ< D
[
ΩΩD E
$num
ΩΩE F
]
ΩΩF G
.
ΩΩG H
DeclaringType
ΩΩH U
.
ΩΩU V'
ContainsGenericParameters
ΩΩV o
?
ΩΩp q
new
ææ  
MemberPathResolver
ææ 
(
ææ 
ReflectionHelper
ææ /
.
ææ/ 0
GetMemberPath
ææ0 =
(
ææ= >
typeMap
ææ> E
.
ææE F

SourceType
ææF P
,
ææP Q
Array
ææR W
.
ææW X

ConvertAll
ææX b
(
ææb c
_members
ææc k
,
ææk l
m
ææm n
=>
ææo q
m
æær s
.
ææs t
Name
ææt x
)
ææx y
,
ææy z
typeMapææ{ Ç
)ææÇ É
)ææÉ Ñ
:ææÖ Ü
thisææá ã
;ææã å
}øø 
public¿¿ 
abstract
¿¿ 
class
¿¿ !
LambdaValueResolver
¿¿ )
(
¿¿) *
LambdaExpression
¿¿* :
lambda
¿¿; A
)
¿¿A B
{¡¡ 
public
¬¬ 

LambdaExpression
¬¬ 
Lambda
¬¬ "
{
¬¬# $
get
¬¬% (
;
¬¬( )
}
¬¬* +
=
¬¬, -
lambda
¬¬. 4
;
¬¬4 5
public
√√ 

Type
√√ 
ResolvedType
√√ 
=>
√√ 
Lambda
√√  &
.
√√& '

ReturnType
√√' 1
;
√√1 2
}ƒƒ 
public≈≈ 
class
≈≈ 
FuncResolver
≈≈ 
(
≈≈ 
LambdaExpression
≈≈ *
lambda
≈≈+ 1
)
≈≈1 2
:
≈≈3 4!
LambdaValueResolver
≈≈5 H
(
≈≈H I
lambda
≈≈I O
)
≈≈O P
,
≈≈P Q
IValueResolver
≈≈R `
{∆∆ 
public
«« 


Expression
«« 
GetExpression
«« #
(
««# $"
IGlobalConfiguration
««$ 8
configuration
««9 F
,
««F G
	MemberMap
««H Q
	memberMap
««R [
,
««[ \

Expression
««] g
source
««h n
,
««n o

Expression
««p z
destination««{ Ü
,««Ü á

Expression««à í!
destinationMember««ì §
)««§ •
=>««¶ ®
configuration
»» 
.
»» &
ConvertReplaceParameters
»» .
(
»». /
Lambda
»»/ 5
,
»»5 6
[
»»7 8
source
»»8 >
,
»»> ?
destination
»»@ K
,
»»K L
destinationMember
»»M ^
,
»»^ _
ContextParameter
»»` p
]
»»p q
)
»»q r
;
»»r s
public
…… 


MemberInfo
…… 
GetSourceMember
…… %
(
……% &
	MemberMap
……& /
_
……0 1
)
……1 2
=>
……3 5
null
……6 :
;
……: ;
}   
publicÀÀ 
class
ÀÀ  
ExpressionResolver
ÀÀ 
(
ÀÀ  
LambdaExpression
ÀÀ  0
lambda
ÀÀ1 7
)
ÀÀ7 8
:
ÀÀ9 :!
LambdaValueResolver
ÀÀ; N
(
ÀÀN O
lambda
ÀÀO U
)
ÀÀU V
,
ÀÀV W
IValueResolver
ÀÀX f
{ÃÃ 
public
ÕÕ 


Expression
ÕÕ 
GetExpression
ÕÕ #
(
ÕÕ# $"
IGlobalConfiguration
ÕÕ$ 8
configuration
ÕÕ9 F
,
ÕÕF G
	MemberMap
ÕÕH Q
	memberMap
ÕÕR [
,
ÕÕ[ \

Expression
ÕÕ] g
source
ÕÕh n
,
ÕÕn o

Expression
ÕÕp z
_
ÕÕ{ |
,
ÕÕ| }

ExpressionÕÕ~ à!
destinationMemberÕÕâ ö
)ÕÕö õ
{
ŒŒ 
var
œœ 
mapFrom
œœ 
=
œœ 
configuration
œœ #
.
œœ# $
ReplaceParameters
œœ$ 5
(
œœ5 6
Lambda
œœ6 <
,
œœ< =
source
œœ> D
)
œœD E
;
œœE F
var
–– #
nullCheckedExpression
–– !
=
––" #
mapFrom
––$ +
.
––+ ,
	NullCheck
––, 5
(
––5 6
configuration
––6 C
,
––C D
	memberMap
––E N
,
––N O
destinationMember
––P a
)
––a b
;
––b c
if
—— 

(
—— #
nullCheckedExpression
—— !
!=
——" $
mapFrom
——% ,
)
——, -
{
““ 	
return
”” #
nullCheckedExpression
”” (
;
””( )
}
‘‘ 	
var
’’ 
defaultExpression
’’ 
=
’’ 
configuration
’’  -
.
’’- .
Default
’’. 5
(
’’5 6
mapFrom
’’6 =
.
’’= >
Type
’’> B
)
’’B C
;
’’C D
return
÷÷ 
TryCatch
÷÷ 
(
÷÷ 
mapFrom
÷÷ 
,
÷÷  
Catch
÷÷! &
(
÷÷& '
typeof
÷÷' -
(
÷÷- .$
NullReferenceException
÷÷. D
)
÷÷D E
,
÷÷E F
defaultExpression
÷÷G X
)
÷÷X Y
,
÷÷Y Z
Catch
÷÷[ `
(
÷÷` a
typeof
÷÷a g
(
÷÷g h#
ArgumentNullException
÷÷h }
)
÷÷} ~
,
÷÷~ !
defaultExpression÷÷Ä ë
)÷÷ë í
)÷÷í ì
;÷÷ì î
}
◊◊ 
public
ÿÿ 


MemberInfo
ÿÿ 
GetSourceMember
ÿÿ %
(
ÿÿ% &
	MemberMap
ÿÿ& /
_
ÿÿ0 1
)
ÿÿ1 2
=>
ÿÿ3 5
Lambda
ÿÿ6 <
.
ÿÿ< =
	GetMember
ÿÿ= F
(
ÿÿF G
)
ÿÿG H
;
ÿÿH I
public
ŸŸ 

LambdaExpression
ŸŸ !
ProjectToExpression
ŸŸ /
=>
ŸŸ0 2
Lambda
ŸŸ3 9
;
ŸŸ9 :
}⁄⁄ 
[€€ 
EditorBrowsable
€€ 
(
€€ "
EditorBrowsableState
€€ %
.
€€% &
Never
€€& +
)
€€+ ,
]
€€, -
public‹‹ 
abstract
‹‹ 
class
‹‹ !
ValueResolverConfig
‹‹ )
(
‹‹) *
Type
‹‹* .
concreteType
‹‹/ ;
,
‹‹; <
Type
‹‹= A
interfaceType
‹‹B O
,
‹‹O P

Expression
‹‹Q [
instance
‹‹\ d
,
‹‹d e
string
‹‹f l
sourceMemberName
‹‹m }
)
‹‹} ~
{›› 
private
ﬁﬁ 
	protected
ﬁﬁ 
readonly
ﬁﬁ 

Expression
ﬁﬁ )
	_instance
ﬁﬁ* 3
=
ﬁﬁ4 5
instance
ﬁﬁ6 >
;
ﬁﬁ> ?
public
ﬂﬂ 

Type
ﬂﬂ 
ConcreteType
ﬂﬂ 
{
ﬂﬂ 
get
ﬂﬂ "
;
ﬂﬂ" #
}
ﬂﬂ$ %
=
ﬂﬂ& '
concreteType
ﬂﬂ( 4
;
ﬂﬂ4 5
public
‡‡ 

Type
‡‡ 
InterfaceType
‡‡ 
{
‡‡ 
get
‡‡  #
;
‡‡# $
}
‡‡% &
=
‡‡' (
interfaceType
‡‡) 6
;
‡‡6 7
public
·· 

LambdaExpression
··  
SourceMemberLambda
·· .
{
··/ 0
get
··1 4
;
··4 5
init
··6 :
;
··: ;
}
··< =
	protected
‚‚ !
ValueResolverConfig
‚‚ !
(
‚‚! "
object
‚‚" (
instance
‚‚) 1
,
‚‚1 2
Type
‚‚3 7
interfaceType
‚‚8 E
,
‚‚E F
string
‚‚G M
sourceMemberName
‚‚N ^
)
‚‚^ _
:
‚‚` a
this
‚‚b f
(
‚‚f g
null
‚‚g k
,
‚‚k l
interfaceType
‚‚m z
,
‚‚z {
Constant‚‚| Ñ
(‚‚Ñ Ö
instance‚‚Ö ç
)‚‚ç é
,‚‚é è 
sourceMemberName‚‚ê †
)‚‚† °
{‚‚¢ £
}‚‚§ •
public
„„ 

string
„„ 
SourceMemberName
„„ "
{
„„# $
get
„„% (
;
„„( )
}
„„* +
=
„„, -
sourceMemberName
„„. >
;
„„> ?
public
‰‰ 

Type
‰‰ 
ResolvedType
‰‰ 
=>
‰‰ 
InterfaceType
‰‰  -
.
‰‰- ."
GenericTypeArguments
‰‰. B
[
‰‰B C
^
‰‰C D
$num
‰‰D E
]
‰‰E F
;
‰‰F G
}ÂÂ 
[ÊÊ 
EditorBrowsable
ÊÊ 
(
ÊÊ "
EditorBrowsableState
ÊÊ %
.
ÊÊ% &
Never
ÊÊ& +
)
ÊÊ+ ,
]
ÊÊ, -
publicÁÁ 
class
ÁÁ 
ValueConverter
ÁÁ 
:
ÁÁ !
ValueResolverConfig
ÁÁ 1
,
ÁÁ1 2
IValueResolver
ÁÁ3 A
{ËË 
public
ÈÈ 

ValueConverter
ÈÈ 
(
ÈÈ 
Type
ÈÈ 
concreteType
ÈÈ +
,
ÈÈ+ ,
Type
ÈÈ- 1
interfaceType
ÈÈ2 ?
,
ÈÈ? @
string
ÈÈA G
sourceMemberName
ÈÈH X
)
ÈÈX Y
:
ÈÈZ [
base
ÈÈ\ `
(
ÈÈ` a
concreteType
ÈÈa m
,
ÈÈm n
interfaceType
ÈÈo |
,
ÈÈ| }
ServiceLocatorÈÈ~ å
(ÈÈå ç
concreteTypeÈÈç ô
)ÈÈô ö
,ÈÈö õ 
sourceMemberNameÈÈú ¨
)ÈÈ¨ ≠
{ÈÈÆ Ø
}ÈÈ∞ ±
public
ÍÍ 

ValueConverter
ÍÍ 
(
ÍÍ 
object
ÍÍ  
instance
ÍÍ! )
,
ÍÍ) *
Type
ÍÍ+ /
interfaceType
ÍÍ0 =
,
ÍÍ= >
string
ÍÍ? E
sourceMemberName
ÍÍF V
)
ÍÍV W
:
ÍÍX Y
base
ÍÍZ ^
(
ÍÍ^ _
instance
ÍÍ_ g
,
ÍÍg h
interfaceType
ÍÍi v
,
ÍÍv w
sourceMemberNameÍÍx à
)ÍÍà â
{ÍÍä ã
}ÍÍå ç
public
ÎÎ 


Expression
ÎÎ 
GetExpression
ÎÎ #
(
ÎÎ# $"
IGlobalConfiguration
ÎÎ$ 8
configuration
ÎÎ9 F
,
ÎÎF G
	MemberMap
ÎÎH Q
	memberMap
ÎÎR [
,
ÎÎ[ \

Expression
ÎÎ] g
source
ÎÎh n
,
ÎÎn o

Expression
ÎÎp z
_
ÎÎ{ |
,
ÎÎ| }

ExpressionÎÎ~ à!
destinationMemberÎÎâ ö
)ÎÎö õ
{
ÏÏ 
var
ÌÌ 
sourceMemberType
ÌÌ 
=
ÌÌ 
InterfaceType
ÌÌ ,
.
ÌÌ, -"
GenericTypeArguments
ÌÌ- A
[
ÌÌA B
$num
ÌÌB C
]
ÌÌC D
;
ÌÌD E
var
ÓÓ 
sourceMember
ÓÓ 
=
ÓÓ 
this
ÓÓ 
switch
ÓÓ  &
{
ÔÔ 	
{
  
SourceMemberLambda
  
:
  !
{
" #
}
$ %
}
& '
=>
( *
configuration
+ 8
.
8 9
ReplaceParameters
9 J
(
J K 
SourceMemberLambda
K ]
,
] ^
source
_ e
)
e f
,
f g
{
ÒÒ 
SourceMemberName
ÒÒ 
:
ÒÒ 
{
ÒÒ  !
}
ÒÒ" #
}
ÒÒ$ %
=>
ÒÒ& (
PropertyOrField
ÒÒ) 8
(
ÒÒ8 9
source
ÒÒ9 ?
,
ÒÒ? @
SourceMemberName
ÒÒA Q
)
ÒÒQ R
,
ÒÒR S
_
ÚÚ 
when
ÚÚ 
	memberMap
ÚÚ 
.
ÚÚ 
SourceMembers
ÚÚ *
.
ÚÚ* +
Length
ÚÚ+ 1
>
ÚÚ2 3
$num
ÚÚ4 5
=>
ÚÚ6 8
	memberMap
ÚÚ9 B
.
ÚÚB C 
ChainSourceMembers
ÚÚC U
(
ÚÚU V
configuration
ÚÚV c
,
ÚÚc d
source
ÚÚe k
,
ÚÚk l
destinationMember
ÚÚm ~
)
ÚÚ~ 
,ÚÚ Ä
_
ÛÛ 
=>
ÛÛ 
Throw
ÛÛ 
(
ÛÛ 
Constant
ÛÛ 
(
ÛÛ  #
BuildExceptionMessage
ÛÛ  5
(
ÛÛ5 6
)
ÛÛ6 7
)
ÛÛ7 8
,
ÛÛ8 9
sourceMemberType
ÛÛ: J
)
ÛÛJ K
}
ÙÙ 	
;
ÙÙ	 

return
ıı 
Call
ıı 
(
ıı 
ToType
ıı 
(
ıı 
	_instance
ıı $
,
ıı$ %
InterfaceType
ıı& 3
)
ıı3 4
,
ıı4 5
InterfaceType
ıı6 C
.
ııC D
	GetMethod
ııD M
(
ııM N
$str
ııN W
)
ııW X
,
ııX Y
ToType
ııZ `
(
ıı` a
sourceMember
ııa m
,
ıım n
sourceMemberType
ııo 
)ıı Ä
,ııÄ Å 
ContextParameterııÇ í
)ııí ì
;ııì î.
 AutoMapperConfigurationException
ˆˆ (#
BuildExceptionMessage
ˆˆ) >
(
ˆˆ> ?
)
ˆˆ? @
=>
˜˜ 
new
˜˜ 
(
˜˜ 
$"
˜˜ 
$str
˜˜ X
{
˜˜X Y
ConcreteType
˜˜Y e
}
˜˜e f
$str˜˜f é
"˜˜é è
)˜˜è ê
;˜˜ê ë
}
¯¯ 
public
˘˘ 


MemberInfo
˘˘ 
GetSourceMember
˘˘ %
(
˘˘% &
	MemberMap
˘˘& /
	memberMap
˘˘0 9
)
˘˘9 :
=>
˘˘; =
this
˘˘> B
switch
˘˘C I
{
˙˙ 
{
˚˚ 	 
SourceMemberLambda
˚˚
 
:
˚˚ 
{
˚˚ 
}
˚˚  !
lambda
˚˚" (
}
˚˚) *
=>
˚˚+ -
lambda
˚˚. 4
.
˚˚4 5
	GetMember
˚˚5 >
(
˚˚> ?
)
˚˚? @
,
˚˚@ A
{
¸¸ 	
SourceMemberName
¸¸
 
:
¸¸ 
{
¸¸ 
}
¸¸ 
}
¸¸  !
=>
¸¸" $
null
¸¸% )
,
¸¸) *
_
˝˝ 	
=>
˝˝
 
	memberMap
˝˝ 
.
˝˝ 
SourceMembers
˝˝ $
.
˝˝$ %
Length
˝˝% +
==
˝˝, .
$num
˝˝/ 0
?
˝˝1 2
	memberMap
˝˝3 <
.
˝˝< =
SourceMembers
˝˝= J
[
˝˝J K
$num
˝˝K L
]
˝˝L M
:
˝˝N O
null
˝˝P T
}
˛˛ 
;
˛˛ 
}ˇˇ 
[ÄÄ 
EditorBrowsable
ÄÄ 
(
ÄÄ "
EditorBrowsableState
ÄÄ %
.
ÄÄ% &
Never
ÄÄ& +
)
ÄÄ+ ,
]
ÄÄ, -
publicÅÅ 
class
ÅÅ  
ClassValueResolver
ÅÅ 
:
ÅÅ  !!
ValueResolverConfig
ÅÅ" 5
,
ÅÅ5 6
IValueResolver
ÅÅ7 E
{ÇÇ 
public
ÉÉ 
 
ClassValueResolver
ÉÉ 
(
ÉÉ 
Type
ÉÉ "
concreteType
ÉÉ# /
,
ÉÉ/ 0
Type
ÉÉ1 5
interfaceType
ÉÉ6 C
,
ÉÉC D
string
ÉÉE K
sourceMemberName
ÉÉL \
=
ÉÉ] ^
null
ÉÉ_ c
)
ÉÉc d
:
ÉÉe f
base
ÉÉg k
(
ÉÉk l
concreteType
ÉÉl x
,
ÉÉx y
interfaceTypeÉÉz á
,ÉÉá à
nullÉÉâ ç
,ÉÉç é 
sourceMemberNameÉÉè ü
)ÉÉü †
{ÉÉ° ¢
}ÉÉ£ §
public
ÑÑ 
 
ClassValueResolver
ÑÑ 
(
ÑÑ 
object
ÑÑ $
instance
ÑÑ% -
,
ÑÑ- .
Type
ÑÑ/ 3
interfaceType
ÑÑ4 A
,
ÑÑA B
string
ÑÑC I
sourceMemberName
ÑÑJ Z
=
ÑÑ[ \
null
ÑÑ] a
)
ÑÑa b
:
ÑÑc d
base
ÑÑe i
(
ÑÑi j
instance
ÑÑj r
,
ÑÑr s
interfaceTypeÑÑt Å
,ÑÑÅ Ç 
sourceMemberNameÑÑÉ ì
)ÑÑì î
{ÑÑï ñ
}ÑÑó ò
public
ÖÖ 


Expression
ÖÖ 
GetExpression
ÖÖ #
(
ÖÖ# $"
IGlobalConfiguration
ÖÖ$ 8
configuration
ÖÖ9 F
,
ÖÖF G
	MemberMap
ÖÖH Q
	memberMap
ÖÖR [
,
ÖÖ[ \

Expression
ÖÖ] g
source
ÖÖh n
,
ÖÖn o

Expression
ÖÖp z
destinationÖÖ{ Ü
,ÖÖÜ á

ExpressionÖÖà í!
destinationMemberÖÖì §
)ÖÖ§ •
{
ÜÜ 
var
áá 
typeMap
áá 
=
áá 
	memberMap
áá 
.
áá  
TypeMap
áá  '
;
áá' (
var
àà 
resolverInstance
àà 
=
àà 
	_instance
àà (
??
àà) +
ServiceLocator
àà, :
(
àà: ;
typeMap
àà; B
.
ààB C
MakeGenericType
ààC R
(
ààR S
ConcreteType
ààS _
)
àà_ `
)
àà` a
;
ààa b

Expression
ââ 
sourceMember
ââ 
;
ââ  
if
ää 

(
ää  
SourceMemberLambda
ää 
==
ää !
null
ää" &
)
ää& '
{
ãã 	
sourceMember
åå 
=
åå 
SourceMemberName
åå +
==
åå, .
null
åå/ 3
?
åå4 5
null
åå6 :
:
åå; <
PropertyOrField
åå= L
(
ååL M
source
ååM S
,
ååS T
SourceMemberName
ååU e
)
ååe f
;
ååf g
}
çç 	
else
éé 
{
èè 	
sourceMember
êê 
=
êê 
configuration
êê (
.
êê( )
ReplaceParameters
êê) :
(
êê: ; 
SourceMemberLambda
êê; M
,
êêM N
source
êêO U
)
êêU V
;
êêV W
}
ëë 	
var
íí 
iValueResolver
íí 
=
íí 
InterfaceType
íí *
;
íí* +
if
ìì 

(
ìì 
iValueResolver
ìì 
.
ìì '
ContainsGenericParameters
ìì 4
)
ìì4 5
{
îî 	
var
ïï 
typeArgs
ïï 
=
ïï 
iValueResolver
ññ 
.
ññ "
GenericTypeArguments
ññ 3
.
ññ3 4
Zip
ññ4 7
(
ññ7 8
new
ññ8 ;
[
ññ; <
]
ññ< =
{
ññ> ?
typeMap
ññ@ G
.
ññG H

SourceType
ññH R
,
ññR S
typeMap
ññT [
.
ññ[ \
DestinationType
ññ\ k
,
ññk l
sourceMember
ññm y
?
ññy z
.
ññz {
Type
ññ{ 
,ññ Ä!
destinationMemberññÅ í
.ññí ì
Typeññì ó
}ññò ô
.ññô ö
Whereññö ü
(ññü †
tññ† °
=>ññ¢ §
tññ• ¶
!=ññß ©
nullññ™ Æ
)ññÆ Ø
,ññØ ∞
(
óó 
declaredType
óó !
,
óó! "
runtimeType
óó# .
)
óó. /
=>
óó0 2
declaredType
óó3 ?
.
óó? @'
ContainsGenericParameters
óó@ Y
?
óóZ [
runtimeType
óó\ g
:
óóh i
declaredType
óój v
)
óóv w
.
óów x
ToArray
óóx 
(óó Ä
)óóÄ Å
;óóÅ Ç
iValueResolver
òò 
=
òò 
iValueResolver
òò +
.
òò+ ,&
GetGenericTypeDefinition
òò, D
(
òòD E
)
òòE F
.
òòF G
MakeGenericType
òòG V
(
òòV W
typeArgs
òòW _
)
òò_ `
;
òò` a
}
ôô 	
var
öö 

parameters
öö 
=
öö 
new
öö 
[
öö 
]
öö 
{
öö  
source
öö! '
,
öö' (
destination
öö) 4
,
öö4 5
sourceMember
öö6 B
,
ööB C
destinationMember
ööD U
}
ööV W
.
ööW X
Where
ööX ]
(
öö] ^
p
öö^ _
=>
öö` b
p
ööc d
!=
ööe g
null
ööh l
)
ööl m
.
õõ 
Zip
õõ 
(
õõ 
iValueResolver
õõ 
.
õõ  "
GenericTypeArguments
õõ  4
,
õõ4 5
ToType
õõ6 <
)
õõ< =
.
úú 
Append
úú 
(
úú 
ContextParameter
úú $
)
úú$ %
.
ùù 
ToArray
ùù 
(
ùù 
)
ùù 
;
ùù 
return
ûû 
Call
ûû 
(
ûû 
ToType
ûû 
(
ûû 
resolverInstance
ûû +
,
ûû+ ,
iValueResolver
ûû- ;
)
ûû; <
,
ûû< =
$str
ûû> G
,
ûûG H

parameters
ûûI S
)
ûûS T
;
ûûT U
}
üü 
public
†† 


MemberInfo
†† 
GetSourceMember
†† %
(
††% &
	MemberMap
††& /
_
††0 1
)
††1 2
=>
††3 5 
SourceMemberLambda
††6 H
?
††H I
.
††I J
	GetMember
††J S
(
††S T
)
††T U
;
††U V
}°° 
public¢¢ 
abstract
¢¢ 
class
¢¢ 
TypeConverter
¢¢ #
{££ 
public
§§ 

abstract
§§ 

Expression
§§ 
GetExpression
§§ ,
(
§§, -"
IGlobalConfiguration
§§- A
configuration
§§B O
,
§§O P!
ParameterExpression
§§Q d
[
§§d e
]
§§e f

parameters
§§g q
)
§§q r
;
§§r s
public
•• 

virtual
•• 
void
•• 
CloseGenerics
•• %
(
••% &"
TypeMapConfiguration
••& :
openMapConfig
••; H
,
••H I
TypePair
••J R
closedTypes
••S ^
)
••^ _
{
••` a
}
••b c
public
¶¶ 

virtual
¶¶ 
LambdaExpression
¶¶ #!
ProjectToExpression
¶¶$ 7
=>
¶¶8 :
null
¶¶; ?
;
¶¶? @
}ßß 
public®® 
class
®® !
LambdaTypeConverter
®®  
(
®®  !
LambdaExpression
®®! 1
lambda
®®2 8
)
®®8 9
:
®®: ;
TypeConverter
®®< I
{©© 
public
™™ 

LambdaExpression
™™ 
Lambda
™™ "
{
™™# $
get
™™% (
;
™™( )
}
™™* +
=
™™, -
lambda
™™. 4
;
™™4 5
public
´´ 

override
´´ 

Expression
´´ 
GetExpression
´´ ,
(
´´, -"
IGlobalConfiguration
´´- A
configuration
´´B O
,
´´O P!
ParameterExpression
´´Q d
[
´´d e
]
´´e f

parameters
´´g q
)
´´q r
=>
´´s u
configuration
¨¨ 
.
¨¨ &
ConvertReplaceParameters
¨¨ .
(
¨¨. /
Lambda
¨¨/ 5
,
¨¨5 6

parameters
¨¨7 A
)
¨¨A B
;
¨¨B C
}≠≠ 
publicÆÆ 
class
ÆÆ %
ExpressionTypeConverter
ÆÆ $
(
ÆÆ$ %
LambdaExpression
ÆÆ% 5
lambda
ÆÆ6 <
)
ÆÆ< =
:
ÆÆ> ?!
LambdaTypeConverter
ÆÆ@ S
(
ÆÆS T
lambda
ÆÆT Z
)
ÆÆZ [
{ØØ 
public
∞∞ 

override
∞∞ 
LambdaExpression
∞∞ $!
ProjectToExpression
∞∞% 8
=>
∞∞9 ;
Lambda
∞∞< B
;
∞∞B C
}±± 
public≤≤ 
class
≤≤  
ClassTypeConverter
≤≤ 
(
≤≤  
Type
≤≤  $
converterType
≤≤% 2
,
≤≤2 3
Type
≤≤4 8 
converterInterface
≤≤9 K
)
≤≤K L
:
≤≤M N
TypeConverter
≤≤O \
{≥≥ 
public
¥¥ 

Type
¥¥ 
ConverterType
¥¥ 
{
¥¥ 
get
¥¥  #
;
¥¥# $
private
¥¥% ,
set
¥¥- 0
;
¥¥0 1
}
¥¥2 3
=
¥¥4 5
converterType
¥¥6 C
;
¥¥C D
public
µµ 

Type
µµ  
ConverterInterface
µµ "
{
µµ# $
get
µµ% (
;
µµ( )
}
µµ* +
=
µµ, - 
converterInterface
µµ. @
;
µµ@ A
public
∂∂ 

override
∂∂ 

Expression
∂∂ 
GetExpression
∂∂ ,
(
∂∂, -"
IGlobalConfiguration
∂∂- A
configuration
∂∂B O
,
∂∂O P!
ParameterExpression
∂∂Q d
[
∂∂d e
]
∂∂e f

parameters
∂∂g q
)
∂∂q r
=>
∂∂s u
Call
∑∑ 
(
∑∑ 
ToType
∑∑ 
(
∑∑ 
ServiceLocator
∑∑ "
(
∑∑" #
ConverterType
∑∑# 0
)
∑∑0 1
,
∑∑1 2 
ConverterInterface
∑∑3 E
)
∑∑E F
,
∑∑F G
$str
∑∑H Q
,
∑∑Q R

parameters
∑∑S ]
)
∑∑] ^
;
∑∑^ _
public
∏∏ 

override
∏∏ 
void
∏∏ 
CloseGenerics
∏∏ &
(
∏∏& '"
TypeMapConfiguration
∏∏' ;
openMapConfig
∏∏< I
,
∏∏I J
TypePair
∏∏K S
closedTypes
∏∏T _
)
∏∏_ `
{
ππ 
var
∫∫ 

typeParams
∫∫ 
=
∫∫ 
(
∫∫ 
openMapConfig
∫∫ '
.
∫∫' (

SourceType
∫∫( 2
.
∫∫2 3%
IsGenericTypeDefinition
∫∫3 J
?
∫∫K L
closedTypes
∫∫M X
.
∫∫X Y

SourceType
∫∫Y c
.
∫∫c d"
GenericTypeArguments
∫∫d x
:
∫∫y z
[
∫∫{ |
]
∫∫| }
)
∫∫} ~
.
ªª 
Concat
ªª 
(
ªª 
openMapConfig
ªª !
.
ªª! "
DestinationType
ªª" 1
.
ªª1 2%
IsGenericTypeDefinition
ªª2 I
?
ªªJ K
closedTypes
ªªL W
.
ªªW X
DestinationType
ªªX g
.
ªªg h"
GenericTypeArguments
ªªh |
:
ªª} ~
[ªª Ä
]ªªÄ Å
)ªªÅ Ç
;ªªÇ É
var
ºº 
neededParameters
ºº 
=
ºº 
ConverterType
ºº ,
.
ºº, -$
GenericParametersCount
ºº- C
(
ººC D
)
ººD E
;
ººE F
ConverterType
ΩΩ 
=
ΩΩ 
ConverterType
ΩΩ %
.
ΩΩ% &
MakeGenericType
ΩΩ& 5
(
ΩΩ5 6
[
ΩΩ6 7
..
ΩΩ7 9

typeParams
ΩΩ9 C
.
ΩΩC D
Take
ΩΩD H
(
ΩΩH I
neededParameters
ΩΩI Y
)
ΩΩY Z
]
ΩΩZ [
)
ΩΩ[ \
;
ΩΩ\ ]
}
ææ 
}øø ÿ‹
TC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Execution\ProxyGenerator.cs
	namespace 	

AutoMapper
 
. 
	Execution 
; 
public 
static 
class 
ProxyGenerator "
{ 
private 
static 
readonly 

MethodInfo &
DelegateCombine' 6
=7 8
typeof9 ?
(? @
Delegate@ H
)H I
.I J
	GetMethodJ S
(S T
nameofT Z
(Z [
Delegate[ c
.c d
Combined k
)k l
,l m
[n o
typeofo u
(u v
Delegatev ~
)~ 
,	 Ä
typeof
Å á
(
á à
Delegate
à ê
)
ê ë
]
ë í
)
í ì
;
ì î
private 
static 
readonly 

MethodInfo &
DelegateRemove' 5
=6 7
typeof8 >
(> ?
Delegate? G
)G H
.H I
	GetMethodI R
(R S
nameofS Y
(Y Z
DelegateZ b
.b c
Removec i
)i j
)j k
;k l
private		 
static		 
readonly		 
	EventInfo		 %
PropertyChanged		& 5
=		6 7
typeof		8 >
(		> ?"
INotifyPropertyChanged		? U
)		U V
.		V W
GetEvent		W _
(		_ `
nameof		` f
(		f g"
INotifyPropertyChanged		g }
.		} ~
PropertyChanged			~ ç
)
		ç é
)
		é è
;
		è ê
private

 
static

 
readonly

 
ConstructorInfo

 +
ProxyBaseCtor

, 9
=

: ;
typeof

< B
(

B C
	ProxyBase

C L
)

L M
.

M N
GetConstructor

N \
(

\ ]
[

] ^
]

^ _
)

_ `
;

` a
private 
static 
readonly 
ModuleBuilder )
ProxyModule* 5
=6 7
CreateProxyModule8 I
(I J
)J K
;K L
private 
static 
readonly '
LockingConcurrentDictionary 7
<7 8
TypeDescription8 G
,G H
TypeI M
>M N

ProxyTypesO Y
=Z [
new\ _
(_ `
	EmitProxy` i
)i j
;j k
private 
static 
ModuleBuilder  
CreateProxyModule! 2
(2 3
)3 4
{ 
var 
assemblyName 
= 
typeof !
(! "
Mapper" (
)( )
.) *
Assembly* 2
.2 3
GetName3 :
(: ;
); <
;< =
assemblyName 
. 
Name 
= 
$str 5
;5 6
var 
builder 
= 
AssemblyBuilder %
.% &!
DefineDynamicAssembly& ;
(; <
assemblyName< H
,H I!
AssemblyBuilderAccessJ _
._ `
Run` c
)c d
;d e
return 
builder 
. 
DefineDynamicModule *
(* +
assemblyName+ 7
.7 8
Name8 <
)< =
;= >
} 
private 
static 
Type 
	EmitProxy !
(! "
TypeDescription" 1
typeDescription2 A
)A B
{ 
var 
interfaceType 
= 
typeDescription +
.+ ,
Type, 0
;0 1
var 
typeBuilder 
= 
GenerateType &
(& '
)' (
;( )
GenerateConstructor 
( 
) 
; 
FieldBuilder  
propertyChangedField )
=* +
null, 0
;0 1
if 

( 
typeof 
( "
INotifyPropertyChanged )
)) *
.* +
IsAssignableFrom+ ;
(; <
interfaceType< I
)I J
)J K
{ 	#
GeneratePropertyChanged #
(# $
)$ %
;% &
} 	
GenerateFields 
( 
) 
; 
return 
typeBuilder 
. 
CreateTypeInfo )
() *
)* +
.+ ,
AsType, 2
(2 3
)3 4
;4 5
TypeBuilder   
GenerateType    
(    !
)  ! "
{!! 	
var"" 
propertyNames"" 
="" 
string""  &
.""& '
Join""' +
(""+ ,
$str"", /
,""/ 0
typeDescription""1 @
.""@ A 
AdditionalProperties""A U
.""U V
Select""V \
(""\ ]
p""] ^
=>""_ a
p""b c
.""c d
Name""d h
)""h i
)""i j
;""j k
var## 
typeName## 
=## 
$"## 
$str## #
{### $
interfaceType##$ 1
.##1 2
FullName##2 :
}##: ;
$str##; <
{##< =
typeDescription##= L
.##L M
GetHashCode##M X
(##X Y
)##Y Z
}##Z [
$str##[ \
{##\ ]
propertyNames##] j
}##j k
"##k l
;##l m
const$$ 
int$$ 
MaxTypeNameLength$$ '
=$$( )
$num$$* .
;$$. /
typeName%% 
=%% 
typeName%% 
[%%  
..%%  "
Math%%" &
.%%& '
Min%%' *
(%%* +
MaxTypeNameLength%%+ <
,%%< =
typeName%%> F
.%%F G
Length%%G M
)%%M N
]%%N O
;%%O P
Debug&& 
.&& 
	WriteLine&& 
(&& 
typeName&& $
,&&$ %
$str&&& ;
)&&; <
;&&< =
return'' 
ProxyModule'' 
.'' 

DefineType'' )
('') *
typeName''* 2
,''2 3
TypeAttributes(( 
.(( 
Class(( $
|((% &
TypeAttributes((' 5
.((5 6
Sealed((6 <
|((= >
TypeAttributes((? M
.((M N
Public((N T
,((T U
typeof((V \
(((\ ]
	ProxyBase((] f
)((f g
,((g h
interfaceType)) 
.)) 
IsInterface)) )
?))* +
[)), -
interfaceType))- :
])): ;
:))< =
[))> ?
]))? @
)))@ A
;))A B
}** 	
void++ #
GeneratePropertyChanged++ $
(++$ %
)++% &
{,, 	 
propertyChangedField--  
=--! "
typeBuilder--# .
.--. /
DefineField--/ :
(--: ;
PropertyChanged--; J
.--J K
Name--K O
,--O P
typeof--Q W
(--W X'
PropertyChangedEventHandler--X s
)--s t
,--t u
FieldAttributes	--v Ö
.
--Ö Ü
Private
--Ü ç
)
--ç é
;
--é è
EventAccessor.. 
(.. 
PropertyChanged.. )
...) *
	AddMethod..* 3
,..3 4
DelegateCombine..5 D
)..D E
;..E F
EventAccessor// 
(// 
PropertyChanged// )
.//) *
RemoveMethod//* 6
,//6 7
DelegateRemove//8 F
)//F G
;//G H
}00 	
void11 
EventAccessor11 
(11 

MethodInfo11 %
method11& ,
,11, -

MethodInfo11. 8
delegateMethod119 G
)11G H
{22 	
var33 
eventAccessor33 
=33 
typeBuilder33  +
.33+ ,
DefineMethod33, 8
(338 9
method339 ?
.33? @
Name33@ D
,33D E
MethodAttributes44  
.44  !
Public44! '
|44( )
MethodAttributes44* :
.44: ;
	HideBySig44; D
|44E F
MethodAttributes44G W
.44W X
SpecialName44X c
|44d e
MethodAttributes55  
.55  !
NewSlot55! (
|55) *
MethodAttributes55+ ;
.55; <
Virtual55< C
,55C D
typeof55E K
(55K L
void55L P
)55P Q
,55Q R
new66 
[66 
]66 
{66 
typeof66 
(66 '
PropertyChangedEventHandler66 :
)66: ;
}66< =
)66= >
;66> ?
var77 
addIl77 
=77 
eventAccessor77 %
.77% &
GetILGenerator77& 4
(774 5
)775 6
;776 7
addIl88 
.88 
Emit88 
(88 
OpCodes88 
.88 
Ldarg_088 &
)88& '
;88' (
addIl99 
.99 
Emit99 
(99 
OpCodes99 
.99 
Dup99 "
)99" #
;99# $
addIl:: 
.:: 
Emit:: 
(:: 
OpCodes:: 
.:: 
Ldfld:: $
,::$ % 
propertyChangedField::& :
)::: ;
;::; <
addIl;; 
.;; 
Emit;; 
(;; 
OpCodes;; 
.;; 
Ldarg_1;; &
);;& '
;;;' (
addIl<< 
.<< 
Emit<< 
(<< 
OpCodes<< 
.<< 
Call<< #
,<<# $
delegateMethod<<% 3
)<<3 4
;<<4 5
addIl== 
.== 
Emit== 
(== 
OpCodes== 
.== 
	Castclass== (
,==( )
typeof==* 0
(==0 1'
PropertyChangedEventHandler==1 L
)==L M
)==M N
;==N O
addIl>> 
.>> 
Emit>> 
(>> 
OpCodes>> 
.>> 
Stfld>> $
,>>$ % 
propertyChangedField>>& :
)>>: ;
;>>; <
addIl?? 
.?? 
Emit?? 
(?? 
OpCodes?? 
.?? 
Ret?? "
)??" #
;??# $
typeBuilder@@ 
.@@  
DefineMethodOverride@@ ,
(@@, -
eventAccessor@@- :
,@@: ;
method@@< B
)@@B C
;@@C D
}AA 	
voidBB 
GenerateFieldsBB 
(BB 
)BB 
{CC 	

DictionaryDD 
<DD 
stringDD 
,DD 
PropertyEmitterDD .
>DD. /
fieldBuildersDD0 =
=DD> ?
[DD@ A
]DDA B
;DDB C
foreachEE 
(EE 
varEE 
propertyEE !
inEE" $!
PropertiesToImplementEE% :
(EE: ;
)EE; <
)EE< =
{FF 
ifGG 
(GG 
fieldBuildersGG !
.GG! "
TryGetValueGG" -
(GG- .
propertyGG. 6
.GG6 7
NameGG7 ;
,GG; <
outGG= @
varGGA D
propertyEmitterGGE T
)GGT U
)GGU V
{HH 
ifII 
(II 
propertyEmitterII '
.II' (
PropertyTypeII( 4
!=II5 7
propertyII8 @
.II@ A
TypeIIA E
&&IIF H
(III J
propertyIIJ R
.IIR S
CanWriteIIS [
||II\ ^
!II_ `
propertyII` h
.IIh i
TypeIIi m
.IIm n
IsAssignableFromIIn ~
(II~ 
propertyEmitter	II é
.
IIé è
PropertyType
IIè õ
)
IIõ ú
)
IIú ù
)
IIù û
{JJ 
throwKK 
newKK !
ArgumentExceptionKK" 3
(KK3 4
$"KK4 6
$strKK6 _
{KK_ `
propertyKK` h
.KKh i
NameKKi m
}KKm n
"KKn o
,KKo p
nameofKKq w
(KKw x
interfaceType	KKx Ö
)
KKÖ Ü
)
KKÜ á
;
KKá à
}LL 
}MM 
elseNN 
{OO 
fieldBuildersPP !
.PP! "
AddPP" %
(PP% &
propertyPP& .
.PP. /
NamePP/ 3
,PP3 4
newPP5 8
PropertyEmitterPP9 H
(PPH I
typeBuilderPPI T
,PPT U
propertyPPV ^
,PP^ _ 
propertyChangedFieldPP` t
)PPt u
)PPu v
;PPv w
}QQ 
}RR 
}SS 	
ListTT 
<TT 
PropertyDescriptionTT  
>TT  !!
PropertiesToImplementTT" 7
(TT7 8
)TT8 9
{UU 	
ListVV 
<VV 
PropertyDescriptionVV $
>VV$ %!
propertiesToImplementVV& ;
=VV< =
[VV> ?
]VV? @
;VV@ A
ListWW 
<WW 
TypeWW 
>WW 
allInterfacesWW $
=WW% &
[WW' (
..WW( *
interfaceTypeWW* 7
.WW7 8
GetInterfacesWW8 E
(WWE F
)WWF G
,WWG H
interfaceTypeWWI V
]WWV W
;WWW X
foreachYY 
(YY 
varYY 
propertyYY !
inYY" $
allInterfacesZZ 
.ZZ 
WhereZZ #
(ZZ# $
intfZZ$ (
=>ZZ) +
intfZZ, 0
!=ZZ1 3
typeofZZ4 :
(ZZ: ;"
INotifyPropertyChangedZZ; Q
)ZZQ R
)ZZR S
.[[ 

SelectMany[[ 
([[  
intf[[  $
=>[[% '
intf[[( ,
.[[, -
GetProperties[[- :
([[: ;
)[[; <
)[[< =
.\\ 
Select\\ 
(\\ 
p\\ 
=>\\  
new\\! $
PropertyDescription\\% 8
(\\8 9
p\\9 :
)\\: ;
)\\; <
.]] 
Concat]] 
(]] 
typeDescription]] +
.]]+ , 
AdditionalProperties]], @
)]]@ A
)]]A B
{^^ 
if__ 
(__ 
property__ 
.__ 
CanWrite__ %
)__% &
{`` !
propertiesToImplementaa )
.aa) *
Insertaa* 0
(aa0 1
$numaa1 2
,aa2 3
propertyaa4 <
)aa< =
;aa= >
}bb 
elsecc 
{dd !
propertiesToImplementee )
.ee) *
Addee* -
(ee- .
propertyee. 6
)ee6 7
;ee7 8
}ff 
}gg 
returnhh !
propertiesToImplementhh (
;hh( )
}ii 	
voidjj 
GenerateConstructorjj  
(jj  !
)jj! "
{kk 	
varll 
constructorBuilderll "
=ll# $
typeBuilderll% 0
.ll0 1
DefineConstructorll1 B
(llB C
MethodAttributesllC S
.llS T
PublicllT Z
,llZ [
CallingConventionsll\ n
.lln o
Standardllo w
,llw x
[lly z
]llz {
)ll{ |
;ll| }
varmm 
ctorIlmm 
=mm 
constructorBuildermm +
.mm+ ,
GetILGeneratormm, :
(mm: ;
)mm; <
;mm< =
ctorIlnn 
.nn 
Emitnn 
(nn 
OpCodesnn 
.nn  
Ldarg_0nn  '
)nn' (
;nn( )
ctorIloo 
.oo 
Emitoo 
(oo 
OpCodesoo 
.oo  
Calloo  $
,oo$ %
ProxyBaseCtoroo& 3
)oo3 4
;oo4 5
ctorIlpp 
.pp 
Emitpp 
(pp 
OpCodespp 
.pp  
Retpp  #
)pp# $
;pp$ %
}qq 	
}rr 
publicss 

staticss 
Typess 
GetProxyTypess #
(ss# $
Typess$ (
interfaceTypess) 6
)ss6 7
=>ss8 :

ProxyTypesss; E
.ssE F
GetOrAddssF N
(ssN O
newssO R
(ssR S
interfaceTypessS `
,ss` a
[ssb c
]ssc d
)ssd e
)sse f
;ssf g
publictt 

statictt 
Typett 
GetSimilarTypett %
(tt% &
Typett& *

sourceTypett+ 5
,tt5 6
IEnumerablett7 B
<ttB C
PropertyDescriptionttC V
>ttV W 
additionalPropertiesttX l
)ttl m
=>ttn p

ProxyTypesuu 
.uu 
GetOrAdduu 
(uu 
newuu 
(uu  

sourceTypeuu  *
,uu* +
[uu, -
..uu- / 
additionalPropertiesuu/ C
.uuC D
OrderByuuD K
(uuK L
puuL M
=>uuN P
puuQ R
.uuR S
NameuuS W
)uuW X
]uuX Y
)uuY Z
)uuZ [
;uu[ \
classvv 	
PropertyEmittervv
 
{ww 
privatexx 
staticxx 
readonlyxx 

MethodInfoxx  **
ProxyBaseNotifyPropertyChangedxx+ I
=xxJ K
typeofxxL R
(xxR S
	ProxyBasexxS \
)xx\ ]
.xx] ^
GetInstanceMethodxx^ o
(xxo p
$str	xxp á
)
xxá à
;
xxà â
privateyy 
readonlyyy 
FieldBuilderyy %
_fieldBuilderyy& 3
;yy3 4
privatezz 
readonlyzz 
MethodBuilderzz &
_getterBuilderzz' 5
;zz5 6
private{{ 
readonly{{ 
PropertyBuilder{{ (
_propertyBuilder{{) 9
;{{9 :
private|| 
readonly|| 
MethodBuilder|| &
_setterBuilder||' 5
;||5 6
public}} 
PropertyEmitter}} 
(}} 
TypeBuilder}} *
owner}}+ 0
,}}0 1
PropertyDescription}}2 E
property}}F N
,}}N O
FieldBuilder}}P \ 
propertyChangedField}}] q
)}}q r
{~~ 	
var 
name 
= 
property 
.  
Name  $
;$ %
var
ÄÄ 
propertyType
ÄÄ 
=
ÄÄ 
property
ÄÄ '
.
ÄÄ' (
Type
ÄÄ( ,
;
ÄÄ, -
_fieldBuilder
ÅÅ 
=
ÅÅ 
owner
ÅÅ !
.
ÅÅ! "
DefineField
ÅÅ" -
(
ÅÅ- .
$"
ÅÅ. 0
$str
ÅÅ0 1
{
ÅÅ1 2
name
ÅÅ2 6
}
ÅÅ6 7
$str
ÅÅ7 8
"
ÅÅ8 9
,
ÅÅ9 :
propertyType
ÅÅ; G
,
ÅÅG H
FieldAttributes
ÅÅI X
.
ÅÅX Y
Private
ÅÅY `
)
ÅÅ` a
;
ÅÅa b
_propertyBuilder
ÇÇ 
=
ÇÇ 
owner
ÇÇ $
.
ÇÇ$ %
DefineProperty
ÇÇ% 3
(
ÇÇ3 4
name
ÇÇ4 8
,
ÇÇ8 9 
PropertyAttributes
ÇÇ: L
.
ÇÇL M
None
ÇÇM Q
,
ÇÇQ R
propertyType
ÇÇS _
,
ÇÇ_ `
null
ÇÇa e
)
ÇÇe f
;
ÇÇf g
_getterBuilder
ÉÉ 
=
ÉÉ 
owner
ÉÉ "
.
ÉÉ" #
DefineMethod
ÉÉ# /
(
ÉÉ/ 0
$"
ÉÉ0 2
$str
ÉÉ2 6
{
ÉÉ6 7
name
ÉÉ7 ;
}
ÉÉ; <
"
ÉÉ< =
,
ÉÉ= >
MethodAttributes
ÑÑ  
.
ÑÑ  !
Public
ÑÑ! '
|
ÑÑ( )
MethodAttributes
ÑÑ* :
.
ÑÑ: ;
Virtual
ÑÑ; B
|
ÑÑC D
MethodAttributes
ÑÑE U
.
ÑÑU V
	HideBySig
ÑÑV _
|
ÑÑ` a
MethodAttributes
ÖÖ  
.
ÖÖ  !
SpecialName
ÖÖ! ,
,
ÖÖ, -
propertyType
ÖÖ. :
,
ÖÖ: ;
Type
ÖÖ< @
.
ÖÖ@ A

EmptyTypes
ÖÖA K
)
ÖÖK L
;
ÖÖL M
ILGenerator
ÜÜ 
getterIl
ÜÜ  
=
ÜÜ! "
_getterBuilder
ÜÜ# 1
.
ÜÜ1 2
GetILGenerator
ÜÜ2 @
(
ÜÜ@ A
)
ÜÜA B
;
ÜÜB C
getterIl
áá 
.
áá 
Emit
áá 
(
áá 
OpCodes
áá !
.
áá! "
Ldarg_0
áá" )
)
áá) *
;
áá* +
getterIl
àà 
.
àà 
Emit
àà 
(
àà 
OpCodes
àà !
.
àà! "
Ldfld
àà" '
,
àà' (
_fieldBuilder
àà) 6
)
àà6 7
;
àà7 8
getterIl
ââ 
.
ââ 
Emit
ââ 
(
ââ 
OpCodes
ââ !
.
ââ! "
Ret
ââ" %
)
ââ% &
;
ââ& '
_propertyBuilder
ää 
.
ää 
SetGetMethod
ää )
(
ää) *
_getterBuilder
ää* 8
)
ää8 9
;
ää9 :
if
ãã 
(
ãã 
!
ãã 
property
ãã 
.
ãã 
CanWrite
ãã "
)
ãã" #
{
åå 
return
çç 
;
çç 
}
éé 
_setterBuilder
èè 
=
èè 
owner
èè "
.
èè" #
DefineMethod
èè# /
(
èè/ 0
$"
èè0 2
$str
èè2 6
{
èè6 7
name
èè7 ;
}
èè; <
"
èè< =
,
èè= >
MethodAttributes
êê  
.
êê  !
Public
êê! '
|
êê( )
MethodAttributes
êê* :
.
êê: ;
Virtual
êê; B
|
êêC D
MethodAttributes
êêE U
.
êêU V
	HideBySig
êêV _
|
êê` a
MethodAttributes
ëë  
.
ëë  !
SpecialName
ëë! ,
,
ëë, -
typeof
ëë. 4
(
ëë4 5
void
ëë5 9
)
ëë9 :
,
ëë: ;
[
ëë< =
propertyType
ëë= I
]
ëëI J
)
ëëJ K
;
ëëK L
ILGenerator
íí 
setterIl
íí  
=
íí! "
_setterBuilder
íí# 1
.
íí1 2
GetILGenerator
íí2 @
(
íí@ A
)
ííA B
;
ííB C
setterIl
ìì 
.
ìì 
Emit
ìì 
(
ìì 
OpCodes
ìì !
.
ìì! "
Ldarg_0
ìì" )
)
ìì) *
;
ìì* +
setterIl
îî 
.
îî 
Emit
îî 
(
îî 
OpCodes
îî !
.
îî! "
Ldarg_1
îî" )
)
îî) *
;
îî* +
setterIl
ïï 
.
ïï 
Emit
ïï 
(
ïï 
OpCodes
ïï !
.
ïï! "
Stfld
ïï" '
,
ïï' (
_fieldBuilder
ïï) 6
)
ïï6 7
;
ïï7 8
if
ññ 
(
ññ "
propertyChangedField
ññ $
!=
ññ% '
null
ññ( ,
)
ññ, -
{
óó 
setterIl
òò 
.
òò 
Emit
òò 
(
òò 
OpCodes
òò %
.
òò% &
Ldarg_0
òò& -
)
òò- .
;
òò. /
setterIl
ôô 
.
ôô 
Emit
ôô 
(
ôô 
OpCodes
ôô %
.
ôô% &
Dup
ôô& )
)
ôô) *
;
ôô* +
setterIl
öö 
.
öö 
Emit
öö 
(
öö 
OpCodes
öö %
.
öö% &
Ldfld
öö& +
,
öö+ ,"
propertyChangedField
öö- A
)
ööA B
;
ööB C
setterIl
õõ 
.
õõ 
Emit
õõ 
(
õõ 
OpCodes
õõ %
.
õõ% &
Ldstr
õõ& +
,
õõ+ ,
name
õõ- 1
)
õõ1 2
;
õõ2 3
setterIl
úú 
.
úú 
Emit
úú 
(
úú 
OpCodes
úú %
.
úú% &
Call
úú& *
,
úú* +,
ProxyBaseNotifyPropertyChanged
úú, J
)
úúJ K
;
úúK L
}
ùù 
setterIl
ûû 
.
ûû 
Emit
ûû 
(
ûû 
OpCodes
ûû !
.
ûû! "
Ret
ûû" %
)
ûû% &
;
ûû& '
_propertyBuilder
üü 
.
üü 
SetSetMethod
üü )
(
üü) *
_setterBuilder
üü* 8
)
üü8 9
;
üü9 :
}
†† 	
public
°° 
Type
°° 
PropertyType
°°  
=>
°°! #
_propertyBuilder
°°$ 4
.
°°4 5
PropertyType
°°5 A
;
°°A B
}
¢¢ 
}££ 
public§§ 
abstract
§§ 
class
§§ 
	ProxyBase
§§ 
{•• 
public
¶¶ 

	ProxyBase
¶¶ 
(
¶¶ 
)
¶¶ 
{
¶¶ 
}
¶¶ 
	protected
ßß 
void
ßß #
NotifyPropertyChanged
ßß (
(
ßß( ))
PropertyChangedEventHandler
ßß) D
handler
ßßE L
,
ßßL M
string
ßßN T
method
ßßU [
)
ßß[ \
=>
ßß] _
handler
ßß` g
?
ßßg h
.
ßßh i
Invoke
ßßi o
(
ßßo p
this
ßßp t
,
ßßt u
new
ßßv y
(
ßßy z
methodßßz Ä
)ßßÄ Å
)ßßÅ Ç
;ßßÇ É
}®® 
public©© 
readonly
©© 
record
©© 
struct
©© 
TypeDescription
©© -
(
©©- .
Type
©©. 2
Type
©©3 7
,
©©7 8!
PropertyDescription
©©9 L
[
©©L M
]
©©M N"
AdditionalProperties
©©O c
)
©©c d
{™™ 
public
´´ 

override
´´ 
int
´´ 
GetHashCode
´´ #
(
´´# $
)
´´$ %
{
¨¨ 
var
≠≠ 
hashCode
≠≠ 
=
≠≠ 
new
≠≠ 
HashCode
≠≠ #
(
≠≠# $
)
≠≠$ %
;
≠≠% &
hashCode
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ 
Type
ÆÆ 
)
ÆÆ 
;
ÆÆ 
foreach
ØØ 
(
ØØ 
var
ØØ 
property
ØØ 
in
ØØ  "
AdditionalProperties
ØØ! 5
)
ØØ5 6
{
∞∞ 	
hashCode
±± 
.
±± 
Add
±± 
(
±± 
property
±± !
)
±±! "
;
±±" #
}
≤≤ 	
return
≥≥ 
hashCode
≥≥ 
.
≥≥ 

ToHashCode
≥≥ "
(
≥≥" #
)
≥≥# $
;
≥≥$ %
}
¥¥ 
public
µµ 

bool
µµ 
Equals
µµ 
(
µµ 
TypeDescription
µµ &
other
µµ' ,
)
µµ, -
=>
µµ. 0
Type
µµ1 5
==
µµ6 8
other
µµ9 >
.
µµ> ?
Type
µµ? C
&&
µµD F"
AdditionalProperties
µµG [
.
µµ[ \
SequenceEqual
µµ\ i
(
µµi j
other
µµj o
.
µµo p#
AdditionalPropertiesµµp Ñ
)µµÑ Ö
;µµÖ Ü
}∂∂ 
[∑∑ 
DebuggerDisplay
∑∑ 
(
∑∑ 
$str
∑∑ %
)
∑∑% &
]
∑∑& '
public∏∏ 
readonly
∏∏ 
record
∏∏ 
struct
∏∏ !
PropertyDescription
∏∏ 1
(
∏∏1 2
string
∏∏2 8
Name
∏∏9 =
,
∏∏= >
Type
∏∏? C
Type
∏∏D H
,
∏∏H I
bool
∏∏J N
CanWrite
∏∏O W
=
∏∏X Y
true
∏∏Z ^
)
∏∏^ _
{ππ 
public
∫∫ 
!
PropertyDescription
∫∫ 
(
∫∫ 
PropertyInfo
∫∫ +
property
∫∫, 4
)
∫∫4 5
:
∫∫6 7
this
∫∫8 <
(
∫∫< =
property
∫∫= E
.
∫∫E F
Name
∫∫F J
,
∫∫J K
property
∫∫L T
.
∫∫T U
PropertyType
∫∫U a
,
∫∫a b
property
∫∫c k
.
∫∫k l
CanWrite
∫∫l t
)
∫∫t u
{
∫∫v w
}
∫∫x y
}ªª ÍW
SC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Execution\ObjectFactory.cs
	namespace 	

AutoMapper
 
. 
	Execution 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
static 
class 
ObjectFactory !
{ 
static 

readonly 

Expression 
EmptyString *
=+ ,
Constant- 5
(5 6
string6 <
.< =
Empty= B
)B C
;C D
static 

readonly '
LockingConcurrentDictionary /
</ 0
Type0 4
,4 5
Func6 :
<: ;
object; A
>A B
>B C
	CtorCacheD M
=N O
newP S
(S T
GenerateConstructorT g
)g h
;h i
public 

static 
object 
CreateInstance '
(' (
Type( ,
type- 1
)1 2
=>3 5
	CtorCache6 ?
.? @
GetOrAdd@ H
(H I
typeI M
)M N
(N O
)O P
;P Q
private		 
static		 
Func		 
<		 
object		 
>		 
GenerateConstructor		  3
(		3 4
Type		4 8
type		9 =
)		= >
=>		? A
Lambda

 
<

 
Func

 
<

 
object

 
>

 
>

 
(

 )
GenerateConstructorExpression

 :
(

: ;
type

; ?
,

? @
null

A E
)

E F
.

F G
ToObject

G O
(

O P
)

P Q
)

Q R
.

R S
Compile

S Z
(

Z [
)

[ \
;

\ ]
public 

static 
object  
CreateInterfaceProxy -
(- .
Type. 2
interfaceType3 @
)@ A
=>B D
CreateInstanceE S
(S T
ProxyGeneratorT b
.b c
GetProxyTypec o
(o p
interfaceTypep }
)} ~
)~ 
;	 Ä
public 

static 

Expression )
GenerateConstructorExpression :
(: ;
Type; ?
type@ D
,D E 
IGlobalConfigurationF Z
configuration[ h
)h i
=>j l
typem q
switchr x
{ 
{ 	
IsValueType
 
: 
true 
} 
=>  
configuration! .
.. /
Default/ 6
(6 7
type7 ;
); <
,< =
Type 

stringType 
when 

stringType '
==( *
typeof+ 1
(1 2
string2 8
)8 9
=>: <
EmptyString= H
,H I
{ 	
IsInterface
 
: 
true 
} 
=>  %
CreateInterfaceExpression! :
(: ;
type; ?
)? @
,@ A
{ 	

IsAbstract
 
: 
true 
} 
=> 
InvalidType  +
(+ ,
type, 0
,0 1
$"2 4
$str4 _
{_ `
type` d
}d e
$stre f
"f g
)g h
,h i
_ 	
=>
 
CallConstructor 
( 
type !
,! "
configuration# 0
)0 1
} 
; 
private 
static 

Expression 
CallConstructor -
(- .
Type. 2
type3 7
,7 8 
IGlobalConfiguration9 M
configurationN [
)[ \
{ 
var 
defaultCtor 
= 
type 
. 
GetConstructor -
(- .
Internal. 6
.6 7
TypeExtensions7 E
.E F
InstanceFlagsF S
,S T
[U V
]V W
)W X
;X Y
if 

( 
defaultCtor 
!= 
null 
)  
{ 	
return 
New 
( 
defaultCtor "
)" #
;# $
} 	
var  
ctorWithOptionalArgs  
=! "
( 
from 
ctor 
in 
type 
. #
GetDeclaredConstructors 6
(6 7
)7 8
let9 <
args= A
=B C
ctorD H
.H I
GetParametersI V
(V W
)W X
whereY ^
args_ c
.c d
Alld g
(g h
ph i
=>j l
pm n
.n o

IsOptionalo y
)y z
select	{ Å
(
Ç É
ctor
É á
,
á à
args
â ç
)
ç é
)
é è
.
è ê
FirstOrDefault
ê û
(
û ü
)
ü †
;
† °
if 

(  
ctorWithOptionalArgs  
.  !
args! %
==& (
null) -
)- .
{ 	
return 
InvalidType 
( 
type #
,# $
$"% '
{' (
type( ,
}, -
$str	- ï
"
ï ñ
)
ñ ó
;
ó ò
}   	
var!! 
	arguments!! 
=!!  
ctorWithOptionalArgs!! ,
.!!, -
args!!- 1
.!!1 2
Select!!2 8
(!!8 9
p!!9 :
=>!!; =
p!!> ?
.!!? @
GetDefaultValue!!@ O
(!!O P
configuration!!P ]
)!!] ^
)!!^ _
;!!_ `
return"" 
New"" 
(""  
ctorWithOptionalArgs"" '
.""' (
ctor""( ,
,"", -
	arguments"". 7
)""7 8
;""8 9
}## 
private$$ 
static$$ 

Expression$$ %
CreateInterfaceExpression$$ 7
($$7 8
Type$$8 <
type$$= A
)$$A B
=>$$C E
type%% 
.%% 
IsGenericType%% 
(%% 
typeof%% !
(%%! "
IDictionary%%" -
<%%- .
,%%. /
>%%/ 0
)%%0 1
)%%1 2
?%%3 4
CreateCollection%%5 E
(%%E F
type%%F J
,%%J K
typeof%%L R
(%%R S

Dictionary%%S ]
<%%] ^
,%%^ _
>%%_ `
)%%` a
)%%a b
:%%c d
type&& 
.&& 
IsGenericType&& 
(&& 
typeof&& !
(&&! "
IReadOnlyDictionary&&" 5
<&&5 6
,&&6 7
>&&7 8
)&&8 9
)&&9 :
?&&; <$
CreateReadOnlyDictionary&&= U
(&&U V
type&&V Z
.&&Z [ 
GenericTypeArguments&&[ o
)&&o p
:&&q r
type'' 
.'' 
IsGenericType'' 
('' 
typeof'' !
(''! "
ISet''" &
<''& '
>''' (
)''( )
)'') *
?''+ ,
CreateCollection''- =
(''= >
type''> B
,''B C
typeof''D J
(''J K
HashSet''K R
<''R S
>''S T
)''T U
)''U V
:''W X
type(( 
.(( 
IsCollection(( 
((( 
)(( 
?(( 
CreateCollection(( .
(((. /
type((/ 3
,((3 4
typeof((5 ;
(((; <
List((< @
<((@ A
>((A B
)((B C
,((C D#
GetIEnumerableArguments((E \
(((\ ]
type((] a
)((a b
)((b c
:((d e
InvalidType)) 
()) 
type)) 
,)) 
$")) 
$str)) H
{))H I
type))I M
}))M N
$str))N O
"))O P
)))P Q
;))Q R
private** 
static** 
Type** 
[** 
]** #
GetIEnumerableArguments** 1
(**1 2
Type**2 6
type**7 ;
)**; <
=>**= ?
type**@ D
.**D E
GetIEnumerableType**E W
(**W X
)**X Y
?**Y Z
.**Z [ 
GenericTypeArguments**[ o
??**p r
[**s t
typeof**t z
(**z {
object	**{ Å
)
**Å Ç
]
**Ç É
;
**É Ñ
private++ 
static++ 

Expression++ 
CreateCollection++ .
(++. /
Type++/ 3
type++4 8
,++8 9
Type++: >
collectionType++? M
,++M N
Type++O S
[++S T
]++T U
genericArguments++V f
=++g h
null++i m
)++m n
=>++o q
ToType,, 
(,, 
New,, 
(,, 
collectionType,, !
.,,! "
MakeGenericType,," 1
(,,1 2
genericArguments,,2 B
??,,C E
type,,F J
.,,J K 
GenericTypeArguments,,K _
),,_ `
),,` a
,,,a b
type,,c g
),,g h
;,,h i
private-- 
static-- 

Expression-- $
CreateReadOnlyDictionary-- 6
(--6 7
Type--7 ;
[--; <
]--< =
typeArguments--> K
)--K L
{.. 
var// 
ctor// 
=// 
typeof// 
(// 
ReadOnlyDictionary// ,
<//, -
,//- .
>//. /
)/// 0
.//0 1
MakeGenericType//1 @
(//@ A
typeArguments//A N
)//N O
.//O P
GetConstructors//P _
(//_ `
)//` a
[//a b
$num//b c
]//c d
;//d e
return00 
New00 
(00 
ctor00 
,00 
New00 
(00 
typeof00 #
(00# $

Dictionary00$ .
<00. /
,00/ 0
>000 1
)001 2
.002 3
MakeGenericType003 B
(00B C
typeArguments00C P
)00P Q
)00Q R
)00R S
;00S T
}11 
private22 
static22 

Expression22 
InvalidType22 )
(22) *
Type22* .
type22/ 3
,223 4
string225 ;
message22< C
)22C D
=>22E G
Throw22H M
(22M N
Constant22N V
(22V W
new22W Z
ArgumentException22[ l
(22l m
message22m t
,22t u
$str22v |
)22| }
)22} ~
,22~ 
type
22Ä Ñ
)
22Ñ Ö
;
22Ö Ü
}33 ˆ√
WC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Execution\ExpressionBuilder.cs
	namespace 	

AutoMapper
 
. 
	Execution 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
static 
class 
ExpressionBuilder %
{ 
public		 

static		 
readonly		 

MethodInfo		 %
ObjectToString		& 4
=		5 6
typeof		7 =
(		= >
object		> D
)		D E
.		E F
	GetMethod		F O
(		O P
nameof		P V
(		V W
ToString		W _
)		_ `
)		` a
;		a b
public

 

static

 
readonly

 

Expression

 %
True

& *
=

+ ,
Constant

- 5
(

5 6
true

6 :
,

: ;
typeof

< B
(

B C
bool

C G
)

G H
)

H I
;

I J
public 

static 
readonly 

Expression %
Null& *
=+ ,

Expression- 7
.7 8
Default8 ?
(? @
typeof@ F
(F G
objectG M
)M N
)N O
;O P
public 

static 
readonly 

Expression %
Empty& +
=, -
Empty. 3
(3 4
)4 5
;5 6
public 

static 
readonly 

Expression %
Zero& *
=+ ,

Expression- 7
.7 8
Default8 ?
(? @
typeof@ F
(F G
intG J
)J K
)K L
;L M
public 

static 
readonly 
ParameterExpression .
ExceptionParameter/ A
=B C
	ParameterD M
(M N
typeofN T
(T U
	ExceptionU ^
)^ _
,_ `
$stra e
)e f
;f g
public 

static 
readonly 
ParameterExpression .
ContextParameter/ ?
=@ A
	ParameterB K
(K L
typeofL R
(R S
ResolutionContextS d
)d e
,e f
$strg p
)p q
;q r
public 

static 
readonly 

MethodInfo %

IListClear& 0
=1 2
typeof3 9
(9 :
IList: ?
)? @
.@ A
	GetMethodA J
(J K
nameofK Q
(Q R
IListR W
.W X
ClearX ]
)] ^
)^ _
;_ `
static 

readonly 

MethodInfo 
ContextCreate ,
=- .
typeof/ 5
(5 6
ResolutionContext6 G
)G H
.H I
GetInstanceMethodI Z
(Z [
nameof[ a
(a b
ResolutionContextb s
.s t
CreateInstance	t Ç
)
Ç É
)
É Ñ
;
Ñ Ö
static 

readonly 

MethodInfo 
OverTypeDepthMethod 2
=3 4
typeof5 ;
(; <
ResolutionContext< M
)M N
.N O
GetInstanceMethodO `
(` a
nameofa g
(g h
ResolutionContexth y
.y z
OverTypeDepth	z á
)
á à
)
à â
;
â ä
static 

readonly  
MethodCallExpression (
CheckContextCall) 9
=: ;

Expression< F
.F G
CallG K
(K L
typeof 
( 
ResolutionContext  
)  !
.! "
GetStaticMethod" 1
(1 2
nameof2 8
(8 9
ResolutionContext9 J
.J K
CheckContextK W
)W X
)X Y
,Y Z
ContextParameter[ k
)k l
;l m
static 

readonly 

MethodInfo 
ContextMapMethod /
=0 1
typeof2 8
(8 9
ResolutionContext9 J
)J K
.K L
GetInstanceMethodL ]
(] ^
nameof^ d
(d e
ResolutionContexte v
.v w
MapInternal	w Ç
)
Ç É
)
É Ñ
;
Ñ Ö
static 

readonly 

MethodInfo 
ArrayEmptyMethod /
=0 1
typeof2 8
(8 9
Array9 >
)> ?
.? @
GetStaticMethod@ O
(O P
nameofP V
(V W
ArrayW \
.\ ]
Empty] b
)b c
)c d
;d e
static 

readonly 
ParameterExpression '

Disposable( 2
=3 4
Variable5 =
(= >
typeof> D
(D E
IDisposableE P
)P Q
,Q R
$strS i
)i j
;j k
static 

readonly 
ReadOnlyCollection &
<& '
ParameterExpression' :
>: ;
DisposableArray< K
=L M

DisposableN X
.X Y

ToReadOnlyY c
(c d
)d e
;e f
static 

readonly 

MethodInfo 
DisposeMethod ,
=- .
typeof/ 5
(5 6
IDisposable6 A
)A B
.B C
	GetMethodC L
(L M
nameofM S
(S T
IDisposableT _
._ `
Dispose` g
)g h
)h i
;i j
static 

readonly 

Expression 
DisposeCall *
=+ ,
IfThen- 3
(3 4
ReferenceNotEqual4 E
(E F

DisposableF P
,P Q
NullR V
)V W
,W X

ExpressionY c
.c d
Calld h
(h i

Disposablei s
,s t
DisposeMethod	u Ç
)
Ç É
)
É Ñ
;
Ñ Ö
static 

readonly 
ParameterExpression '
Index( -
=. /
Variable0 8
(8 9
typeof9 ?
(? @
int@ C
)C D
,D E
$strF X
)X Y
;Y Z
static 

readonly 
BinaryExpression $

ResetIndex% /
=0 1
Assign2 8
(8 9
Index9 >
,> ?
Zero@ D
)D E
;E F
static 

readonly 
UnaryExpression #
IncrementIndex$ 2
=3 4
PostIncrementAssign5 H
(H I
IndexI N
)N O
;O P
public 

static 

Expression 
ReplaceParameters .
(. /
this/ 3 
IGlobalConfiguration4 H
configurationI V
,V W
LambdaExpressionX h
initialLambdai v
,v w

Expression	x Ç
newParameter
É è
)
è ê
=>
ë ì
configuration 
. #
ParameterReplaceVisitor -
(- .
). /
./ 0
Replace0 7
(7 8
initialLambda8 E
,E F
newParameterG S
)S T
;T U
public   

static   

Expression   
ReplaceParameters   .
(  . /
this  / 3 
IGlobalConfiguration  4 H
configuration  I V
,  V W
LambdaExpression  X h
initialLambda  i v
,  v w

Expression	  x Ç
[
  Ç É
]
  É Ñ
newParameters
  Ö í
)
  í ì
=>
  î ñ
configuration!! 
.!! #
ParameterReplaceVisitor!! -
(!!- .
)!!. /
.!!/ 0
Replace!!0 7
(!!7 8
initialLambda!!8 E
,!!E F
newParameters!!G T
)!!T U
;!!U V
public"" 

static"" 

Expression"" $
ConvertReplaceParameters"" 5
(""5 6
this""6 : 
IGlobalConfiguration""; O
configuration""P ]
,""] ^
LambdaExpression""_ o
initialLambda""p }
,""} ~

Expression	"" â
newParameter
""ä ñ
)
""ñ ó
=>
""ò ö
configuration## 
.## *
ConvertParameterReplaceVisitor## 4
(##4 5
)##5 6
.##6 7
Replace##7 >
(##> ?
initialLambda##? L
,##L M
newParameter##N Z
)##Z [
;##[ \
public$$ 

static$$ 

Expression$$ $
ConvertReplaceParameters$$ 5
($$5 6
this$$6 : 
IGlobalConfiguration$$; O
configuration$$P ]
,$$] ^
LambdaExpression$$_ o
initialLambda$$p }
,$$} ~

Expression	$$ â
[
$$â ä
]
$$ä ã
newParameters
$$å ô
)
$$ô ö
=>
$$õ ù
configuration%% 
.%% *
ConvertParameterReplaceVisitor%% 4
(%%4 5
)%%5 6
.%%6 7
Replace%%7 >
(%%> ?
initialLambda%%? L
,%%L M
newParameters%%N [
)%%[ \
;%%\ ]
public&& 

static&& 
DefaultExpression&& #
Default&&$ +
(&&+ ,
this&&, 0 
IGlobalConfiguration&&1 E
configuration&&F S
,&&S T
Type&&U Y
type&&Z ^
)&&^ _
=>&&` b
configuration'' 
=='' 
null'' 
?'' 

Expression''  *
.''* +
Default''+ 2
(''2 3
type''3 7
)''7 8
:''9 :
configuration''; H
.''H I

GetDefault''I S
(''S T
type''T X
)''X Y
;''Y Z
public(( 

static(( 
((( 
List(( 
<(( 
ParameterExpression(( +
>((+ ,
	Variables((- 6
,((6 7
List((8 <
<((< =

Expression((= G
>((G H
Expressions((I T
)((T U

Scratchpad((V `
(((` a
this((a e 
IGlobalConfiguration((f z
configuration	(({ à
)
((à â
{)) 
var** 
	variables** 
=** 
configuration** %
?**% &
.**& '
	Variables**' 0
;**0 1
if++ 

(++ 
	variables++ 
==++ 
null++ 
)++ 
{,, 	
	variables-- 
=-- 
[-- 
]-- 
;-- 
}.. 	
else// 
{00 	
	variables11 
.11 
Clear11 
(11 
)11 
;11 
}22 	
var33 
expressions33 
=33 
configuration33 '
?33' (
.33( )
Expressions33) 4
;334 5
if44 

(44 
expressions44 
==44 
null44 
)44  
{55 	
expressions66 
=66 
[66 
]66 
;66 
}77 	
else88 
{99 	
expressions:: 
.:: 
Clear:: 
(:: 
):: 
;::  
};; 	
return<< 
(<< 
	variables<< 
,<< 
expressions<< &
)<<& '
;<<' (
}== 
public>> 

static>> 

Expression>> 
MapExpression>> *
(>>* +
this>>+ / 
IGlobalConfiguration>>0 D
configuration>>E R
,>>R S

ProfileMap>>T ^

profileMap>>_ i
,>>i j
TypePair>>k s
typePair>>t |
,>>| }

Expression	>>~ à
source
>>â è
,
>>è ê
	MemberMap?? 
	memberMap?? 
=?? 
null?? "
,??" #

Expression??$ .
destination??/ :
=??; <
null??= A
)??A B
{@@ 
destinationAA 
??=AA 
configurationAA %
.AA% &
DefaultAA& -
(AA- .
typePairAA. 6
.AA6 7
DestinationTypeAA7 F
)AAF G
;AAG H
varBB 
typeMapBB 
=BB 
configurationBB #
.BB# $
ResolveTypeMapBB$ 2
(BB2 3
typePairBB3 ;
)BB; <
;BB< =

ExpressionCC 
mapExpressionCC  
=CC! "
nullCC# '
;CC' (
boolDD 
	nullCheckDD 
;DD 
ifEE 

(EE 
typeMapEE 
!=EE 
nullEE 
)EE 
{FF 	
typeMapGG 
.GG 
CheckProjectionGG #
(GG# $
)GG$ %
;GG% &
varHH 
	allowNullHH 
=HH 
	memberMapHH %
?HH% &
.HH& '
	AllowNullHH' 0
;HH0 1
	nullCheckII 
=II 
!II 
typeMapII  
.II  !
HasTypeConverterII! 1
&&II2 4
(II5 6
destinationII6 A
.IIA B
NodeTypeIIB J
!=IIK M
ExpressionTypeIIN \
.II\ ]
DefaultII] d
||IIe g
(JJ 
	allowNullJJ 
.JJ 
HasValueJJ #
&&JJ$ &
	allowNullJJ' 0
!=JJ1 3

profileMapJJ4 >
.JJ> ?&
AllowNullDestinationValuesJJ? Y
)JJY Z
)JJZ [
;JJ[ \
ifKK 
(KK 
!KK 
typeMapKK 
.KK $
HasDerivedTypesToIncludeKK 1
)KK1 2
{LL 
typeMapMM 
.MM 
SealMM 
(MM 
configurationMM *
)MM* +
;MM+ ,
ifNN 
(NN 
typeMapNN 
.NN 
MapExpressionNN )
!=NN* ,
nullNN- 1
)NN1 2
{OO 
mapExpressionPP !
=PP" #
typeMapPP$ +
.PP+ ,
InvokePP, 2
(PP2 3
sourcePP3 9
,PP9 :
destinationPP; F
)PPF G
;PPG H
}QQ 
}RR 
}SS 	
elseTT 
{UU 	
varVV 
mapperVV 
=VV 
configurationVV &
.VV& '

FindMapperVV' 1
(VV1 2
typePairVV2 :
)VV: ;
;VV; <
ifWW 
(WW 
mapperWW 
!=WW 
nullWW 
)WW 
{XX 
mapExpressionYY 
=YY 
mapperYY  &
.YY& '
MapExpressionYY' 4
(YY4 5
configurationYY5 B
,YYB C

profileMapYYD N
,YYN O
	memberMapYYP Y
,YYY Z
sourceYY[ a
,YYa b
destinationYYc n
)YYn o
;YYo p
	nullCheckZZ 
=ZZ 
mapExpressionZZ )
!=ZZ* ,
sourceZZ- 3
;ZZ3 4
}[[ 
else\\ 
{]] 
	nullCheck^^ 
=^^ 
true^^  
;^^  !
}__ 
}`` 	
mapExpressionaa 
=aa 
mapExpressionaa %
==aa& (
nullaa) -
?aa. /

ContextMapaa0 :
(aa: ;
typePairaa; C
,aaC D
sourceaaE K
,aaK L
destinationaaM X
,aaX Y
	memberMapaaZ c
)aac d
:aae f
ToTypeaag m
(aam n
mapExpressionaan {
,aa{ |
typePair	aa} Ö
.
aaÖ Ü
DestinationType
aaÜ ï
)
aaï ñ
;
aañ ó
returnbb 
	nullCheckbb 
?bb 
configurationbb (
.bb( )
NullCheckSourcebb) 8
(bb8 9

profileMapbb9 C
,bbC D
sourcebbE K
,bbK L
destinationbbM X
,bbX Y
mapExpressionbbZ g
,bbg h
	memberMapbbi r
)bbr s
:bbt u
mapExpression	bbv É
;
bbÉ Ñ
}cc 
publicdd 

staticdd 

Expressiondd 
NullCheckSourcedd ,
(dd, -
thisdd- 1 
IGlobalConfigurationdd2 F
configurationddG T
,ddT U

ProfileMapddV `

profileMapdda k
,ddk l

Expressionddm w
sourceddx ~
,dd~ 

Expression
ddÄ ä
destination
ddã ñ
,
ddñ ó

Expressionee 
mapExpressionee  
,ee  !
	MemberMapee" +
	memberMapee, 5
)ee5 6
{ff 
vargg 

sourceTypegg 
=gg 
sourcegg 
.gg  
Typegg  $
;gg$ %
ifhh 

(hh 

sourceTypehh 
.hh 
IsValueTypehh "
&&hh# %
!hh& '

sourceTypehh' 1
.hh1 2
IsNullableTypehh2 @
(hh@ A
)hhA B
)hhB C
{ii 	
returnjj 
mapExpressionjj  
;jj  !
}kk 	
varll 
destinationTypell 
=ll 
destinationll )
.ll) *
Typell* .
;ll. /
varmm 
isCollectionmm 
=mm 
destinationTypemm *
.mm* +
IsCollectionmm+ 7
(mm7 8
)mm8 9
;mm9 :
varnn 
mustUseDestinationnn 
=nn  
	memberMapnn! *
isnn+ -
{nn. /
MustUseDestinationnn0 B
:nnB C
truennD H
}nnI J
;nnJ K
varoo 
ifSourceNulloo 
=oo 
	memberMapoo $
==oo% '
nulloo( ,
?oo- .
destinationpp 
.pp 

IfNullElsepp "
(pp" #
DefaultDestinationpp# 5
(pp5 6
)pp6 7
,pp7 8&
ClearDestinationCollectionpp9 S
(ppS T
)ppT U
)ppU V
:ppW X
mustUseDestinationqq 
?qq  &
ClearDestinationCollectionqq! ;
(qq; <
)qq< =
:qq> ?
DefaultDestinationqq@ R
(qqR S
)qqS T
;qqT U
returnrr 
sourcerr 
.rr 

IfNullElserr  
(rr  !
ifSourceNullrr! -
,rr- .
mapExpressionrr/ <
)rr< =
;rr= >

Expressionss &
ClearDestinationCollectionss -
(ss- .
)ss. /
{tt 	
ifuu 
(uu 
!uu 
isCollectionuu 
)uu 
{vv 
returnww 
destinationww "
;ww" #
}xx 

MethodInfoyy 
clearMethodyy "
;yy" #
varzz 
destinationVariablezz #
=zz$ %
Variablezz& .
(zz. /
destinationzz/ :
.zz: ;
Typezz; ?
,zz? @
$strzzA X
)zzX Y
;zzY Z

Expression{{ 

collection{{ !
={{" #
destinationVariable{{$ 7
;{{7 8
if|| 
(|| 
destinationType|| 
.||  

IsListType||  *
(||* +
)||+ ,
)||, -
{}} 
clearMethod~~ 
=~~ 

IListClear~~ (
;~~( )
} 
else
ÄÄ 
{
ÅÅ 
var
ÇÇ '
destinationCollectionType
ÇÇ -
=
ÇÇ. /
destinationType
ÇÇ0 ?
.
ÇÇ? @ 
GetICollectionType
ÇÇ@ R
(
ÇÇR S
)
ÇÇS T
;
ÇÇT U
if
ÉÉ 
(
ÉÉ '
destinationCollectionType
ÉÉ -
==
ÉÉ. 0
null
ÉÉ1 5
)
ÉÉ5 6
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
!
ÖÖ  
mustUseDestination
ÖÖ +
)
ÖÖ+ ,
{
ÜÜ 
return
áá 
destination
áá *
;
áá* +
}
àà 
var
ââ $
destinationElementType
ââ .
=
ââ/ 0&
GetEnumerableElementType
ââ1 I
(
ââI J
destinationType
ââJ Y
)
ââY Z
;
ââZ ['
destinationCollectionType
ää -
=
ää. /
typeof
ää0 6
(
ää6 7
ICollection
ää7 B
<
ääB C
>
ääC D
)
ääD E
.
ääE F
MakeGenericType
ääF U
(
ääU V$
destinationElementType
ääV l
)
ääl m
;
ääm n

collection
ãã 
=
ãã  
TypeAs
ãã! '
(
ãã' (

collection
ãã( 2
,
ãã2 3'
destinationCollectionType
ãã4 M
)
ããM N
;
ããN O
}
åå 
clearMethod
çç 
=
çç '
destinationCollectionType
çç 7
.
çç7 8
	GetMethod
çç8 A
(
ççA B
$str
ççB I
)
ççI J
;
ççJ K
}
éé 
var
èè 
(
èè 
	variables
èè 
,
èè 

statements
èè &
)
èè& '
=
èè( )
configuration
èè* 7
.
èè7 8

Scratchpad
èè8 B
(
èèB C
)
èèC D
;
èèD E
	variables
êê 
.
êê 
Add
êê 
(
êê !
destinationVariable
êê -
)
êê- .
;
êê. /

statements
ëë 
.
ëë 
Add
ëë 
(
ëë 
Assign
ëë !
(
ëë! "!
destinationVariable
ëë" 5
,
ëë5 6
destination
ëë7 B
)
ëëB C
)
ëëC D
;
ëëD E

statements
íí 
.
íí 
Add
íí 
(
íí 
IfThen
íí !
(
íí! "
ReferenceNotEqual
íí" 3
(
íí3 4

collection
íí4 >
,
íí> ?
Null
íí@ D
)
ííD E
,
ííE F

Expression
ííG Q
.
ííQ R
Call
ííR V
(
ííV W

collection
ííW a
,
íía b
clearMethod
ííc n
)
íín o
)
íío p
)
ííp q
;
ííq r

statements
ìì 
.
ìì 
Add
ìì 
(
ìì !
destinationVariable
ìì .
)
ìì. /
;
ìì/ 0
return
îî 
Block
îî 
(
îî 
	variables
îî "
,
îî" #

statements
îî$ .
)
îî. /
;
îî/ 0
}
ïï 	

Expression
ññ  
DefaultDestination
ññ %
(
ññ% &
)
ññ& '
{
óó 	
if
òò 
(
òò 
(
òò 
isCollection
òò 
&&
òò  

profileMap
òò! +
.
òò+ ,&
AllowsNullCollectionsFor
òò, D
(
òòD E
	memberMap
òòE N
)
òòN O
)
òòO P
||
òòQ S
(
òòT U
!
òòU V
isCollection
òòV b
&&
òòc e

profileMap
òòf p
.
òòp q-
AllowsNullDestinationValuesForòòq è
(òòè ê
	memberMapòòê ô
)òòô ö
)òòö õ
)òòõ ú
{
ôô 
return
öö 
destination
öö "
.
öö" #
NodeType
öö# +
==
öö, .
ExpressionType
öö/ =
.
öö= >
Default
öö> E
?
ööF G
destination
ööH S
:
ööT U
configuration
ööV c
.
ööc d
Default
ööd k
(
öök l
destinationType
ööl {
)
öö{ |
;
öö| }
}
õõ 
if
úú 
(
úú 
destinationType
úú 
.
úú  
IsArray
úú  '
)
úú' (
{
ùù 
var
ûû $
destinationElementType
ûû *
=
ûû+ ,
destinationType
ûû- <
.
ûû< =
GetElementType
ûû= K
(
ûûK L
)
ûûL M
;
ûûM N
var
üü 
rank
üü 
=
üü 
destinationType
üü *
.
üü* +
GetArrayRank
üü+ 7
(
üü7 8
)
üü8 9
;
üü9 :
return
†† 
rank
†† 
==
†† 
$num
††  
?
††! "

Expression
°° 
.
°° 
Call
°° #
(
°°# $
ArrayEmptyMethod
°°$ 4
.
°°4 5
MakeGenericMethod
°°5 F
(
°°F G$
destinationElementType
°°G ]
)
°°] ^
)
°°^ _
:
°°` a
NewArrayBounds
¢¢ "
(
¢¢" #$
destinationElementType
¢¢# 9
,
¢¢9 :

Enumerable
¢¢; E
.
¢¢E F
Repeat
¢¢F L
(
¢¢L M
Zero
¢¢M Q
,
¢¢Q R
rank
¢¢S W
)
¢¢W X
)
¢¢X Y
;
¢¢Y Z
}
££ 
return
§§ 
ObjectFactory
§§  
.
§§  !+
GenerateConstructorExpression
§§! >
(
§§> ?
destinationType
§§? N
,
§§N O
configuration
§§P ]
)
§§] ^
;
§§^ _
}
•• 	
}
¶¶ 
public
ßß 

static
ßß 

Expression
ßß 
ServiceLocator
ßß +
(
ßß+ ,
Type
ßß, 0
type
ßß1 5
)
ßß5 6
=>
ßß7 9

Expression
ßß: D
.
ßßD E
Call
ßßE I
(
ßßI J
ContextParameter
ßßJ Z
,
ßßZ [
ContextCreate
ßß\ i
,
ßßi j
Constant
ßßk s
(
ßßs t
type
ßßt x
)
ßßx y
)
ßßy z
;
ßßz {
public
®® 

static
®® 

Expression
®® 

ContextMap
®® '
(
®®' (
TypePair
®®( 0
typePair
®®1 9
,
®®9 :

Expression
®®; E
sourceParameter
®®F U
,
®®U V

Expression
®®W a"
destinationParameter
®®b v
,
®®v w
	MemberMap®®x Å
	memberMap®®Ç ã
)®®ã å
{
©© 
var
™™ 
	mapMethod
™™ 
=
™™ 
ContextMapMethod
™™ (
.
™™( )
MakeGenericMethod
™™) :
(
™™: ;
typePair
™™; C
.
™™C D

SourceType
™™D N
,
™™N O
typePair
™™P X
.
™™X Y
DestinationType
™™Y h
)
™™h i
;
™™i j
return
´´ 

Expression
´´ 
.
´´ 
Call
´´ 
(
´´ 
ContextParameter
´´ /
,
´´/ 0
	mapMethod
´´1 :
,
´´: ;
sourceParameter
´´< K
,
´´K L"
destinationParameter
´´M a
,
´´a b
Constant
´´c k
(
´´k l
	memberMap
´´l u
,
´´u v
typeof
´´w }
(
´´} ~
	MemberMap´´~ á
)´´á à
)´´à â
)´´â ä
;´´ä ã
}
¨¨ 
public
≠≠ 

static
≠≠ 

Expression
≠≠ 
CheckContext
≠≠ )
(
≠≠) *
TypeMap
≠≠* 1
typeMap
≠≠2 9
)
≠≠9 :
=>
≠≠; =
typeMap
≠≠> E
.
≠≠E F 
PreserveReferences
≠≠F X
||
≠≠Y [
typeMap
≠≠\ c
.
≠≠c d
MaxDepth
≠≠d l
>
≠≠m n
$num
≠≠o p
?
≠≠q r
CheckContextCall≠≠s É
:≠≠Ñ Ö
null≠≠Ü ä
;≠≠ä ã
public
ÆÆ 

static
ÆÆ 

Expression
ÆÆ 
OverMaxDepth
ÆÆ )
(
ÆÆ) *
TypeMap
ÆÆ* 1
typeMap
ÆÆ2 9
)
ÆÆ9 :
=>
ÆÆ; =
typeMap
ÆÆ> E
?
ÆÆE F
.
ÆÆF G
MaxDepth
ÆÆG O
>
ÆÆP Q
$num
ÆÆR S
?
ÆÆT U

Expression
ØØ 
.
ØØ 
Call
ØØ 
(
ØØ 
ContextParameter
ØØ (
,
ØØ( )!
OverTypeDepthMethod
ØØ* =
,
ØØ= >
Constant
ØØ? G
(
ØØG H
typeMap
ØØH O
)
ØØO P
)
ØØP Q
:
ØØR S
null
ØØT X
;
ØØX Y
public
∞∞ 

static
∞∞ 

Expression
∞∞ 
NullSubstitute
∞∞ +
(
∞∞+ ,
this
∞∞, 0
	MemberMap
∞∞1 :
	memberMap
∞∞; D
,
∞∞D E

Expression
∞∞F P
sourceExpression
∞∞Q a
)
∞∞a b
=>
∞∞c e
Coalesce
±± 
(
±± 
sourceExpression
±± !
,
±±! "
ToType
±±# )
(
±±) *
Constant
±±* 2
(
±±2 3
	memberMap
±±3 <
.
±±< =
NullSubstitute
±±= K
)
±±K L
,
±±L M
sourceExpression
±±N ^
.
±±^ _
Type
±±_ c
)
±±c d
)
±±d e
;
±±e f
public
≤≤ 

static
≤≤ 

Expression
≤≤ 
ApplyTransformers
≤≤ .
(
≤≤. /
this
≤≤/ 3
	MemberMap
≤≤4 =
	memberMap
≤≤> G
,
≤≤G H

Expression
≤≤I S
source
≤≤T Z
,
≤≤Z ["
IGlobalConfiguration
≤≤\ p
configuration
≤≤q ~
)
≤≤~ 
{
≥≥ 
var
¥¥ 
	perMember
¥¥ 
=
¥¥ 
	memberMap
¥¥ !
.
¥¥! "
ValueTransformers
¥¥" 3
;
¥¥3 4
var
µµ 
perMap
µµ 
=
µµ 
	memberMap
µµ 
.
µµ 
TypeMap
µµ &
.
µµ& '
ValueTransformers
µµ' 8
;
µµ8 9
var
∂∂ 

perProfile
∂∂ 
=
∂∂ 
	memberMap
∂∂ "
.
∂∂" #
Profile
∂∂# *
.
∂∂* +
ValueTransformers
∂∂+ <
;
∂∂< =
return
∑∑ 
	perMember
∑∑ 
.
∑∑ 
Count
∑∑ 
>
∑∑  
$num
∑∑! "
||
∑∑# %
perMap
∑∑& ,
.
∑∑, -
Count
∑∑- 2
>
∑∑3 4
$num
∑∑5 6
||
∑∑7 9

perProfile
∑∑: D
.
∑∑D E
Count
∑∑E J
>
∑∑K L
$num
∑∑M N
?
∑∑O P
	memberMap
∏∏ 
.
∏∏ 
ApplyTransformers
∏∏ '
(
∏∏' (
source
∏∏( .
,
∏∏. /
configuration
∏∏0 =
,
∏∏= >
	perMember
∏∏? H
.
∏∏H I
Concat
∏∏I O
(
∏∏O P
perMap
∏∏P V
)
∏∏V W
.
∏∏W X
Concat
∏∏X ^
(
∏∏^ _

perProfile
∏∏_ i
)
∏∏i j
)
∏∏j k
:
∏∏l m
source
∏∏n t
;
∏∏t u
}
ππ 
static
∫∫ 


Expression
∫∫ 
ApplyTransformers
∫∫ '
(
∫∫' (
this
∫∫( ,
	MemberMap
∫∫- 6
	memberMap
∫∫7 @
,
∫∫@ A

Expression
∫∫B L
result
∫∫M S
,
∫∫S T"
IGlobalConfiguration
∫∫U i
configuration
∫∫j w
,
∫∫w x
IEnumerable∫∫y Ñ
<∫∫Ñ Ö-
ValueTransformerConfiguration∫∫Ö ¢
>∫∫¢ £
transformers∫∫§ ∞
)∫∫∞ ±
{
ªª 
foreach
ºº 
(
ºº 
var
ºº 
transformer
ºº  
in
ºº! #
transformers
ºº$ 0
)
ºº0 1
{
ΩΩ 	
if
ææ 
(
ææ 
transformer
ææ 
.
ææ 
IsMatch
ææ #
(
ææ# $
	memberMap
ææ$ -
)
ææ- .
)
ææ. /
{
øø 
result
¿¿ 
=
¿¿ 
ToType
¿¿ 
(
¿¿  
configuration
¿¿  -
.
¿¿- .
ReplaceParameters
¿¿. ?
(
¿¿? @
transformer
¿¿@ K
.
¿¿K L#
TransformerExpression
¿¿L a
,
¿¿a b
ToType
¿¿c i
(
¿¿i j
result
¿¿j p
,
¿¿p q
transformer
¿¿r }
.
¿¿} ~
	ValueType¿¿~ á
)¿¿á à
)¿¿à â
,¿¿â ä
	memberMap¿¿ã î
.¿¿î ï
DestinationType¿¿ï §
)¿¿§ •
;¿¿• ¶
}
¡¡ 
}
¬¬ 	
return
√√ 
result
√√ 
;
√√ 
}
ƒƒ 
public
≈≈ 

static
≈≈ 
LambdaExpression
≈≈ "
Lambda
≈≈# )
(
≈≈) *
this
≈≈* .

MemberInfo
≈≈/ 9
member
≈≈: @
)
≈≈@ A
=>
≈≈B D
new
≈≈E H
[
≈≈H I
]
≈≈I J
{
≈≈K L
member
≈≈M S
}
≈≈T U
.
≈≈U V
Lambda
≈≈V \
(
≈≈\ ]
)
≈≈] ^
;
≈≈^ _
public
∆∆ 

static
∆∆ 
LambdaExpression
∆∆ "
Lambda
∆∆# )
(
∆∆) *
this
∆∆* .

MemberInfo
∆∆/ 9
[
∆∆9 :
]
∆∆: ;
members
∆∆< C
)
∆∆C D
{
«« 
var
»» 
source
»» 
=
»» 
	Parameter
»» 
(
»» 
members
»» &
[
»»& '
$num
»»' (
]
»»( )
.
»») *
DeclaringType
»»* 7
,
»»7 8
$str
»»9 A
)
»»A B
;
»»B C
return
…… 

Expression
…… 
.
…… 
Lambda
……  
(
……  !
members
……! (
.
……( )
Chain
……) .
(
……. /
source
……/ 5
)
……5 6
,
……6 7
source
……8 >
)
……> ?
;
……? @
}
   
public
ÀÀ 

static
ÀÀ 

Expression
ÀÀ 
Chain
ÀÀ "
(
ÀÀ" #
this
ÀÀ# '

MemberInfo
ÀÀ( 2
[
ÀÀ2 3
]
ÀÀ3 4
members
ÀÀ5 <
,
ÀÀ< =

Expression
ÀÀ> H
target
ÀÀI O
)
ÀÀO P
{
ÃÃ 
foreach
ÕÕ 
(
ÕÕ 
var
ÕÕ 
member
ÕÕ 
in
ÕÕ 
members
ÕÕ &
)
ÕÕ& '
{
ŒŒ 	
target
œœ 
=
œœ 
member
œœ 
switch
œœ "
{
–– 
PropertyInfo
—— 
property
—— %
=>
——& (

Expression
——) 3
.
——3 4
Property
——4 <
(
——< =
target
——= C
,
——C D
property
——E M
)
——M N
,
——N O

MethodInfo
““ 
{
““ 
IsStatic
““ %
:
““% &
true
““' +
}
““, -
getter
““. 4
=>
““5 7

Expression
““8 B
.
““B C
Call
““C G
(
““G H
getter
““H N
,
““N O
target
““P V
)
““V W
,
““W X
	FieldInfo
”” 
field
”” 
=>
””  "
Field
””# (
(
””( )
target
””) /
,
””/ 0
field
””1 6
)
””6 7
,
””7 8

MethodInfo
‘‘ 
getter
‘‘ !
=>
‘‘" $

Expression
‘‘% /
.
‘‘/ 0
Call
‘‘0 4
(
‘‘4 5
target
‘‘5 ;
,
‘‘; <
getter
‘‘= C
)
‘‘C D
,
‘‘D E
_
’’ 
=>
’’ 
throw
’’ 
new
’’ )
ArgumentOutOfRangeException
’’ :
(
’’: ;
nameof
’’; A
(
’’A B
member
’’B H
)
’’H I
,
’’I J
member
’’K Q
,
’’Q R
$str
’’S g
)
’’g h
}
÷÷ 
;
÷÷ 
}
◊◊ 	
return
ÿÿ 
target
ÿÿ 
;
ÿÿ 
}
ŸŸ 
public
⁄⁄ 

static
⁄⁄ 

MemberInfo
⁄⁄ 
[
⁄⁄ 
]
⁄⁄ 
GetMembersChain
⁄⁄ .
(
⁄⁄. /
this
⁄⁄/ 3
LambdaExpression
⁄⁄4 D
lambda
⁄⁄E K
)
⁄⁄K L
=>
⁄⁄M O
lambda
⁄⁄P V
.
⁄⁄V W
Body
⁄⁄W [
.
⁄⁄[ \
GetChain
⁄⁄\ d
(
⁄⁄d e
)
⁄⁄e f
.
⁄⁄f g
ToMemberInfos
⁄⁄g t
(
⁄⁄t u
)
⁄⁄u v
;
⁄⁄v w
public
€€ 

static
€€ 

MemberInfo
€€ 
	GetMember
€€ &
(
€€& '
this
€€' +
LambdaExpression
€€, <
lambda
€€= C
)
€€C D
=>
€€E G
(
‹‹ 	
lambda
‹‹	 
?
‹‹ 
.
‹‹ 
Body
‹‹ 
is
‹‹ 
MemberExpression
‹‹ )
memberExpression
‹‹* :
&&
‹‹; =
memberExpression
‹‹> N
.
‹‹N O

Expression
‹‹O Y
==
‹‹Z \
lambda
‹‹] c
.
‹‹c d

Parameters
‹‹d n
[
‹‹n o
$num
‹‹o p
]
‹‹p q
)
‹‹q r
?
‹‹s t
memberExpression‹‹u Ö
.‹‹Ö Ü
Member‹‹Ü å
:‹‹ç é
null‹‹è ì
;‹‹ì î
public
›› 

static
›› 

MemberInfo
›› 
[
›› 
]
›› 
ToMemberInfos
›› ,
(
››, -
this
››- 1
Stack
››2 7
<
››7 8
Member
››8 >
>
››> ?
chain
››@ E
)
››E F
{
ﬁﬁ 
var
ﬂﬂ 
members
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 

MemberInfo
ﬂﬂ $
[
ﬂﬂ$ %
chain
ﬂﬂ% *
.
ﬂﬂ* +
Count
ﬂﬂ+ 0
]
ﬂﬂ0 1
;
ﬂﬂ1 2
int
‡‡ 
index
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
foreach
·· 
(
·· 
var
·· 
member
·· 
in
·· 
chain
·· $
)
··$ %
{
‚‚ 	
members
„„ 
[
„„ 
index
„„ 
++
„„ 
]
„„ 
=
„„ 
member
„„ %
.
„„% &

MemberInfo
„„& 0
;
„„0 1
}
‰‰ 	
return
ÂÂ 
members
ÂÂ 
;
ÂÂ 
}
ÊÊ 
public
ÁÁ 

static
ÁÁ 
Stack
ÁÁ 
<
ÁÁ 
Member
ÁÁ 
>
ÁÁ 
GetChain
ÁÁ  (
(
ÁÁ( )
this
ÁÁ) -

Expression
ÁÁ. 8

expression
ÁÁ9 C
)
ÁÁC D
{
ËË 
Stack
ÈÈ 
<
ÈÈ 
Member
ÈÈ 
>
ÈÈ 
stack
ÈÈ 
=
ÈÈ 
[
ÈÈ 
]
ÈÈ  
;
ÈÈ  !
while
ÍÍ 
(
ÍÍ 

expression
ÍÍ 
!=
ÍÍ 
null
ÍÍ !
)
ÍÍ! "
{
ÎÎ 	
var
ÏÏ 
member
ÏÏ 
=
ÏÏ 

expression
ÏÏ #
switch
ÏÏ$ *
{
ÌÌ 
MemberExpression
ÓÓ  
{
ÓÓ! "

Expression
ÓÓ# -
:
ÓÓ- .

Expression
ÓÓ/ 9
target
ÓÓ: @
,
ÓÓ@ A
Member
ÓÓB H
:
ÓÓH I

MemberInfo
ÓÓJ T
propertyOrField
ÓÓU d
}
ÓÓe f
=>
ÓÓg i
new
ÔÔ 
Member
ÔÔ 
(
ÔÔ 

expression
ÔÔ )
,
ÔÔ) *
propertyOrField
ÔÔ+ :
,
ÔÔ: ;
target
ÔÔ< B
)
ÔÔB C
,
ÔÔC D"
MethodCallExpression
 $
{
% &
Method
' -
:
- .
var
/ 2
instanceMethod
3 A
,
A B
Object
C I
:
I J

Expression
K U
target
V \
}
] ^
=>
_ a
new
ÒÒ 
Member
ÒÒ 
(
ÒÒ 

expression
ÒÒ )
,
ÒÒ) *
instanceMethod
ÒÒ+ 9
,
ÒÒ9 :
target
ÒÒ; A
)
ÒÒA B
,
ÒÒB C"
MethodCallExpression
ÚÚ $
{
ÚÚ% &
Method
ÚÚ' -
:
ÚÚ- .
var
ÚÚ/ 2
extensionMethod
ÚÚ3 B
,
ÚÚB C
	Arguments
ÚÚD M
:
ÚÚM N
{
ÚÚO P
Count
ÚÚQ V
:
ÚÚV W
>
ÚÚX Y
$num
ÚÚZ [
}
ÚÚ\ ]
	arguments
ÚÚ^ g
}
ÚÚh i
when
ÚÚj n
extensionMethod
ÚÚo ~
.
ÚÚ~ 
HasÚÚ Ç
<ÚÚÇ É"
ExtensionAttributeÚÚÉ ï
>ÚÚï ñ
(ÚÚñ ó
)ÚÚó ò
=>ÚÚô õ
new
ÛÛ 
Member
ÛÛ 
(
ÛÛ 

expression
ÛÛ )
,
ÛÛ) *
extensionMethod
ÛÛ+ :
,
ÛÛ: ;
	arguments
ÛÛ< E
[
ÛÛE F
$num
ÛÛF G
]
ÛÛG H
)
ÛÛH I
,
ÛÛI J
_
ÙÙ 
=>
ÙÙ 
default
ÙÙ 
}
ıı 
;
ıı 
if
ˆˆ 
(
ˆˆ 
member
ˆˆ 
.
ˆˆ 

Expression
ˆˆ !
==
ˆˆ" $
null
ˆˆ% )
)
ˆˆ) *
{
˜˜ 
break
¯¯ 
;
¯¯ 
}
˘˘ 
stack
˙˙ 
.
˙˙ 
Push
˙˙ 
(
˙˙ 
member
˙˙ 
)
˙˙ 
;
˙˙ 

expression
˚˚ 
=
˚˚ 
member
˚˚ 
.
˚˚  
Target
˚˚  &
;
˚˚& '
}
¸¸ 	
return
˝˝ 
stack
˝˝ 
;
˝˝ 
}
˛˛ 
public
ˇˇ 

static
ˇˇ 
IEnumerable
ˇˇ 
<
ˇˇ 
MemberExpression
ˇˇ .
>
ˇˇ. /"
GetMemberExpressions
ˇˇ0 D
(
ˇˇD E
this
ˇˇE I

Expression
ˇˇJ T

expression
ˇˇU _
)
ˇˇ_ `
=>
ˇˇa c

expression
ˇˇd n
is
ˇˇo q
MemberExpressionˇˇr Ç
?ˇˇÉ Ñ

expression
ÄÄ 
.
ÄÄ 
GetChain
ÄÄ 
(
ÄÄ 
)
ÄÄ 
.
ÄÄ 
Select
ÄÄ $
(
ÄÄ$ %
m
ÄÄ% &
=>
ÄÄ' )
m
ÄÄ* +
.
ÄÄ+ ,

Expression
ÄÄ, 6
as
ÄÄ7 9
MemberExpression
ÄÄ: J
)
ÄÄJ K
.
ÄÄK L
	TakeWhile
ÄÄL U
(
ÄÄU V
m
ÄÄV W
=>
ÄÄX Z
m
ÄÄ[ \
!=
ÄÄ] _
null
ÄÄ` d
)
ÄÄd e
:
ÄÄf g
[
ÄÄh i
]
ÄÄi j
;
ÄÄj k
public
ÅÅ 

static
ÅÅ 
bool
ÅÅ 
IsMemberPath
ÅÅ #
(
ÅÅ# $
this
ÅÅ$ (
LambdaExpression
ÅÅ) 9
lambda
ÅÅ: @
,
ÅÅ@ A
out
ÅÅB E
Stack
ÅÅF K
<
ÅÅK L
Member
ÅÅL R
>
ÅÅR S
members
ÅÅT [
)
ÅÅ[ \
{
ÇÇ 

Expression
ÉÉ 
currentExpression
ÉÉ $
=
ÉÉ% &
null
ÉÉ' +
;
ÉÉ+ ,
members
ÑÑ 
=
ÑÑ 
lambda
ÑÑ 
.
ÑÑ 
Body
ÑÑ 
.
ÑÑ 
GetChain
ÑÑ &
(
ÑÑ& '
)
ÑÑ' (
;
ÑÑ( )
foreach
ÖÖ 
(
ÖÖ 
var
ÖÖ 
member
ÖÖ 
in
ÖÖ 
members
ÖÖ &
)
ÖÖ& '
{
ÜÜ 	
currentExpression
áá 
=
áá 
member
áá  &
.
áá& '

Expression
áá' 1
;
áá1 2
if
àà 
(
àà 
currentExpression
àà !
is
àà" $
not
àà% (
MemberExpression
àà) 9
)
àà9 :
{
ââ 
return
ää 
false
ää 
;
ää 
}
ãã 
}
åå 	
return
çç 
currentExpression
çç  
==
çç! #
lambda
çç$ *
.
çç* +
Body
çç+ /
;
çç/ 0
}
éé 
public
èè 

static
èè 
LambdaExpression
èè " 
MemberAccessLambda
èè# 5
(
èè5 6
Type
èè6 :
type
èè; ?
,
èè? @
string
èèA G

memberPath
èèH R
,
èèR S
TypeMap
èèT [
typeMap
èè\ c
)
èèc d
=>
èèe g
GetMemberPath
êê 
(
êê 
type
êê 
,
êê 

memberPath
êê &
,
êê& '
typeMap
êê( /
)
êê/ 0
.
êê0 1
Lambda
êê1 7
(
êê7 8
)
êê8 9
;
êê9 :
public
ëë 

static
ëë 

Expression
ëë 
ForEach
ëë $
(
ëë$ %
List
ëë% )
<
ëë) *!
ParameterExpression
ëë* =
>
ëë= >
	variables
ëë? H
,
ëëH I
List
ëëJ N
<
ëëN O

Expression
ëëO Y
>
ëëY Z

statements
ëë[ e
,
ëëe f!
ParameterExpression
ëëg z
loopVarëë{ Ç
,ëëÇ É

ExpressionëëÑ é

collectionëëè ô
,ëëô ö

Expressionëëõ •
loopContentëë¶ ±
)ëë± ≤
{
íí 
if
ìì 

(
ìì 

collection
ìì 
.
ìì 
Type
ìì 
.
ìì 
IsArray
ìì #
)
ìì# $
{
îî 	
return
ïï 
ForEachArrayItem
ïï #
(
ïï# $
	variables
ïï$ -
,
ïï- .

statements
ïï/ 9
,
ïï9 :
loopVar
ïï; B
,
ïïB C

collection
ïïD N
,
ïïN O
loopContent
ïïP [
)
ïï[ \
;
ïï\ ]
}
ññ 	
var
óó 
getEnumeratorCall
óó 
=
óó 
Call
óó  $
(
óó$ %

collection
óó% /
,
óó/ 0
$str
óó1 @
)
óó@ A
;
óóA B
var
òò 
enumeratorVar
òò 
=
òò 
Variable
òò $
(
òò$ %
getEnumeratorCall
òò% 6
.
òò6 7
Type
òò7 ;
,
òò; <
$str
òò= I
)
òòI J
;
òòJ K
var
ôô 

breakLabel
ôô 
=
ôô 
Label
ôô 
(
ôô 
$str
ôô *
)
ôô* +
;
ôô+ ,
var
öö 
usingEnumerator
öö 
=
öö 
Using
öö #
(
öö# $

statements
öö$ .
,
öö. /
enumeratorVar
öö0 =
,
öö= >
Loop
õõ 
(
õõ 

IfThenElse
úú 
(
úú 
Call
ùù 
(
ùù 
enumeratorVar
ùù *
,
ùù* +
$str
ùù, 6
)
ùù6 7
,
ùù7 8
Block
ûû 
(
ûû 
Assign
ûû $
(
ûû$ %
loopVar
ûû% ,
,
ûû, -
ToType
ûû. 4
(
ûû4 5
Property
ûû5 =
(
ûû= >
enumeratorVar
ûû> K
,
ûûK L
$str
ûûM V
)
ûûV W
,
ûûW X
loopVar
ûûY `
.
ûû` a
Type
ûûa e
)
ûûe f
)
ûûf g
,
ûûg h
loopContent
ûûi t
)
ûût u
,
ûûu v
Break
üü 
(
üü 

breakLabel
üü (
)
üü( )
)
†† 
,
†† 

breakLabel
°° 
)
°° 
)
°° 
;
°° 

statements
¢¢ 
.
¢¢ 
Clear
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
	variables
££ 
.
££ 
Add
££ 
(
££ 
enumeratorVar
££ #
)
££# $
;
££$ %
	variables
§§ 
.
§§ 
Add
§§ 
(
§§ 
loopVar
§§ 
)
§§ 
;
§§ 

statements
•• 
.
•• 
Add
•• 
(
•• 
Assign
•• 
(
•• 
enumeratorVar
•• +
,
••+ ,
getEnumeratorCall
••- >
)
••> ?
)
••? @
;
••@ A

statements
¶¶ 
.
¶¶ 
Add
¶¶ 
(
¶¶ 
usingEnumerator
¶¶ &
)
¶¶& '
;
¶¶' (
return
ßß 
Block
ßß 
(
ßß 
	variables
ßß 
,
ßß 

statements
ßß  *
)
ßß* +
;
ßß+ ,
static
®® 

Expression
®® 
ForEachArrayItem
®® *
(
®®* +
List
®®+ /
<
®®/ 0!
ParameterExpression
®®0 C
>
®®C D
	variables
®®E N
,
®®N O
List
®®P T
<
®®T U

Expression
®®U _
>
®®_ `

statements
®®a k
,
®®k l"
ParameterExpression®®m Ä
loopVar®®Å à
,®®à â

Expression®®ä î
array®®ï ö
,®®ö õ

Expression®®ú ¶
loopContent®®ß ≤
)®®≤ ≥
{
©© 	
var
™™ 

breakLabel
™™ 
=
™™ 
Label
™™ "
(
™™" #
$str
™™# .
)
™™. /
;
™™/ 0
	variables
´´ 
.
´´ 
Add
´´ 
(
´´ 
Index
´´ 
)
´´  
;
´´  !
	variables
¨¨ 
.
¨¨ 
Add
¨¨ 
(
¨¨ 
loopVar
¨¨ !
)
¨¨! "
;
¨¨" #

statements
≠≠ 
.
≠≠ 
Add
≠≠ 
(
≠≠ 

ResetIndex
≠≠ %
)
≠≠% &
;
≠≠& '

statements
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ 
Loop
ÆÆ 
(
ÆÆ  

IfThenElse
ØØ 
(
ØØ 
LessThan
∞∞  
(
∞∞  !
Index
∞∞! &
,
∞∞& '
ArrayLength
∞∞( 3
(
∞∞3 4
array
∞∞4 9
)
∞∞9 :
)
∞∞: ;
,
∞∞; <
Block
±± 
(
±± 
Assign
±± $
(
±±$ %
loopVar
±±% ,
,
±±, -

ArrayIndex
±±. 8
(
±±8 9
array
±±9 >
,
±±> ?
Index
±±@ E
)
±±E F
)
±±F G
,
±±G H
loopContent
±±I T
,
±±T U
IncrementIndex
±±V d
)
±±d e
,
±±e f
Break
≤≤ 
(
≤≤ 

breakLabel
≤≤ (
)
≤≤( )
)
≥≥ 
,
≥≥ 

breakLabel
¥¥ 
)
¥¥ 
)
¥¥ 
;
¥¥ 
return
µµ 
Block
µµ 
(
µµ 
	variables
µµ "
,
µµ" #

statements
µµ$ .
)
µµ. /
;
µµ/ 0
}
∂∂ 	
static
∑∑ 

Expression
∑∑ 
Using
∑∑ 
(
∑∑  
List
∑∑  $
<
∑∑$ %

Expression
∑∑% /
>
∑∑/ 0

statements
∑∑1 ;
,
∑∑; <

Expression
∑∑= G
target
∑∑H N
,
∑∑N O

Expression
∑∑P Z
body
∑∑[ _
)
∑∑_ `
{
∏∏ 	

Expression
ππ 
finallyDispose
ππ %
;
ππ% &
if
∫∫ 
(
∫∫ 
typeof
∫∫ 
(
∫∫ 
IDisposable
∫∫ "
)
∫∫" #
.
∫∫# $
IsAssignableFrom
∫∫$ 4
(
∫∫4 5
target
∫∫5 ;
.
∫∫; <
Type
∫∫< @
)
∫∫@ A
)
∫∫A B
{
ªª 
finallyDispose
ºº 
=
ºº  

Expression
ºº! +
.
ºº+ ,
Call
ºº, 0
(
ºº0 1
target
ºº1 7
,
ºº7 8
DisposeMethod
ºº9 F
)
ººF G
;
ººG H
}
ΩΩ 
else
ææ 
{
øø 
if
¿¿ 
(
¿¿ 
target
¿¿ 
.
¿¿ 
Type
¿¿ 
.
¿¿  
IsValueType
¿¿  +
)
¿¿+ ,
{
¡¡ 
return
¬¬ 
body
¬¬ 
;
¬¬  
}
√√ 
var
ƒƒ 
assignDisposable
ƒƒ $
=
ƒƒ% &
Assign
ƒƒ' -
(
ƒƒ- .

Disposable
ƒƒ. 8
,
ƒƒ8 9
TypeAs
ƒƒ: @
(
ƒƒ@ A
target
ƒƒA G
,
ƒƒG H
typeof
ƒƒI O
(
ƒƒO P
IDisposable
ƒƒP [
)
ƒƒ[ \
)
ƒƒ\ ]
)
ƒƒ] ^
;
ƒƒ^ _

statements
≈≈ 
.
≈≈ 
Add
≈≈ 
(
≈≈ 
assignDisposable
≈≈ /
)
≈≈/ 0
;
≈≈0 1

statements
∆∆ 
.
∆∆ 
Add
∆∆ 
(
∆∆ 
DisposeCall
∆∆ *
)
∆∆* +
;
∆∆+ ,
finallyDispose
«« 
=
««  
Block
««! &
(
««& '
DisposableArray
««' 6
,
««6 7

statements
««8 B
)
««B C
;
««C D
}
»» 
return
…… 

TryFinally
…… 
(
…… 
body
…… "
,
……" #
finallyDispose
……$ 2
)
……2 3
;
……3 4
}
   	
}
ÀÀ 
public
ÕÕ 

static
ÕÕ 
MemberExpression
ÕÕ "
Property
ÕÕ# +
(
ÕÕ+ ,

Expression
ÕÕ, 6
target
ÕÕ7 =
,
ÕÕ= >
string
ÕÕ? E
name
ÕÕF J
)
ÕÕJ K
=>
ÕÕL N

Expression
ŒŒ 
.
ŒŒ 
Property
ŒŒ 
(
ŒŒ 
target
ŒŒ "
,
ŒŒ" #
target
ŒŒ$ *
.
ŒŒ* +
Type
ŒŒ+ /
.
ŒŒ/ 0"
GetInheritedProperty
ŒŒ0 D
(
ŒŒD E
name
ŒŒE I
)
ŒŒI J
)
ŒŒJ K
;
ŒŒK L
public
–– 

static
–– "
MethodCallExpression
–– &
Call
––' +
(
––+ ,

Expression
––, 6
target
––7 =
,
––= >
string
––? E
name
––F J
)
––J K
=>
––L N

Expression
––O Y
.
––Y Z
Call
––Z ^
(
––^ _
target
––_ e
,
––e f
target
––g m
.
––m n
Type
––n r
.
––r s!
GetInheritedMethod––s Ö
(––Ö Ü
name––Ü ä
)––ä ã
)––ã å
;––å ç
public
—— 

static
—— "
MethodCallExpression
—— &
Call
——' +
(
——+ ,

Expression
——, 6
target
——7 =
,
——= >
string
——? E
name
——F J
,
——J K

Expression
——L V
[
——V W
]
——W X
	arguments
——Y b
)
——b c
=>
——d f

Expression
““ 
.
““ 
Call
““ 
(
““ 
target
““ 
,
““ 
target
““  &
.
““& '
Type
““' +
.
““+ , 
GetInheritedMethod
““, >
(
““> ?
name
““? C
)
““C D
,
““D E
	arguments
““F O
)
““O P
;
““P Q
public
”” 

static
”” 

Expression
”” 
ToObject
”” %
(
””% &
this
””& *

Expression
””+ 5

expression
””6 @
)
””@ A
=>
””B D

expression
””E O
.
””O P
Type
””P T
.
””T U
IsValueType
””U `
?
””a b
Convert
””c j
(
””j k

expression
””k u
,
””u v
typeof
””w }
(
””} ~
object””~ Ñ
)””Ñ Ö
)””Ö Ü
:””á à

expression””â ì
;””ì î
public
‘‘ 

static
‘‘ 

Expression
‘‘ 
ToType
‘‘ #
(
‘‘# $

Expression
‘‘$ .

expression
‘‘/ 9
,
‘‘9 :
Type
‘‘; ?
type
‘‘@ D
)
‘‘D E
=>
‘‘F H

expression
‘‘I S
.
‘‘S T
Type
‘‘T X
==
‘‘Y [
type
‘‘\ `
?
‘‘a b

expression
‘‘c m
:
‘‘n o
Convert
‘‘p w
(
‘‘w x

expression‘‘x Ç
,‘‘Ç É
type‘‘Ñ à
)‘‘à â
;‘‘â ä
public
’’ 

static
’’ 

Expression
’’ 
ReplaceParameters
’’ .
(
’’. /
this
’’/ 3
LambdaExpression
’’4 D
initialLambda
’’E R
,
’’R S

Expression
’’T ^
newParameter
’’_ k
)
’’k l
=>
’’m o
new
÷÷ %
ParameterReplaceVisitor
÷÷ #
(
÷÷# $
)
÷÷$ %
.
÷÷% &
Replace
÷÷& -
(
÷÷- .
initialLambda
÷÷. ;
,
÷÷; <
newParameter
÷÷= I
)
÷÷I J
;
÷÷J K
private
◊◊ 
static
◊◊ 

Expression
◊◊ 
Replace
◊◊ %
(
◊◊% &
this
◊◊& *%
ParameterReplaceVisitor
◊◊+ B
visitor
◊◊C J
,
◊◊J K
LambdaExpression
◊◊L \
initialLambda
◊◊] j
,
◊◊j k

Expression
◊◊l v
newParameter◊◊w É
)◊◊É Ñ
=>◊◊Ö á
visitor
ÿÿ 
.
ÿÿ 
Replace
ÿÿ 
(
ÿÿ 
initialLambda
ÿÿ %
.
ÿÿ% &
Body
ÿÿ& *
,
ÿÿ* +
initialLambda
ÿÿ, 9
.
ÿÿ9 :

Parameters
ÿÿ: D
[
ÿÿD E
$num
ÿÿE F
]
ÿÿF G
,
ÿÿG H
newParameter
ÿÿI U
)
ÿÿU V
;
ÿÿV W
private
ŸŸ 
static
ŸŸ 

Expression
ŸŸ 
Replace
ŸŸ %
(
ŸŸ% &
this
ŸŸ& *%
ParameterReplaceVisitor
ŸŸ+ B
visitor
ŸŸC J
,
ŸŸJ K
LambdaExpression
ŸŸL \
initialLambda
ŸŸ] j
,
ŸŸj k

Expression
ŸŸl v
[
ŸŸv w
]
ŸŸw x
newParametersŸŸy Ü
)ŸŸÜ á
{
⁄⁄ 
var
€€ 
	newLambda
€€ 
=
€€ 
initialLambda
€€ %
.
€€% &
Body
€€& *
;
€€* +
for
‹‹ 
(
‹‹ 
var
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹ 
<
‹‹ 
Math
‹‹  
.
‹‹  !
Min
‹‹! $
(
‹‹$ %
newParameters
‹‹% 2
.
‹‹2 3
Length
‹‹3 9
,
‹‹9 :
initialLambda
‹‹; H
.
‹‹H I

Parameters
‹‹I S
.
‹‹S T
Count
‹‹T Y
)
‹‹Y Z
;
‹‹Z [
i
‹‹\ ]
++
‹‹] _
)
‹‹_ `
{
›› 	
	newLambda
ﬁﬁ 
=
ﬁﬁ 
visitor
ﬁﬁ 
.
ﬁﬁ  
Replace
ﬁﬁ  '
(
ﬁﬁ' (
	newLambda
ﬁﬁ( 1
,
ﬁﬁ1 2
initialLambda
ﬁﬁ3 @
.
ﬁﬁ@ A

Parameters
ﬁﬁA K
[
ﬁﬁK L
i
ﬁﬁL M
]
ﬁﬁM N
,
ﬁﬁN O
newParameters
ﬁﬁP ]
[
ﬁﬁ] ^
i
ﬁﬁ^ _
]
ﬁﬁ_ `
)
ﬁﬁ` a
;
ﬁﬁa b
}
ﬂﬂ 	
return
‡‡ 
	newLambda
‡‡ 
;
‡‡ 
}
·· 
public
‚‚ 

static
‚‚ 

Expression
‚‚ 
Replace
‚‚ $
(
‚‚$ %
this
‚‚% )

Expression
‚‚* 4
exp
‚‚5 8
,
‚‚8 9

Expression
‚‚: D
old
‚‚E H
,
‚‚H I

Expression
‚‚J T
replace
‚‚U \
)
‚‚\ ]
=>
‚‚^ `
new
‚‚a d
ReplaceVisitor
‚‚e s
(
‚‚s t
)
‚‚t u
.
‚‚u v
Replace
‚‚v }
(
‚‚} ~
exp‚‚~ Å
,‚‚Å Ç
old‚‚É Ü
,‚‚Ü á
replace‚‚à è
)‚‚è ê
;‚‚ê ë
public
„„ 

static
„„ 

Expression
„„ 
	NullCheck
„„ &
(
„„& '
this
„„' +

Expression
„„, 6

expression
„„7 A
,
„„A B"
IGlobalConfiguration
„„C W
configuration
„„X e
,
„„e f
	MemberMap
„„g p
	memberMap
„„q z
=
„„{ |
null„„} Å
,„„Å Ç

Expression„„É ç
defaultValue„„é ö
=„„õ ú
null„„ù °
,„„° ¢
IncludedMember„„£ ±
includedMember„„≤ ¿
=„„¡ ¬
null„„√ «
)„„« »
{
‰‰ 
var
ÂÂ 
chain
ÂÂ 
=
ÂÂ 

expression
ÂÂ 
.
ÂÂ 
GetChain
ÂÂ '
(
ÂÂ' (
)
ÂÂ( )
;
ÂÂ) *
var
ÊÊ 
min
ÊÊ 
=
ÊÊ 
(
ÊÊ 
includedMember
ÊÊ !
??
ÊÊ" $
	memberMap
ÊÊ% .
?
ÊÊ. /
.
ÊÊ/ 0
IncludedMember
ÊÊ0 >
)
ÊÊ> ?
==
ÊÊ@ B
null
ÊÊC G
?
ÊÊH I
$num
ÊÊJ K
:
ÊÊL M
$num
ÊÊN O
;
ÊÊO P
if
ÁÁ 

(
ÁÁ 
chain
ÁÁ 
.
ÁÁ 
Count
ÁÁ 
<
ÁÁ 
min
ÁÁ 
||
ÁÁ  
chain
ÁÁ! &
.
ÁÁ& '
Peek
ÁÁ' +
(
ÁÁ+ ,
)
ÁÁ, -
.
ÁÁ- .
Target
ÁÁ. 4
is
ÁÁ5 7
not
ÁÁ8 ;!
ParameterExpression
ÁÁ< O
	parameter
ÁÁP Y
)
ÁÁY Z
{
ËË 	
return
ÈÈ 

expression
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
var
ÎÎ 
destinationType
ÎÎ 
=
ÎÎ 
	memberMap
ÎÎ '
?
ÎÎ' (
.
ÎÎ( )
DestinationType
ÎÎ) 8
;
ÎÎ8 9
var
ÏÏ 

returnType
ÏÏ 
=
ÏÏ 
(
ÏÏ 
destinationType
ÏÏ )
!=
ÏÏ* ,
null
ÏÏ- 1
&&
ÏÏ2 4
destinationType
ÏÏ5 D
!=
ÏÏE G

expression
ÏÏH R
.
ÏÏR S
Type
ÏÏS W
&&
ÏÏX Z
Nullable
ÏÏ[ c
.
ÏÏc d
GetUnderlyingType
ÏÏd u
(
ÏÏu v
destinationTypeÏÏv Ö
)ÏÏÖ Ü
==ÏÏá â

expressionÏÏä î
.ÏÏî ï
TypeÏÏï ô
)ÏÏô ö
?ÏÏõ ú
destinationType
ÌÌ 
:
ÌÌ 

expression
ÌÌ (
.
ÌÌ( )
Type
ÌÌ) -
;
ÌÌ- .
var
ÓÓ 
defaultReturn
ÓÓ 
=
ÓÓ 
(
ÓÓ 
defaultValue
ÓÓ )
is
ÓÓ* ,
{
ÓÓ- .
NodeType
ÓÓ/ 7
:
ÓÓ7 8
ExpressionType
ÓÓ9 G
.
ÓÓG H
Default
ÓÓH O
}
ÓÓP Q
&&
ÓÓR T
defaultValue
ÓÓU a
.
ÓÓa b
Type
ÓÓb f
==
ÓÓg i

returnType
ÓÓj t
)
ÓÓt u
?
ÓÓv w
defaultValueÓÓx Ñ
:ÓÓÖ Ü
configurationÓÓá î
.ÓÓî ï
DefaultÓÓï ú
(ÓÓú ù

returnTypeÓÓù ß
)ÓÓß ®
;ÓÓ® ©
List
ÔÔ 
<
ÔÔ !
ParameterExpression
ÔÔ  
>
ÔÔ  !
	variables
ÔÔ" +
=
ÔÔ, -
null
ÔÔ. 2
;
ÔÔ2 3
List
 
<
 

Expression
 
>
 
expressions
 $
=
% &
null
' +
;
+ ,
var
ÒÒ 
name
ÒÒ 
=
ÒÒ 
	parameter
ÒÒ 
.
ÒÒ 
Name
ÒÒ !
;
ÒÒ! "
var
ÚÚ #
nullCheckedExpression
ÚÚ !
=
ÚÚ" #
	NullCheck
ÚÚ$ -
(
ÚÚ- .
	parameter
ÚÚ. 7
)
ÚÚ7 8
;
ÚÚ8 9
if
ÛÛ 

(
ÛÛ 
	variables
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
{
ÙÙ 	
return
ıı #
nullCheckedExpression
ıı (
;
ıı( )
}
ˆˆ 	
expressions
˜˜ 
.
˜˜ 
Add
˜˜ 
(
˜˜ #
nullCheckedExpression
˜˜ -
)
˜˜- .
;
˜˜. /
return
¯¯ 
Block
¯¯ 
(
¯¯ 
	variables
¯¯ 
,
¯¯  
expressions
¯¯! ,
)
¯¯, -
;
¯¯- .

Expression
˘˘ 
	NullCheck
˘˘ 
(
˘˘ 

Expression
˘˘ '
variable
˘˘( 0
)
˘˘0 1
{
˙˙ 	
var
˚˚ 
member
˚˚ 
=
˚˚ 
chain
˚˚ 
.
˚˚ 
Pop
˚˚ "
(
˚˚" #
)
˚˚# $
;
˚˚$ %
var
¸¸ 
skipNullCheck
¸¸ 
=
¸¸ 
min
¸¸  #
==
¸¸$ &
$num
¸¸' (
&&
¸¸) +
variable
¸¸, 4
==
¸¸5 7
	parameter
¸¸8 A
;
¸¸A B
if
˝˝ 
(
˝˝ 
chain
˝˝ 
.
˝˝ 
Count
˝˝ 
==
˝˝ 
$num
˝˝  
)
˝˝  !
{
˛˛ 
var
ˇˇ 
updated
ˇˇ 
=
ˇˇ 
UpdateTarget
ˇˇ *
(
ˇˇ* +

expression
ˇˇ+ 5
,
ˇˇ5 6
variable
ˇˇ7 ?
)
ˇˇ? @
;
ˇˇ@ A
return
ÄÄ 
skipNullCheck
ÄÄ %
?
ÄÄ& '
updated
ÄÄ( /
:
ÄÄ0 1
variable
ÄÄ2 :
.
ÄÄ: ;

IfNullElse
ÄÄ; E
(
ÄÄE F
defaultReturn
ÄÄF S
,
ÄÄS T
updated
ÄÄU \
)
ÄÄ\ ]
;
ÄÄ] ^
}
ÅÅ 
if
ÇÇ 
(
ÇÇ 
	variables
ÇÇ 
==
ÇÇ 
null
ÇÇ !
)
ÇÇ! "
{
ÉÉ 
(
ÑÑ 
	variables
ÑÑ 
,
ÑÑ 
expressions
ÑÑ '
)
ÑÑ' (
=
ÑÑ) *
configuration
ÑÑ+ 8
.
ÑÑ8 9

Scratchpad
ÑÑ9 C
(
ÑÑC D
)
ÑÑD E
;
ÑÑE F
}
ÖÖ 
name
ÜÜ 
+=
ÜÜ 
member
ÜÜ 
.
ÜÜ 

MemberInfo
ÜÜ %
.
ÜÜ% &
Name
ÜÜ& *
;
ÜÜ* +
var
áá 
newVariable
áá 
=
áá 
Variable
áá &
(
áá& '
member
áá' -
.
áá- .

Expression
áá. 8
.
áá8 9
Type
áá9 =
,
áá= >
name
áá? C
)
ááC D
;
ááD E
	variables
àà 
.
àà 
Add
àà 
(
àà 
newVariable
àà %
)
àà% &
;
àà& '
var
ââ 

assignment
ââ 
=
ââ 
Assign
ââ #
(
ââ# $
newVariable
ââ$ /
,
ââ/ 0
UpdateTarget
ââ1 =
(
ââ= >
member
ââ> D
.
ââD E

Expression
ââE O
,
ââO P
variable
ââQ Y
)
ââY Z
)
ââZ [
;
ââ[ \
var
ää 
block
ää 
=
ää 
Block
ää 
(
ää 

assignment
ää (
,
ää( )
	NullCheck
ää* 3
(
ää3 4
newVariable
ää4 ?
)
ää? @
)
ää@ A
;
ääA B
return
ãã 
skipNullCheck
ãã  
?
ãã! "
block
ãã# (
:
ãã) *
variable
ãã+ 3
.
ãã3 4

IfNullElse
ãã4 >
(
ãã> ?
defaultReturn
ãã? L
,
ããL M
block
ããN S
)
ããS T
;
ããT U
}
åå 	
static
çç 

Expression
çç 
UpdateTarget
çç &
(
çç& '

Expression
çç' 1
sourceExpression
çç2 B
,
ççB C

Expression
ççD N
	newTarget
ççO X
)
ççX Y
=>
ççZ \
sourceExpression
çç] m
switch
ççn t
{
éé 	
MemberExpression
èè 
memberExpression
èè -
=>
èè. 0
memberExpression
èè1 A
.
èèA B
Update
èèB H
(
èèH I
	newTarget
èèI R
)
èèR S
,
èèS T"
MethodCallExpression
êê  
{
êê! "
Object
êê# )
:
êê) *
null
êê+ /
,
êê/ 0
	Arguments
êê1 :
:
êê: ;
var
êê< ?
args
êê@ D
}
êêE F

methodCall
êêG Q
when
êêR V
args
êêW [
[
êê[ \
$num
êê\ ]
]
êê] ^
!=
êê_ a
	newTarget
êêb k
=>
êêl n
ExtensionMethod
ëë 
(
ëë  

methodCall
ëë  *
.
ëë* +
Method
ëë+ 1
,
ëë1 2
	newTarget
ëë3 <
,
ëë< =
args
ëë> B
)
ëëB C
,
ëëC D"
MethodCallExpression
íí  
{
íí! "
Object
íí# )
:
íí) *

Expression
íí+ 5
target
íí6 <
}
íí= >

methodCall
íí? I
when
ííJ N
target
ííO U
!=
ííV X
	newTarget
ííY b
=>
ííc e

Expression
ìì 
.
ìì 
Call
ìì 
(
ìì  
	newTarget
ìì  )
,
ìì) *

methodCall
ìì+ 5
.
ìì5 6
Method
ìì6 <
,
ìì< =

methodCall
ìì> H
.
ììH I
	Arguments
ììI R
)
ììR S
,
ììS T
_
îî 
=>
îî 
sourceExpression
îî !
,
îî! "
}
ïï 	
;
ïï	 

static
ññ "
MethodCallExpression
ññ #
ExtensionMethod
ññ$ 3
(
ññ3 4

MethodInfo
ññ4 >
method
ññ? E
,
ññE F

Expression
ññG Q
	newTarget
ññR [
,
ññ[ \ 
ReadOnlyCollection
ññ] o
<
ñño p

Expression
ññp z
>
ññz {
argsññ| Ä
)ññÄ Å
{
óó 	
var
òò 
newArgs
òò 
=
òò 
args
òò 
.
òò 
ToArray
òò &
(
òò& '
)
òò' (
;
òò( )
newArgs
ôô 
[
ôô 
$num
ôô 
]
ôô 
=
ôô 
	newTarget
ôô "
;
ôô" #
return
öö 

Expression
öö 
.
öö 
Call
öö "
(
öö" #
method
öö# )
,
öö) *
newArgs
öö+ 2
)
öö2 3
;
öö3 4
}
õõ 	
}
úú 
public
ùù 

static
ùù 

Expression
ùù 

IfNullElse
ùù '
(
ùù' (
this
ùù( ,

Expression
ùù- 7

expression
ùù8 B
,
ùùB C

Expression
ùùD N
then
ùùO S
,
ùùS T

Expression
ùùU _
@else
ùù` e
)
ùùe f
=>
ùùg i

expression
ùùj t
.
ùùt u
Type
ùùu y
.
ùùy z
IsValueTypeùùz Ö
?ùùÜ á
(
ûû 	

expression
ûû	 
.
ûû 
Type
ûû 
.
ûû 
IsNullableType
ûû '
(
ûû' (
)
ûû( )
?
ûû* +
	Condition
ûû, 5
(
ûû5 6
Property
ûû6 >
(
ûû> ?

expression
ûû? I
,
ûûI J
$str
ûûK U
)
ûûU V
,
ûûV W
ToType
ûûX ^
(
ûû^ _
@else
ûû_ d
,
ûûd e
then
ûûf j
.
ûûj k
Type
ûûk o
)
ûûo p
,
ûûp q
then
ûûr v
)
ûûv w
:
ûûx y
@else
ûûz 
)ûû Ä
:ûûÅ Ç
	Condition
üü 
(
üü 
ReferenceEqual
üü  
(
üü  !

expression
üü! +
,
üü+ ,
Null
üü- 1
)
üü1 2
,
üü2 3
then
üü4 8
,
üü8 9
ToType
üü: @
(
üü@ A
@else
üüA F
,
üüF G
then
üüH L
.
üüL M
Type
üüM Q
)
üüQ R
)
üüR S
;
üüS T
}†† 
public°° 
readonly
°° 
record
°° 
struct
°° 
Member
°° $
(
°°$ %

Expression
°°% /

Expression
°°0 :
,
°°: ;

MemberInfo
°°< F

MemberInfo
°°G Q
,
°°Q R

Expression
°°S ]
Target
°°^ d
)
°°d e
;
°°e f
public¢¢ 
class
¢¢  
ReplaceVisitorBase
¢¢ 
:
¢¢  !
ExpressionVisitor
¢¢" 3
{££ 
private
§§ 
	protected
§§ 

Expression
§§  
_oldNode
§§! )
;
§§) *
private
•• 
	protected
•• 

Expression
••  
_newNode
••! )
;
••) *
public
¶¶ 

virtual
¶¶ 

Expression
¶¶ 
Replace
¶¶ %
(
¶¶% &

Expression
¶¶& 0
target
¶¶1 7
,
¶¶7 8

Expression
¶¶9 C
oldNode
¶¶D K
,
¶¶K L

Expression
¶¶M W
newNode
¶¶X _
)
¶¶_ `
{
ßß 
_oldNode
®® 
=
®® 
oldNode
®® 
;
®® 
_newNode
©© 
=
©© 
newNode
©© 
;
©© 
return
™™ 
base
™™ 
.
™™ 
Visit
™™ 
(
™™ 
target
™™  
)
™™  !
;
™™! "
}
´´ 
}¨¨ 
public≠≠ 
class
≠≠ 
ReplaceVisitor
≠≠ 
:
≠≠  
ReplaceVisitorBase
≠≠ 0
{ÆÆ 
public
ØØ 

override
ØØ 

Expression
ØØ 
Visit
ØØ $
(
ØØ$ %

Expression
ØØ% /
node
ØØ0 4
)
ØØ4 5
=>
ØØ6 8
_oldNode
ØØ9 A
==
ØØB D
node
ØØE I
?
ØØJ K
_newNode
ØØL T
:
ØØU V
base
ØØW [
.
ØØ[ \
Visit
ØØ\ a
(
ØØa b
node
ØØb f
)
ØØf g
;
ØØg h
}∞∞ 
public±± 
class
±± %
ParameterReplaceVisitor
±± $
:
±±% & 
ReplaceVisitorBase
±±' 9
{≤≤ 
	protected
≥≥ 
override
≥≥ 

Expression
≥≥ !
VisitParameter
≥≥" 0
(
≥≥0 1!
ParameterExpression
≥≥1 D
node
≥≥E I
)
≥≥I J
=>
≥≥K M
_oldNode
≥≥N V
==
≥≥W Y
node
≥≥Z ^
?
≥≥_ `
_newNode
≥≥a i
:
≥≥j k
base
≥≥l p
.
≥≥p q
VisitParameter
≥≥q 
(≥≥ Ä
node≥≥Ä Ñ
)≥≥Ñ Ö
;≥≥Ö Ü
}¥¥ 
publicµµ 
class
µµ ,
ConvertParameterReplaceVisitor
µµ +
:
µµ, -%
ParameterReplaceVisitor
µµ. E
{∂∂ 
public
∑∑ 

override
∑∑ 

Expression
∑∑ 
Replace
∑∑ &
(
∑∑& '

Expression
∑∑' 1
target
∑∑2 8
,
∑∑8 9

Expression
∑∑: D
oldNode
∑∑E L
,
∑∑L M

Expression
∑∑N X
newNode
∑∑Y `
)
∑∑` a
=>
∑∑b d
base
∏∏ 
.
∏∏ 
Replace
∏∏ 
(
∏∏ 
target
∏∏ 
,
∏∏ 
oldNode
∏∏ $
,
∏∏$ %
ToType
∏∏& ,
(
∏∏, -
newNode
∏∏- 4
,
∏∏4 5
oldNode
∏∏6 =
.
∏∏= >
Type
∏∏> B
)
∏∏B C
)
∏∏C D
;
∏∏D E
}ππ çQ
JC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\ConstructorMap.cs
	namespace 	

AutoMapper
 
; 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 
ConstructorMap "
{ 
private 
bool 
? 
_canResolve 
; 
private 
readonly 
List 
< #
ConstructorParameterMap 1
>1 2
_ctorParams3 >
=? @
[A B
]B C
;C D
public 

ConstructorInfo 
Ctor 
{  !
get" %
;% &
private' .
set/ 2
;2 3
}4 5
public 

IReadOnlyCollection 
< #
ConstructorParameterMap 6
>6 7

CtorParams8 B
=>C E
_ctorParamsF Q
;Q R
public		 

void		 
Reset		 
(		 
ConstructorInfo		 %
ctor		& *
)		* +
{

 
Ctor 
= 
ctor 
; 
_ctorParams 
. 
Clear 
( 
) 
; 
_canResolve 
= 
null 
; 
} 
public 

bool 

CanResolve 
{ 
get 
=> 
_canResolve 
??=  
ParametersCanResolve 3
(3 4
)4 5
;5 6
set 
=> 
_canResolve 
= 
value "
;" #
} 
bool  
ParametersCanResolve	 
( 
) 
{ 
foreach 
( 
var 
param 
in 
_ctorParams )
)) *
{ 	
if 
( 
! 
param 
. 
IsMapped 
)  
{ 
return 
false 
; 
} 
} 	
return 
true 
; 
} 
public 
#
ConstructorParameterMap "
this# '
[' (
string( .
name/ 3
]3 4
{   
get!! 
{"" 	
foreach## 
(## 
var## 
param## 
in## !
_ctorParams##" -
)##- .
{$$ 
if%% 
(%% 
param%% 
.%% 
DestinationName%% )
.%%) *
Equals%%* 0
(%%0 1
name%%1 5
,%%5 6
StringComparison%%7 G
.%%G H
OrdinalIgnoreCase%%H Y
)%%Y Z
)%%Z [
{&& 
return'' 
param''  
;''  !
}(( 
})) 
return** 
null** 
;** 
}++ 	
},, 
public-- 

void-- 
AddParameter-- 
(-- 
ParameterInfo-- *
	parameter--+ 4
,--4 5
IEnumerable--6 A
<--A B

MemberInfo--B L
>--L M
sourceMembers--N [
,--[ \
TypeMap--] d
typeMap--e l
)--l m
=>--n p
_ctorParams--q |
.--| }
Add	--} Ä
(
--Ä Å
new
--Å Ñ
(
--Ñ Ö
typeMap
--Ö å
,
--å ç
	parameter
--é ó
,
--ó ò
sourceMembers
--ô ¶
.
--¶ ß
ToArray
--ß Æ
(
--Æ Ø
)
--Ø ∞
)
--∞ ±
)
--± ≤
;
--≤ ≥
public.. 

bool.. 
ApplyMap.. 
(.. 
TypeMap..  
typeMap..! (
,..( )
IncludedMember..* 8
includedMember..9 G
=..H I
null..J N
)..N O
{// 
var00 
constructorMap00 
=00 
typeMap00 $
.00$ %
ConstructorMap00% 3
;003 4
if11 

(11
 
constructorMap11 
==11 
null11 !
)11! "
{22 	
return33 
false33 
;33 
}44 	
bool55 
applied55 
=55 
false55 
;55 
foreach66 
(66 
var66 
parameterMap66  
in66! #
_ctorParams66$ /
)66/ 0
{77 	
var88 !
inheritedParameterMap88 %
=88& '
constructorMap88( 6
[886 7
parameterMap887 C
.88C D
DestinationName88D S
]88S T
;88T U
if99 
(99 !
inheritedParameterMap99 $
is99% '
not99( +
{99, -
IsMapped99. 6
:996 7
true998 <
,99< =
DestinationType99> M
:99M N
var99O R
type99S W
}99X Y
||99Z \
type99] a
!=99b d
parameterMap99e q
.99q r
DestinationType	99r Å
||
99Ç Ñ
!
99Ö Ü
parameterMap
99Ü í
.
99í ì
ApplyMap
99ì õ
(
99õ ú#
inheritedParameterMap
99ú ±
,
99± ≤
includedMember
99≥ ¡
)
99¡ ¬
)
99¬ √
{:: 
continue;; 
;;; 
}<< 
applied== 
=== 
true== 
;== 
_canResolve>> 
=>> 
null>> 
;>> 
}?? 	
return@@ 
applied@@ 
;@@ 
}AA 
}BB 
[CC 
EditorBrowsableCC 
(CC  
EditorBrowsableStateCC %
.CC% &
NeverCC& +
)CC+ ,
]CC, -
publicDD 
classDD #
ConstructorParameterMapDD $
:DD% &
	MemberMapDD' 0
{EE 
publicFF 
#
ConstructorParameterMapFF "
(FF" #
TypeMapFF# *
typeMapFF+ 2
,FF2 3
ParameterInfoFF4 A
	parameterFFB K
,FFK L

MemberInfoFFM W
[FFW X
]FFX Y
sourceMembersFFZ g
)FFg h
:FFi j
baseFFk o
(FFo p
typeMapFFp w
,FFw x
	parameter	FFy Ç
.
FFÇ É
ParameterType
FFÉ ê
)
FFê ë
{GG 
	ParameterHH 
=HH 
	parameterHH 
;HH 
ifII 

(II
 
DestinationTypeII 
.II 
IsByRefII "
)II" #
{JJ 	
DestinationTypeKK 
=KK 
DestinationTypeKK -
.KK- .
GetElementTypeKK. <
(KK< =
)KK= >
;KK> ?
}LL 	
ifMM 

(MM 
sourceMembersMM 
.MM 
LengthMM  
>MM! "
$numMM# $
)MM$ %
{NN 	
MapByConventionOO 
(OO 
sourceMembersOO )
)OO) *
;OO* +
}PP 	
elseQQ 
{RR 	
SourceMembersSS 
=SS 
[SS 
]SS 
;SS 
}TT 	
}UU 
publicVV 

ParameterInfoVV 
	ParameterVV "
{VV# $
getVV% (
;VV( )
}VV* +
publicWW 

overrideWW 
IncludedMemberWW "
IncludedMemberWW# 1
{WW2 3
getWW4 7
;WW7 8
	protectedWW9 B
setWWC F
;WWF G
}WWH I
publicXX 

overrideXX 

MemberInfoXX 
[XX 
]XX  
SourceMembersXX! .
{XX/ 0
getXX1 4
;XX4 5
setXX6 9
;XX9 :
}XX; <
publicYY 

overrideYY 
stringYY 
DestinationNameYY *
=>YY+ -
	ParameterYY. 7
.YY7 8
NameYY8 <
;YY< =
publicZZ 


ExpressionZZ 
DefaultValueZZ "
(ZZ" # 
IGlobalConfigurationZZ# 7
configurationZZ8 E
)ZZE F
=>ZZG I
	ParameterZZJ S
.ZZS T

IsOptionalZZT ^
?ZZ_ `
	ParameterZZa j
.ZZj k
GetDefaultValueZZk z
(ZZz {
configuration	ZZ{ à
)
ZZà â
:
ZZä ã
configuration
ZZå ô
.
ZZô ö
Default
ZZö °
(
ZZ° ¢
DestinationType
ZZ¢ ±
)
ZZ± ≤
;
ZZ≤ ≥
public[[ 

override[[ 
string[[ 
ToString[[ #
([[# $
)[[$ %
=>[[& (
$"[[) +
{[[+ ,
	Parameter[[, 5
.[[5 6
Member[[6 <
}[[< =
$str[[= I
{[[I J
DestinationName[[J Y
}[[Y Z
"[[Z [
;[[[ \
public\\ 

bool\\ 
ApplyMap\\ 
(\\ #
ConstructorParameterMap\\ 0!
inheritedParameterMap\\1 F
,\\F G
IncludedMember\\H V
includedMember\\W e
)\\e f
{]] 
if^^ 

(^^
 
includedMember^^ 
!=^^ 
null^^ !
&&^^" $
IsMapped^^% -
)^^- .
{__ 	
return`` 
false`` 
;`` 
}aa 	
ExplicitExpansionbb 
??=bb !
inheritedParameterMapbb 3
.bb3 4
ExplicitExpansionbb4 E
;bbE F
ifcc 

(cc
 
ApplyInheritedMapcc 
(cc !
inheritedParameterMapcc 2
)cc2 3
)cc3 4
{dd 	
IncludedMemberee 
=ee 
includedMemberee +
?ee+ ,
.ee, -
Chainee- 2
(ee2 3!
inheritedParameterMapee3 H
.eeH I
IncludedMembereeI W
)eeW X
;eeX Y
returnff 
trueff 
;ff 
}gg 	
returnhh 
falsehh 
;hh 
}ii 
publicjj 

overridejj 
booljj 
?jj 
ExplicitExpansionjj +
{jj, -
getjj. 1
;jj1 2
setjj3 6
;jj6 7
}jj8 9
}kk çô
^C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\TypeMapConfiguration.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
abstract 
class  
TypeMapConfiguration *
(* +

MemberList+ 5

memberList6 @
,@ A
TypePairB J
typesK P
)P Q
{ 
private 
List 
< )
ValueTransformerConfiguration .
>. /
_valueTransformers0 B
;B C
private 
Features 
< 
IMappingFeature $
>$ %
	_features& /
;/ 0
private 
List 
< &
ISourceMemberConfiguration +
>+ ,'
_sourceMemberConfigurations- H
;H I
private		 
List		 
<		 '
ICtorParameterConfiguration		 ,
>		, -$
_ctorParamConfigurations		. F
;		F G
private

 
List

 
<

 %
IPropertyMapConfiguration

 *
>

* +!
_memberConfigurations

, A
;

A B
private 
readonly 

MemberList 
_memberList  +
=, -

memberList. 8
;8 9
private 
readonly 
TypePair 
_types $
=% &
types' ,
;, -
public 

Type #
DestinationTypeOverride '
{( )
get* -
;- .
	protected/ 8
set9 <
;< =
}> ?
	protected 
bool 

Projection 
{ 
get  #
;# $
set% (
;( )
}* +
public 

TypePair 
Types 
=> 
_types #
;# $
public 

bool 
IsReverseMap 
{ 
get "
;" #
set$ '
;' (
}) *
public 

bool 
HasTypeConverter  
{! "
get# &
;& '
	protected( 1
set2 5
;5 6
}7 8
public 

TypeMap 
TypeMap 
{ 
get  
;  !
private" )
set* -
;- .
}/ 0
public 

Type 

SourceType 
=> 
_types $
.$ %

SourceType% /
;/ 0
public 

Type 
DestinationType 
=>  "
_types# )
.) *
DestinationType* 9
;9 :
public 

Features 
< 
IMappingFeature #
># $
Features% -
=>. 0
	_features1 :
??=; >
new? B
(B C
)C D
;D E
public 
 
TypeMapConfiguration 
ReverseTypeMap  .
=>/ 1 
ReverseMapExpression2 F
;F G
public 

List 
< )
ValueTransformerConfiguration -
>- .
ValueTransformers/ @
=>A C
_valueTransformersD V
??=W Z
[[ \
]\ ]
;] ^
	protected  
TypeMapConfiguration " 
ReverseMapExpression# 7
{8 9
get: =
;= >
set? B
;B C
}D E
	protected 
List 
< 
Action 
< 
TypeMap !
>! "
>" #
TypeMapActions$ 2
{3 4
get5 8
;8 9
}: ;
=< =
[> ?
]? @
;@ A
	protected 
List 
< %
IPropertyMapConfiguration ,
>, - 
MemberConfigurations. B
=>C E!
_memberConfigurationsF [
??=\ _
[` a
]a b
;b c
	protected 
List 
< &
ISourceMemberConfiguration -
>- .&
SourceMemberConfigurations/ I
=>J L'
_sourceMemberConfigurationsM h
??=i l
[m n
]n o
;o p
	protected 
List 
< '
ICtorParameterConfiguration .
>. /#
CtorParamConfigurations0 G
=>H J$
_ctorParamConfigurationsK c
??=d g
[h i
]i j
;j k
public 

void 
	Configure 
( 
TypeMap !
typeMap" )
,) *
List+ /
</ 0

MemberInfo0 :
>: ;
sourceMembers< I
)I J
{ 
TypeMap 
= 
typeMap 
; 
typeMap   
.   

Projection   
=   

Projection   '
;  ' (
typeMap!! 
.!!  
ConfiguredMemberList!! $
=!!% &
_memberList!!' 2
;!!2 3
foreach"" 
("" 
var"" 
action"" 
in"" 
TypeMapActions"" -
)""- .
{## 	
action$$ 
($$ 
typeMap$$ 
)$$ 
;$$ 
}%% 	
if&& 

(&& 
typeMap&& 
.&& 
ConstructorMap&& "
==&&# %
null&&& *
&&&&+ -
typeMap&&. 5
.&&5 6
CanConstructorMap&&6 G
(&&G H
)&&H I
)&&I J
{'' 	&
MapDestinationCtorToSource(( &
(((& '
typeMap((' .
,((. /
sourceMembers((0 =
)((= >
;((> ?
})) 	
if** 

(** !
_memberConfigurations** !
!=**" $
null**% )
)**) *
{++ 	
foreach,, 
(,, 
var,, 
memberConfig,, %
in,,& (!
_memberConfigurations,,) >
),,> ?
{-- 
memberConfig.. 
... 
	Configure.. &
(..& '
typeMap..' .
)... /
;../ 0
}// 
}00 	
if11 

(11 '
_sourceMemberConfigurations11 '
!=11( *
null11+ /
)11/ 0
{22 	*
AddSourceMembersConfigurations33 *
(33* +
typeMap33+ 2
)332 3
;333 4
}44 	
if55 

(55 $
_ctorParamConfigurations55 $
!=55% '
null55( ,
)55, -
{66 	&
AddCtorParamConfigurations77 &
(77& '
typeMap77' .
)77. /
;77/ 0
}88 	
if99 

(99 
_valueTransformers99 
!=99 !
null99" &
)99& '
{:: 	 
AddValueTransformers;;  
(;;  !
typeMap;;! (
);;( )
;;;) *
}<< 	
	_features== 
?== 
.== 
	Configure== 
(== 
typeMap== $
)==$ %
;==% &
if>> 

(>>  
ReverseMapExpression>>  
!=>>! #
null>>$ (
)>>( )
{?? 	
ConfigureReverseMap@@ 
(@@  
typeMap@@  '
)@@' (
;@@( )
}AA 	
}BB 
	protectedCC 
voidCC 
ReverseMapCoreCC !
(CC! " 
TypeMapConfigurationCC" 6

reverseMapCC7 A
)CCA B
{DD  
ReverseMapExpressionEE 
=EE 

reverseMapEE )
;EE) *
ifFF 

(FF !
_memberConfigurationsFF !
!=FF" $
nullFF% )
)FF) *
{GG 	

reverseMapHH 
.HH  
MemberConfigurationsHH +
.HH+ ,
AddRangeHH, 4
(HH4 5!
_memberConfigurationsHH5 J
.HHJ K
SelectHHK Q
(HHQ R
mHHR S
=>HHT V
mHHW X
.HHX Y
ReverseHHY `
(HH` a
)HHa b
)HHb c
.HHc d
WhereHHd i
(HHi j
mHHj k
=>HHl n
mHHo p
!=HHq s
nullHHt x
)HHx y
)HHy z
;HHz {
}II 	
	_featuresJJ 
?JJ 
.JJ 
	ReverseToJJ 
(JJ 

reverseMapJJ '
.JJ' (
FeaturesJJ( 0
)JJ0 1
;JJ1 2
}KK 
privateLL 
voidLL &
AddCtorParamConfigurationsLL +
(LL+ ,
TypeMapLL, 3
typeMapLL4 ;
)LL; <
{MM 
foreachNN 
(NN 
varNN 
paramConfigNN  
inNN! #$
_ctorParamConfigurationsNN$ <
)NN< =
{OO 	
paramConfigPP 
.PP 
	ConfigurePP !
(PP! "
typeMapPP" )
)PP) *
;PP* +
}QQ 	
}RR 
privateSS 
voidSS *
AddSourceMembersConfigurationsSS /
(SS/ 0
TypeMapSS0 7
typeMapSS8 ?
)SS? @
{TT 
foreachUU 
(UU 
varUU 
memberConfigUU !
inUU" $'
_sourceMemberConfigurationsUU% @
)UU@ A
{VV 	
memberConfigWW 
.WW 
	ConfigureWW "
(WW" #
typeMapWW# *
)WW* +
;WW+ ,
}XX 	
}YY 
privateZZ 
voidZZ  
AddValueTransformersZZ %
(ZZ% &
TypeMapZZ& -
typeMapZZ. 5
)ZZ5 6
{[[ 
foreach\\ 
(\\ 
var\\ 
valueTransformer\\ %
in\\& (
_valueTransformers\\) ;
)\\; <
{]] 	
typeMap^^ 
.^^ "
AddValueTransformation^^ *
(^^* +
valueTransformer^^+ ;
)^^; <
;^^< =
}__ 	
}`` 
privateaa 
voidaa 
ConfigureReverseMapaa $
(aa$ %
TypeMapaa% ,
typeMapaa- 4
)aa4 5
{bb 
ifcc 

(cc 
!cc 
typeMapcc 
.cc 
Typescc 
.cc %
ContainsGenericParameterscc 4
)cc4 5
{dd 	 
ReverseSourceMembersee  
(ee  !
typeMapee! (
)ee( )
;ee) *
}ff 	
foreachgg 
(gg 
vargg 
destPropertygg !
ingg" $
typeMapgg% ,
.gg, -
PropertyMapsgg- 9
.gg9 :
Wheregg: ?
(gg? @
pmgg@ B
=>ggC E
pmggF H
.ggH I
IgnoredggI P
)ggP Q
)ggQ R
{hh 	 
ReverseMapExpressionii  
.ii  !
ForSourceMemberCoreii! 4
(ii4 5
destPropertyii5 A
.iiA B
DestinationNameiiB Q
,iiQ R
optiiS V
=>iiW Y
optiiZ ]
.ii] ^
DoNotValidateii^ k
(iik l
)iil m
)iim n
;iin o
}jj 	
foreachkk 
(kk 
varkk 
includedDerivedTypekk (
inkk) +
typeMapkk, 3
.kk3 4 
IncludedDerivedTypeskk4 H
)kkH I
{ll 	 
ReverseMapExpressionmm  
.mm  !
IncludeCoremm! ,
(mm, -
includedDerivedTypemm- @
.mm@ A
DestinationTypemmA P
,mmP Q
includedDerivedTypemmR e
.mme f

SourceTypemmf p
)mmp q
;mmq r
}nn 	
foreachoo 
(oo 
varoo 
includedBaseTypeoo %
inoo& (
typeMapoo) 0
.oo0 1
IncludedBaseTypesoo1 B
)ooB C
{pp 	 
ReverseMapExpressionqq  
.qq  !
IncludeBaseCoreqq! 0
(qq0 1
includedBaseTypeqq1 A
.qqA B
DestinationTypeqqB Q
,qqQ R
includedBaseTypeqqS c
.qqc d

SourceTypeqqd n
)qqn o
;qqo p
}rr 	"
ReverseIncludedMembersss 
(ss 
typeMapss &
)ss& '
;ss' (
}tt 
privateuu 
voiduu &
MapDestinationCtorToSourceuu +
(uu+ ,
TypeMapuu, 3
typeMapuu4 ;
,uu; <
Listuu= A
<uuA B

MemberInfouuB L
>uuL M
sourceMembersuuN [
)uu[ \
{vv 
sourceMembersww 
??=ww 
[ww 
]ww 
;ww 
ConstructorMapxx 
ctorMapxx 
=xx  
newxx! $
(xx$ %
)xx% &
;xx& '
typeMapyy 
.yy 
ConstructorMapyy 
=yy  
ctorMapyy! (
;yy( )
foreachzz 
(zz 
varzz 
destCtorzz 
inzz  
typeMapzz! (
.zz( )#
DestinationConstructorszz) @
)zz@ A
{{{ 	
var|| 
constructor|| 
=|| 
destCtor|| &
.||& '
Constructor||' 2
;||2 3
ctorMap}} 
.}} 
Reset}} 
(}} 
constructor}} %
)}}% &
;}}& '
bool~~ 
canMapResolve~~ 
=~~  
true~~! %
;~~% &
foreach 
( 
var 
	parameter "
in# %
destCtor& .
.. /

Parameters/ 9
)9 :
{
ÄÄ 
var
ÅÅ 
name
ÅÅ 
=
ÅÅ 
	parameter
ÅÅ $
.
ÅÅ$ %
Name
ÅÅ% )
;
ÅÅ) *
if
ÇÇ 
(
ÇÇ 
name
ÇÇ 
==
ÇÇ 
null
ÇÇ  
)
ÇÇ  !
{
ÉÉ 
ctorMap
ÑÑ 
.
ÑÑ 

CanResolve
ÑÑ &
=
ÑÑ' (
false
ÑÑ) .
;
ÑÑ. /
return
ÖÖ 
;
ÖÖ 
}
ÜÜ 
sourceMembers
áá 
.
áá 
Clear
áá #
(
áá# $
)
áá$ %
;
áá% &
var
àà 

canResolve
àà 
=
àà  
typeMap
àà! (
.
àà( )
Profile
àà) 0
.
àà0 1,
MapDestinationPropertyToSource
àà1 O
(
ààO P
typeMap
ààP W
.
ààW X
SourceTypeDetails
ààX i
,
àài j
constructor
ààk v
.
ààv w
DeclaringTypeààw Ñ
,ààÑ Ö
	parameterààÜ è
.ààè ê
ParameterTypeààê ù
,ààù û
nameààü £
,àà£ §
sourceMembersàà• ≤
,àà≤ ≥
IsReverseMapàà¥ ¿
)àà¿ ¡
;àà¡ ¬
if
ââ 
(
ââ 
!
ââ 

canResolve
ââ 
&&
ââ  "
!
ââ# $
	parameter
ââ$ -
.
ââ- .

IsOptional
ââ. 8
&&
ââ9 ;
!
ââ< =
IsConfigured
ââ= I
(
ââI J
	parameter
ââJ S
)
ââS T
)
ââT U
{
ää 
canMapResolve
ãã !
=
ãã" #
false
ãã$ )
;
ãã) *
}
åå 
ctorMap
çç 
.
çç 
AddParameter
çç $
(
çç$ %
	parameter
çç% .
,
çç. /
sourceMembers
çç0 =
,
çç= >
typeMap
çç? F
)
ççF G
;
ççG H
}
éé 
if
èè 
(
èè 
canMapResolve
èè 
)
èè 
{
êê 
ctorMap
ëë 
.
ëë 

CanResolve
ëë "
=
ëë# $
true
ëë% )
;
ëë) *
break
íí 
;
íí 
}
ìì 
}
îî 	
return
ïï 
;
ïï 
bool
ññ 
IsConfigured
ññ 
(
ññ 
ParameterInfo
ññ '
	parameter
ññ( 1
)
ññ1 2
=>
ññ3 5&
_ctorParamConfigurations
ññ6 N
?
ññN O
.
ññO P
Any
ññP S
(
ññS T
c
ññT U
=>
ññV X
c
ññY Z
.
ññZ [
CtorParamName
ññ[ h
==
ññi k
	parameter
ññl u
.
ññu v
Name
ññv z
)
ññz {
is
ññ| ~
trueññ É
;ññÉ Ñ
}
óó 
	protected
òò 
IEnumerable
òò 
<
òò '
IPropertyMapConfiguration
òò 3
>
òò3 4 
MapToSourceMembers
òò5 G
(
òòG H
)
òòH I
=>
òòJ L#
_memberConfigurations
ôô 
?
ôô 
.
ôô 
Where
ôô $
(
ôô$ %
m
ôô% &
=>
ôô' )
m
ôô* +
.
ôô+ ,
SourceExpression
ôô, <
!=
ôô= ?
null
ôô@ D
&&
ôôE G
m
ôôH I
.
ôôI J
SourceExpression
ôôJ Z
.
ôôZ [
Body
ôô[ _
==
ôô` b
m
ôôc d
.
ôôd e
SourceExpression
ôôe u
.
ôôu v

Parametersôôv Ä
[ôôÄ Å
$numôôÅ Ç
]ôôÇ É
)ôôÉ Ñ
??ôôÖ á
[ôôà â
]ôôâ ä
;ôôä ã
private
öö 
void
öö $
ReverseIncludedMembers
öö '
(
öö' (
TypeMap
öö( /
typeMap
öö0 7
)
öö7 8
{
õõ 
Stack
úú 
<
úú 
Member
úú 
>
úú 
chain
úú 
=
úú 
null
úú "
;
úú" #
foreach
ùù 
(
ùù 
var
ùù 
includedMember
ùù #
in
ùù$ &
typeMap
ùù' .
.
ùù. /
IncludedMembers
ùù/ >
.
ùù> ?
Where
ùù? D
(
ùùD E
i
ùùE F
=>
ùùG I
i
ùùJ K
.
ùùK L
IsMemberPath
ùùL X
(
ùùX Y
out
ùùY \
chain
ùù] b
)
ùùb c
)
ùùc d
)
ùùd e
{
ûû 	
var
üü 
	newSource
üü 
=
üü 
	Parameter
üü %
(
üü% &
typeMap
üü& -
.
üü- .
DestinationType
üü. =
,
üü= >
$str
üü? G
)
üüG H
;
üüH I
var
†† 
customExpression
††  
=
††! "
Lambda
††# )
(
††) *
	newSource
††* 3
,
††3 4
	newSource
††5 >
)
††> ?
;
††? @"
ReverseSourceMembers
°°  
(
°°  !
new
°°! $
(
°°$ %
chain
°°% *
)
°°* +
,
°°+ ,
customExpression
°°- =
)
°°= >
;
°°> ?
}
¢¢ 	
}
££ 
private
§§ 
void
§§ "
ReverseSourceMembers
§§ %
(
§§% &
TypeMap
§§& -
typeMap
§§. 5
)
§§5 6
{
•• 
foreach
¶¶ 
(
¶¶ 
var
¶¶ 
propertyMap
¶¶  
in
¶¶! #
typeMap
¶¶$ +
.
¶¶+ ,
PropertyMaps
¶¶, 8
)
¶¶8 9
{
ßß 	
var
®® 
sourceMembers
®® 
=
®® 
propertyMap
®®  +
.
®®+ ,
SourceMembers
®®, 9
;
®®9 :
if
©© 
(
©© 
sourceMembers
©© 
.
©© 
Length
©© #
<=
©©$ &
$num
©©' (
||
©©) +
Array
©©, 1
.
©©1 2
Exists
©©2 8
(
©©8 9
sourceMembers
©©9 F
,
©©F G
m
©©H I
=>
©©J L
m
©©M N
is
©©O Q

MethodInfo
©©R \
)
©©\ ]
)
©©] ^
{
™™ 
continue
´´ 
;
´´ 
}
¨¨ 
var
≠≠ 
customExpression
≠≠  
=
≠≠! "
propertyMap
≠≠# .
.
≠≠. /
DestinationMember
≠≠/ @
.
≠≠@ A
Lambda
≠≠A G
(
≠≠G H
)
≠≠H I
;
≠≠I J"
ReverseSourceMembers
ÆÆ  
(
ÆÆ  !
new
ÆÆ! $
(
ÆÆ$ %
sourceMembers
ÆÆ% 2
)
ÆÆ2 3
,
ÆÆ3 4
customExpression
ÆÆ5 E
)
ÆÆE F
;
ÆÆF G
}
ØØ 	
}
∞∞ 
private
±± 
void
±± "
ReverseSourceMembers
±± %
(
±±% &

MemberPath
±±& 0

memberPath
±±1 ;
,
±±; <
LambdaExpression
±±= M
customExpression
±±N ^
)
±±^ _
{
≤≤ "
ReverseMapExpression
≥≥ 
.
≥≥ 
TypeMapActions
≥≥ +
.
≥≥+ ,
Add
≥≥, /
(
≥≥/ 0
reverseTypeMap
≥≥0 >
=>
≥≥? A
{
¥¥ 	
var
µµ 
newDestination
µµ 
=
µµ  
	Parameter
µµ! *
(
µµ* +
reverseTypeMap
µµ+ 9
.
µµ9 :
DestinationType
µµ: I
,
µµI J
$str
µµK X
)
µµX Y
;
µµY Z
var
∂∂ 
path
∂∂ 
=
∂∂ 

memberPath
∂∂ !
.
∂∂! "
Members
∂∂" )
.
∂∂) *
Chain
∂∂* /
(
∂∂/ 0
newDestination
∂∂0 >
)
∂∂> ?
;
∂∂? @
var
∑∑ 
forPathLambda
∑∑ 
=
∑∑ 
Lambda
∑∑  &
(
∑∑& '
path
∑∑' +
,
∑∑+ ,
newDestination
∑∑- ;
)
∑∑; <
;
∑∑< =
var
∏∏ 
pathMap
∏∏ 
=
∏∏ 
reverseTypeMap
∏∏ (
.
∏∏( )$
FindOrCreatePathMapFor
∏∏) ?
(
∏∏? @
forPathLambda
∏∏@ M
,
∏∏M N

memberPath
∏∏O Y
,
∏∏Y Z
reverseTypeMap
∏∏[ i
)
∏∏i j
;
∏∏j k
pathMap
ππ 
.
ππ 
MapFrom
ππ 
(
ππ 
customExpression
ππ ,
)
ππ, -
;
ππ- .
}
∫∫ 	
)
∫∫	 

;
∫∫
 
}
ªª 
	protected
ºº 
void
ºº !
ForSourceMemberCore
ºº &
(
ºº& '
string
ºº' -
sourceMemberName
ºº. >
,
ºº> ?
Action
ºº@ F
<
ººF G2
$ISourceMemberConfigurationExpression
ººG k
>
ººk l
memberOptions
ººm z
)
ººz {
{
ΩΩ 
var
ææ 

memberInfo
ææ 
=
ææ 

SourceType
ææ #
.
ææ# $ 
GetFieldOrProperty
ææ$ 6
(
ææ6 7
sourceMemberName
ææ7 G
)
ææG H
;
ææH I!
ForSourceMemberCore
øø 
(
øø 

memberInfo
øø &
,
øø& '
memberOptions
øø( 5
)
øø5 6
;
øø6 7
}
¿¿ 
	protected
¡¡ 
void
¡¡ !
ForSourceMemberCore
¡¡ &
(
¡¡& '

MemberInfo
¡¡' 1

memberInfo
¡¡2 <
,
¡¡< =
Action
¡¡> D
<
¡¡D E2
$ISourceMemberConfigurationExpression
¡¡E i
>
¡¡i j
memberOptions
¡¡k x
)
¡¡x y
{
¬¬ %
SourceMappingExpression
√√ 
	srcConfig
√√  )
=
√√* +
new
√√, /
(
√√/ 0

memberInfo
√√0 :
)
√√: ;
;
√√; <
memberOptions
ƒƒ 
(
ƒƒ 
	srcConfig
ƒƒ 
)
ƒƒ  
;
ƒƒ  !(
SourceMemberConfigurations
≈≈ "
.
≈≈" #
Add
≈≈# &
(
≈≈& '
	srcConfig
≈≈' 0
)
≈≈0 1
;
≈≈1 2
}
∆∆ 
	protected
«« 
void
«« 
IncludeCore
«« 
(
«« 
Type
«« #
derivedSourceType
««$ 5
,
««5 6
Type
««7 ;$
derivedDestinationType
««< R
)
««R S
{
»» 
TypePair
…… 
derivedTypes
…… 
=
…… 
new
……  #
(
……# $
derivedSourceType
……$ 5
,
……5 6$
derivedDestinationType
……7 M
)
……M N
;
……N O
derivedTypes
   
.
    
CheckIsDerivedFrom
   '
(
  ' (
_types
  ( .
)
  . /
;
  / 0
TypeMapActions
ÀÀ 
.
ÀÀ 
Add
ÀÀ 
(
ÀÀ 
tm
ÀÀ 
=>
ÀÀ  
tm
ÀÀ! #
.
ÀÀ# $!
IncludeDerivedTypes
ÀÀ$ 7
(
ÀÀ7 8
derivedTypes
ÀÀ8 D
)
ÀÀD E
)
ÀÀE F
;
ÀÀF G
}
ÃÃ 
	protected
ÕÕ 
void
ÕÕ 
IncludeBaseCore
ÕÕ "
(
ÕÕ" #
Type
ÕÕ# '

sourceBase
ÕÕ( 2
,
ÕÕ2 3
Type
ÕÕ4 8
destinationBase
ÕÕ9 H
)
ÕÕH I
{
ŒŒ 
TypePair
œœ 
	baseTypes
œœ 
=
œœ 
new
œœ  
(
œœ  !

sourceBase
œœ! +
,
œœ+ ,
destinationBase
œœ- <
)
œœ< =
;
œœ= >
_types
–– 
.
––  
CheckIsDerivedFrom
–– !
(
––! "
	baseTypes
––" +
)
––+ ,
;
––, -
TypeMapActions
—— 
.
—— 
Add
—— 
(
—— 
tm
—— 
=>
——  
tm
——! #
.
——# $
IncludeBaseTypes
——$ 4
(
——4 5
	baseTypes
——5 >
)
——> ?
)
——? @
;
——@ A
}
““ 
public
”” 
'
IPropertyMapConfiguration
”” $/
!GetDestinationMemberConfiguration
””% F
(
””F G

MemberInfo
””G Q
destinationMember
””R c
)
””c d
{
‘‘ 
if
’’ 

(
’’ #
_memberConfigurations
’’ !
==
’’" $
null
’’% )
)
’’) *
{
÷÷ 	
return
◊◊ 
null
◊◊ 
;
◊◊ 
}
ÿÿ 	
foreach
ŸŸ 
(
ŸŸ 
var
ŸŸ 
config
ŸŸ 
in
ŸŸ #
_memberConfigurations
ŸŸ 4
)
ŸŸ4 5
{
⁄⁄ 	
if
€€ 
(
€€ 
config
€€ 
.
€€ 
DestinationMember
€€ (
==
€€) +
destinationMember
€€, =
)
€€= >
{
‹‹ 
return
›› 
config
›› 
;
›› 
}
ﬁﬁ 
}
ﬂﬂ 	
return
‡‡ 
null
‡‡ 
;
‡‡ 
}
·· 
	protected
‚‚ 
abstract
‚‚ 
void
‚‚ %
IgnoreDestinationMember
‚‚ 3
(
‚‚3 4

MemberInfo
‚‚4 >
property
‚‚? G
,
‚‚G H
bool
‚‚I M
ignorePaths
‚‚N Y
=
‚‚Z [
true
‚‚\ `
)
‚‚` a
;
‚‚a b
}„„ 
public‰‰ 
abstract
‰‰ 
class
‰‰ #
MappingExpressionBase
‰‰ +
<
‰‰+ ,
TSource
‰‰, 3
,
‰‰3 4
TDestination
‰‰5 A
,
‰‰A B 
TMappingExpression
‰‰C U
>
‰‰U V
(
‰‰V W

MemberList
‰‰W a

memberList
‰‰b l
,
‰‰l m
TypePair
‰‰n v
types
‰‰w |
)
‰‰| }
:
‰‰~ $
TypeMapConfiguration‰‰Ä î
(‰‰î ï

memberList‰‰ï ü
,‰‰ü †
types‰‰° ¶
)‰‰¶ ß
,‰‰ß ®&
IMappingExpressionBase‰‰© ø
<‰‰ø ¿
TSource‰‰¿ «
,‰‰« »
TDestination‰‰… ’
,‰‰’ ÷"
TMappingExpression‰‰◊ È
>‰‰È Í
where
ÂÂ 	 
TMappingExpression
ÂÂ
 
:
ÂÂ 
class
ÂÂ $
,
ÂÂ$ %$
IMappingExpressionBase
ÂÂ& <
<
ÂÂ< =
TSource
ÂÂ= D
,
ÂÂD E
TDestination
ÂÂF R
,
ÂÂR S 
TMappingExpression
ÂÂT f
>
ÂÂf g
{ÊÊ 
	protected
ÁÁ #
MappingExpressionBase
ÁÁ #
(
ÁÁ# $

MemberList
ÁÁ$ .

memberList
ÁÁ/ 9
)
ÁÁ9 :
:
ÁÁ; <
this
ÁÁ= A
(
ÁÁA B

memberList
ÁÁB L
,
ÁÁL M
new
ÁÁN Q
(
ÁÁQ R
typeof
ÁÁR X
(
ÁÁX Y
TSource
ÁÁY `
)
ÁÁ` a
,
ÁÁa b
typeof
ÁÁc i
(
ÁÁi j
TDestination
ÁÁj v
)
ÁÁv w
)
ÁÁw x
)
ÁÁx y
{
ÁÁy z
}
ÁÁ{ |
public
ËË 

void
ËË 
As
ËË 
(
ËË 
Type
ËË 
typeOverride
ËË $
)
ËË$ %
{
ÈÈ 
if
ÍÍ 

(
ÍÍ 
typeOverride
ÍÍ 
==
ÍÍ 
DestinationType
ÍÍ +
)
ÍÍ+ ,
{
ÎÎ 	
throw
ÏÏ 
new
ÏÏ '
InvalidOperationException
ÏÏ /
(
ÏÏ/ 0
$str
ÏÏ0 V
+
ÏÏW X
DestinationType
ÏÏY h
)
ÏÏh i
;
ÏÏi j
}
ÌÌ 	
typeOverride
ÓÓ 
.
ÓÓ  
CheckIsDerivedFrom
ÓÓ '
(
ÓÓ' (
DestinationType
ÓÓ( 7
)
ÓÓ7 8
;
ÓÓ8 9%
DestinationTypeOverride
ÔÔ 
=
ÔÔ  !
typeOverride
ÔÔ" .
;
ÔÔ. /
}
 
public
ÒÒ 
 
TMappingExpression
ÒÒ 
MaxDepth
ÒÒ &
(
ÒÒ& '
int
ÒÒ' *
depth
ÒÒ+ 0
)
ÒÒ0 1
{
ÚÚ 
TypeMapActions
ÛÛ 
.
ÛÛ 
Add
ÛÛ 
(
ÛÛ 
tm
ÛÛ 
=>
ÛÛ  
tm
ÛÛ! #
.
ÛÛ# $
MaxDepth
ÛÛ$ ,
=
ÛÛ- .
depth
ÛÛ/ 4
)
ÛÛ4 5
;
ÛÛ5 6
return
ıı 
this
ıı 
as
ıı  
TMappingExpression
ıı )
;
ıı) *
}
ˆˆ 
public
˜˜ 
 
TMappingExpression
˜˜ *
ConstructUsingServiceLocator
˜˜ :
(
˜˜: ;
)
˜˜; <
{
¯¯ 
TypeMapActions
˘˘ 
.
˘˘ 
Add
˘˘ 
(
˘˘ 
tm
˘˘ 
=>
˘˘  
tm
˘˘! #
.
˘˘# $*
ConstructUsingServiceLocator
˘˘$ @
(
˘˘@ A
)
˘˘A B
)
˘˘B C
;
˘˘C D
return
˚˚ 
this
˚˚ 
as
˚˚  
TMappingExpression
˚˚ )
;
˚˚) *
}
¸¸ 
public
˝˝ 
 
TMappingExpression
˝˝ 
	BeforeMap
˝˝ '
(
˝˝' (
Action
˝˝( .
<
˝˝. /
TSource
˝˝/ 6
,
˝˝6 7
TDestination
˝˝8 D
>
˝˝D E
beforeFunction
˝˝F T
)
˝˝T U
=>
˝˝V X
BeforeMapCore
˝˝Y f
(
˝˝f g
(
˝˝g h
src
˝˝h k
,
˝˝k l
dest
˝˝m q
,
˝˝q r
ctxt
˝˝s w
)
˝˝w x
=>
˝˝y {
beforeFunction˝˝| ä
(˝˝ä ã
src˝˝ã é
,˝˝é è
dest˝˝ê î
)˝˝î ï
)˝˝ï ñ
;˝˝ñ ó
private
˛˛  
TMappingExpression
˛˛ 
BeforeMapCore
˛˛ ,
(
˛˛, -

Expression
˛˛- 7
<
˛˛7 8
Action
˛˛8 >
<
˛˛> ?
TSource
˛˛? F
,
˛˛F G
TDestination
˛˛H T
,
˛˛T U
ResolutionContext
˛˛V g
>
˛˛g h
>
˛˛h i
expr
˛˛j n
)
˛˛n o
{
ˇˇ 
TypeMapActions
ÄÄ 
.
ÄÄ 
Add
ÄÄ 
(
ÄÄ 
tm
ÄÄ 
=>
ÄÄ  
tm
ÄÄ! #
.
ÄÄ# $ 
AddBeforeMapAction
ÄÄ$ 6
(
ÄÄ6 7
expr
ÄÄ7 ;
)
ÄÄ; <
)
ÄÄ< =
;
ÄÄ= >
return
ÅÅ 
this
ÅÅ 
as
ÅÅ  
TMappingExpression
ÅÅ )
;
ÅÅ) *
}
ÇÇ 
public
ÉÉ 
 
TMappingExpression
ÉÉ 
	BeforeMap
ÉÉ '
(
ÉÉ' (
Action
ÉÉ( .
<
ÉÉ. /
TSource
ÉÉ/ 6
,
ÉÉ6 7
TDestination
ÉÉ8 D
,
ÉÉD E
ResolutionContext
ÉÉF W
>
ÉÉW X
beforeFunction
ÉÉY g
)
ÉÉg h
=>
ÉÉi k
BeforeMapCore
ÑÑ 
(
ÑÑ 
(
ÑÑ 
src
ÑÑ 
,
ÑÑ 
dest
ÑÑ  
,
ÑÑ  !
ctxt
ÑÑ" &
)
ÑÑ& '
=>
ÑÑ( *
beforeFunction
ÑÑ+ 9
(
ÑÑ9 :
src
ÑÑ: =
,
ÑÑ= >
dest
ÑÑ? C
,
ÑÑC D
ctxt
ÑÑE I
)
ÑÑI J
)
ÑÑJ K
;
ÑÑK L
public
ÖÖ 
 
TMappingExpression
ÖÖ 
	BeforeMap
ÖÖ '
<
ÖÖ' (
TMappingAction
ÖÖ( 6
>
ÖÖ6 7
(
ÖÖ7 8
)
ÖÖ8 9
where
ÖÖ: ?
TMappingAction
ÖÖ@ N
:
ÖÖO P
IMappingAction
ÖÖQ _
<
ÖÖ_ `
TSource
ÖÖ` g
,
ÖÖg h
TDestination
ÖÖi u
>
ÖÖu v
=>
ÖÖw y
	BeforeMap
ÜÜ 
(
ÜÜ 
CallMapAction
ÜÜ 
<
ÜÜ  
TMappingAction
ÜÜ  .
>
ÜÜ. /
)
ÜÜ/ 0
;
ÜÜ0 1
public
áá 
 
TMappingExpression
áá 
AfterMap
áá &
<
áá& '
TMappingAction
áá' 5
>
áá5 6
(
áá6 7
)
áá7 8
where
áá9 >
TMappingAction
áá? M
:
ááN O
IMappingAction
ááP ^
<
áá^ _
TSource
áá_ f
,
ááf g
TDestination
ááh t
>
áát u
=>
ááv x
AfterMap
àà 
(
àà 
CallMapAction
àà 
<
àà 
TMappingAction
àà -
>
àà- .
)
àà. /
;
àà/ 0
private
ââ 
static
ââ 
void
ââ 
CallMapAction
ââ %
<
ââ% &
TMappingAction
ââ& 4
>
ââ4 5
(
ââ5 6
TSource
ââ6 =
source
ââ> D
,
ââD E
TDestination
ââF R
destination
ââS ^
,
ââ^ _
ResolutionContext
ââ` q
context
ââr y
)
âây z
=>
ââ{ }
(
ää 	
(
ää	 

IMappingAction
ää
 
<
ää 
TSource
ää  
,
ää  !
TDestination
ää" .
>
ää. /
)
ää/ 0
context
ää0 7
.
ää7 8
CreateInstance
ää8 F
(
ääF G
typeof
ääG M
(
ääM N
TMappingAction
ääN \
)
ää\ ]
)
ää] ^
)
ää^ _
.
ää_ `
Process
ää` g
(
ääg h
source
ääh n
,
ään o
destination
ääp {
,
ää{ |
contextää} Ñ
)ääÑ Ö
;ääÖ Ü
public
ãã 
 
TMappingExpression
ãã 
AfterMap
ãã &
(
ãã& '
Action
ãã' -
<
ãã- .
TSource
ãã. 5
,
ãã5 6
TDestination
ãã7 C
>
ããC D
afterFunction
ããE R
)
ããR S
=>
ããT V
AfterMapCore
ããW c
(
ããc d
(
ããd e
src
ããe h
,
ããh i
dest
ããj n
,
ããn o
ctxt
ããp t
)
ããt u
=>
ããv x
afterFunctionããy Ü
(ããÜ á
srcããá ä
,ããä ã
destããå ê
)ããê ë
)ããë í
;ããí ì
private
åå  
TMappingExpression
åå 
AfterMapCore
åå +
(
åå+ ,

Expression
åå, 6
<
åå6 7
Action
åå7 =
<
åå= >
TSource
åå> E
,
ååE F
TDestination
ååG S
,
ååS T
ResolutionContext
ååU f
>
ååf g
>
ååg h
expr
ååi m
)
ååm n
{
çç 
TypeMapActions
éé 
.
éé 
Add
éé 
(
éé 
tm
éé 
=>
éé  
tm
éé! #
.
éé# $
AddAfterMapAction
éé$ 5
(
éé5 6
expr
éé6 :
)
éé: ;
)
éé; <
;
éé< =
return
èè 
this
èè 
as
èè  
TMappingExpression
èè )
;
èè) *
}
êê 
public
ëë 
 
TMappingExpression
ëë 
AfterMap
ëë &
(
ëë& '
Action
ëë' -
<
ëë- .
TSource
ëë. 5
,
ëë5 6
TDestination
ëë7 C
,
ëëC D
ResolutionContext
ëëE V
>
ëëV W
afterFunction
ëëX e
)
ëëe f
=>
ëëg i
AfterMapCore
íí 
(
íí 
(
íí 
src
íí 
,
íí 
dest
íí 
,
íí  
ctxt
íí! %
)
íí% &
=>
íí' )
afterFunction
íí* 7
(
íí7 8
src
íí8 ;
,
íí; <
dest
íí= A
,
ííA B
ctxt
ííC G
)
ííG H
)
ííH I
;
ííI J
public
ìì 
 
TMappingExpression
ìì  
PreserveReferences
ìì 0
(
ìì0 1
)
ìì1 2
{
îî 
TypeMapActions
ïï 
.
ïï 
Add
ïï 
(
ïï 
tm
ïï 
=>
ïï  
tm
ïï! #
.
ïï# $ 
PreserveReferences
ïï$ 6
=
ïï7 8
true
ïï9 =
)
ïï= >
;
ïï> ?
return
ññ 
this
ññ 
as
ññ  
TMappingExpression
ññ )
;
ññ) *
}
óó 
public
òò 
 
TMappingExpression
òò #
DisableCtorValidation
òò 3
(
òò3 4
)
òò4 5
{
ôô 
TypeMapActions
öö 
.
öö 
Add
öö 
(
öö 
tm
öö 
=>
öö  
{
õõ 	
tm
úú 
.
úú *
DisableConstructorValidation
úú +
=
úú, -
true
úú. 2
;
úú2 3
}
ùù 	
)
ùù	 

;
ùù
 
return
ûû 
this
ûû 
as
ûû  
TMappingExpression
ûû )
;
ûû) *
}
üü 
public
†† 
 
TMappingExpression
††  
ValidateMemberList
†† 0
(
††0 1

MemberList
††1 ;

memberList
††< F
)
††F G
{
°° 
TypeMapActions
¢¢ 
.
¢¢ 
Add
¢¢ 
(
¢¢ 
tm
¢¢ 
=>
¢¢  
{
££ 	
tm
§§ 
.
§§ "
ConfiguredMemberList
§§ #
=
§§$ %

memberList
§§& 0
;
§§0 1
}
•• 	
)
••	 

;
••
 
return
¶¶ 
this
¶¶ 
as
¶¶  
TMappingExpression
¶¶ )
;
¶¶) *
}
ßß 
public
®® 
 
TMappingExpression
®® 
IncludeAllDerived
®® /
(
®®/ 0
)
®®0 1
{
©© 
TypeMapActions
™™ 
.
™™ 
Add
™™ 
(
™™ 
tm
™™ 
=>
™™  
tm
™™! #
.
™™# $$
IncludeAllDerivedTypes
™™$ :
=
™™; <
true
™™= A
)
™™A B
;
™™B C
return
´´ 
this
´´ 
as
´´  
TMappingExpression
´´ )
;
´´) *
}
¨¨ 
public
≠≠ 
 
TMappingExpression
≠≠ 
Include
≠≠ %
(
≠≠% &
Type
≠≠& *
otherSourceType
≠≠+ :
,
≠≠: ;
Type
≠≠< @"
otherDestinationType
≠≠A U
)
≠≠U V
{
ÆÆ 
IncludeCore
ØØ 
(
ØØ 
otherSourceType
ØØ #
,
ØØ# $"
otherDestinationType
ØØ% 9
)
ØØ9 :
;
ØØ: ;
return
∞∞ 
this
∞∞ 
as
∞∞  
TMappingExpression
∞∞ )
;
∞∞) *
}
±± 
public
≤≤ 
 
TMappingExpression
≤≤ 
IncludeBase
≤≤ )
(
≤≤) *
Type
≤≤* .

sourceBase
≤≤/ 9
,
≤≤9 :
Type
≤≤; ?
destinationBase
≤≤@ O
)
≤≤O P
{
≥≥ 
IncludeBaseCore
¥¥ 
(
¥¥ 

sourceBase
¥¥ "
,
¥¥" #
destinationBase
¥¥$ 3
)
¥¥3 4
;
¥¥4 5
return
µµ 
this
µµ 
as
µµ  
TMappingExpression
µµ )
;
µµ) *
}
∂∂ 
public
∑∑ 
 
TMappingExpression
∑∑ 
ForSourceMember
∑∑ -
(
∑∑- .
string
∑∑. 4
sourceMemberName
∑∑5 E
,
∑∑E F
Action
∑∑G M
<
∑∑M N2
$ISourceMemberConfigurationExpression
∑∑N r
>
∑∑r s
memberOptions∑∑t Å
)∑∑Å Ç
{
∏∏ !
ForSourceMemberCore
ππ 
(
ππ 
sourceMemberName
ππ ,
,
ππ, -
memberOptions
ππ. ;
)
ππ; <
;
ππ< =
return
∫∫ 
this
∫∫ 
as
∫∫  
TMappingExpression
∫∫ )
;
∫∫) *
}
ªª 
public
ºº 
 
TMappingExpression
ºº 
ConstructUsing
ºº ,
(
ºº, -

Expression
ºº- 7
<
ºº7 8
Func
ºº8 <
<
ºº< =
TSource
ºº= D
,
ººD E
TDestination
ººF R
>
ººR S
>
ººS T
ctor
ººU Y
)
ººY Z
=>
ºº[ ] 
ConstructUsingCore
ºº^ p
(
ººp q
ctor
ººq u
)
ººu v
;
ººv w
private
ΩΩ  
TMappingExpression
ΩΩ  
ConstructUsingCore
ΩΩ 1
(
ΩΩ1 2
LambdaExpression
ΩΩ2 B
ctor
ΩΩC G
)
ΩΩG H
{
ææ 
TypeMapActions
øø 
.
øø 
Add
øø 
(
øø 
tm
øø 
=>
øø  
tm
øø! #
.
øø# $ 
CustomCtorFunction
øø$ 6
=
øø7 8
ctor
øø9 =
)
øø= >
;
øø> ?
return
¿¿ 
this
¿¿ 
as
¿¿  
TMappingExpression
¿¿ )
;
¿¿) *
}
¡¡ 
public
¬¬ 
 
TMappingExpression
¬¬ 
ConstructUsing
¬¬ ,
(
¬¬, -
Func
¬¬- 1
<
¬¬1 2
TSource
¬¬2 9
,
¬¬9 :
ResolutionContext
¬¬; L
,
¬¬L M
TDestination
¬¬N Z
>
¬¬Z [
ctor
¬¬\ `
)
¬¬` a
{
√√ 

Expression
ƒƒ 
<
ƒƒ 
Func
ƒƒ 
<
ƒƒ 
TSource
ƒƒ 
,
ƒƒ  
ResolutionContext
ƒƒ! 2
,
ƒƒ2 3
TDestination
ƒƒ4 @
>
ƒƒ@ A
>
ƒƒA B
expr
ƒƒC G
=
ƒƒH I
(
ƒƒJ K
src
ƒƒK N
,
ƒƒN O
ctxt
ƒƒP T
)
ƒƒT U
=>
ƒƒV X
ctor
ƒƒY ]
(
ƒƒ] ^
src
ƒƒ^ a
,
ƒƒa b
ctxt
ƒƒc g
)
ƒƒg h
;
ƒƒh i
return
≈≈  
ConstructUsingCore
≈≈ !
(
≈≈! "
expr
≈≈" &
)
≈≈& '
;
≈≈' (
}
∆∆ 
public
«« 

void
«« 
ConvertUsing
«« 
(
«« 
Type
«« !
typeConverterType
««" 3
)
««3 4
{
»» 
HasTypeConverter
…… 
=
…… 
true
…… 
;
……  
TypeMapActions
   
.
   
Add
   
(
   
tm
   
=>
    
tm
  ! #
.
  # $
TypeConverter
  $ 1
=
  2 3
new
  4 7 
ClassTypeConverter
  8 J
(
  J K
typeConverterType
  K \
,
  \ ]
tm
  ^ `
.
  ` a
Types
  a f
.
  f g
ITypeConverter
  g u
(
  u v
)
  v w
)
  w x
)
  x y
;
  y z
}
ÀÀ 
public
ÃÃ 

void
ÃÃ 
ConvertUsing
ÃÃ 
(
ÃÃ 
Func
ÃÃ !
<
ÃÃ! "
TSource
ÃÃ" )
,
ÃÃ) *
TDestination
ÃÃ+ 7
,
ÃÃ7 8
TDestination
ÃÃ9 E
>
ÃÃE F
mappingFunction
ÃÃG V
)
ÃÃV W
=>
ÃÃX Z
ConvertUsingCore
ÃÃ[ k
(
ÃÃk l
(
ÃÃl m
src
ÃÃm p
,
ÃÃp q
dest
ÃÃr v
,
ÃÃv w
ctxt
ÃÃx |
)
ÃÃ| }
=>ÃÃ~ Ä
mappingFunctionÃÃÅ ê
(ÃÃê ë
srcÃÃë î
,ÃÃî ï
destÃÃñ ö
)ÃÃö õ
)ÃÃõ ú
;ÃÃú ù
private
ÕÕ 
void
ÕÕ 
ConvertUsingCore
ÕÕ !
(
ÕÕ! "

Expression
ÕÕ" ,
<
ÕÕ, -
Func
ÕÕ- 1
<
ÕÕ1 2
TSource
ÕÕ2 9
,
ÕÕ9 :
TDestination
ÕÕ; G
,
ÕÕG H
ResolutionContext
ÕÕI Z
,
ÕÕZ [
TDestination
ÕÕ\ h
>
ÕÕh i
>
ÕÕi j
expr
ÕÕk o
)
ÕÕo p
=>
ÕÕq s
SetTypeConverterÕÕt Ñ
(ÕÕÑ Ö
newÕÕÖ à#
LambdaTypeConverterÕÕâ ú
(ÕÕú ù
exprÕÕù °
)ÕÕ° ¢
)ÕÕ¢ £
;ÕÕ£ §
private
ŒŒ 
void
ŒŒ 
SetTypeConverter
ŒŒ !
(
ŒŒ! "
	Execution
ŒŒ" +
.
ŒŒ+ ,
TypeConverter
ŒŒ, 9
typeConverter
ŒŒ: G
)
ŒŒG H
{
œœ 
HasTypeConverter
–– 
=
–– 
true
–– 
;
––  
TypeMapActions
—— 
.
—— 
Add
—— 
(
—— 
tm
—— 
=>
——  
tm
——! #
.
——# $
TypeConverter
——$ 1
=
——2 3
typeConverter
——4 A
)
——A B
;
——B C
}
““ 
public
”” 

void
”” 
ConvertUsing
”” 
(
”” 
Func
”” !
<
””! "
TSource
””" )
,
””) *
TDestination
””+ 7
,
””7 8
ResolutionContext
””9 J
,
””J K
TDestination
””L X
>
””X Y
mappingFunction
””Z i
)
””i j
=>
””k m
ConvertUsingCore
””n ~
(
””~ 
(”” Ä
src””Ä É
,””É Ñ
dest””Ö â
,””â ä
ctxt””ã è
)””è ê
=>””ë ì
mappingFunction””î £
(””£ §
src””§ ß
,””ß ®
dest””© ≠
,””≠ Æ
ctxt””Ø ≥
)””≥ ¥
)””¥ µ
;””µ ∂
public
‘‘ 

void
‘‘ 
ConvertUsing
‘‘ 
(
‘‘ 
ITypeConverter
‘‘ +
<
‘‘+ ,
TSource
‘‘, 3
,
‘‘3 4
TDestination
‘‘5 A
>
‘‘A B
	converter
‘‘C L
)
‘‘L M
=>
‘‘N P
ConvertUsing
‘‘Q ]
(
‘‘] ^
	converter
‘‘^ g
.
‘‘g h
Convert
‘‘h o
)
‘‘o p
;
‘‘p q
public
’’ 

void
’’ 
ConvertUsing
’’ 
<
’’ 
TTypeConverter
’’ +
>
’’+ ,
(
’’, -
)
’’- .
where
’’/ 4
TTypeConverter
’’5 C
:
’’D E
ITypeConverter
’’F T
<
’’T U
TSource
’’U \
,
’’\ ]
TDestination
’’^ j
>
’’j k
=>
’’l n
SetTypeConverter
÷÷ 
(
÷÷ 
new
÷÷  
ClassTypeConverter
÷÷ /
(
÷÷/ 0
typeof
÷÷0 6
(
÷÷6 7
TTypeConverter
÷÷7 E
)
÷÷E F
,
÷÷F G
typeof
÷÷H N
(
÷÷N O
ITypeConverter
÷÷O ]
<
÷÷] ^
TSource
÷÷^ e
,
÷÷e f
TDestination
÷÷g s
>
÷÷s t
)
÷÷t u
)
÷÷u v
)
÷÷v w
;
÷÷w x
public
◊◊ 
 
TMappingExpression
◊◊ 
ForCtorParam
◊◊ *
(
◊◊* +
string
◊◊+ 1
ctorParamName
◊◊2 ?
,
◊◊? @
Action
◊◊A G
<
◊◊G H/
!ICtorParamConfigurationExpression
◊◊H i
<
◊◊i j
TSource
◊◊j q
>
◊◊q r
>
◊◊r s
paramOptions◊◊t Ä
)◊◊Ä Å
{
ÿÿ .
 CtorParamConfigurationExpression
ŸŸ (
<
ŸŸ( )
TSource
ŸŸ) 0
,
ŸŸ0 1
TDestination
ŸŸ2 >
>
ŸŸ> ?!
ctorParamExpression
ŸŸ@ S
=
ŸŸT U
new
ŸŸV Y
(
ŸŸY Z
ctorParamName
ŸŸZ g
,
ŸŸg h

SourceType
ŸŸi s
)
ŸŸs t
;
ŸŸt u
paramOptions
⁄⁄ 
(
⁄⁄ !
ctorParamExpression
⁄⁄ (
)
⁄⁄( )
;
⁄⁄) *%
CtorParamConfigurations
€€ 
.
€€  
Add
€€  #
(
€€# $!
ctorParamExpression
€€$ 7
)
€€7 8
;
€€8 9
return
‹‹ 
this
‹‹ 
as
‹‹  
TMappingExpression
‹‹ )
;
‹‹) *
}
›› 
public
ﬁﬁ 
 
TMappingExpression
ﬁﬁ 9
+IgnoreAllPropertiesWithAnInaccessibleSetter
ﬁﬁ I
(
ﬁﬁI J
)
ﬁﬁJ K
{
ﬂﬂ 
foreach
‡‡ 
(
‡‡ 
var
‡‡ 
property
‡‡ 
in
‡‡ 0
"PropertiesWithAnInaccessibleSetter
‡‡  B
(
‡‡B C
DestinationType
‡‡C R
)
‡‡R S
)
‡‡S T
{
·· 	%
IgnoreDestinationMember
‚‚ #
(
‚‚# $
property
‚‚$ ,
)
‚‚, -
;
‚‚- .
}
„„ 	
return
‰‰ 
this
‰‰ 
as
‰‰  
TMappingExpression
‰‰ )
;
‰‰) *
}
ÂÂ 
public
ÊÊ 
 
TMappingExpression
ÊÊ ?
1IgnoreAllSourcePropertiesWithAnInaccessibleSetter
ÊÊ O
(
ÊÊO P
)
ÊÊP Q
{
ÁÁ 
foreach
ËË 
(
ËË 
var
ËË 
property
ËË 
in
ËË  0
"PropertiesWithAnInaccessibleSetter
ËË! C
(
ËËC D

SourceType
ËËD N
)
ËËN O
)
ËËO P
{
ÈÈ 	!
ForSourceMemberCore
ÍÍ 
(
ÍÍ  
property
ÍÍ  (
,
ÍÍ( )
options
ÍÍ* 1
=>
ÍÍ2 4
options
ÍÍ5 <
.
ÍÍ< =
DoNotValidate
ÍÍ= J
(
ÍÍJ K
)
ÍÍK L
)
ÍÍL M
;
ÍÍM N
}
ÎÎ 	
return
ÏÏ 
this
ÏÏ 
as
ÏÏ  
TMappingExpression
ÏÏ )
;
ÏÏ) *
}
ÌÌ 
private
ÓÓ 
static
ÓÓ 
IEnumerable
ÓÓ 
<
ÓÓ 
PropertyInfo
ÓÓ +
>
ÓÓ+ ,0
"PropertiesWithAnInaccessibleSetter
ÓÓ- O
(
ÓÓO P
Type
ÓÓP T
type
ÓÓU Y
)
ÓÓY Z
=>
ÓÓ[ ]
type
ÓÓ^ b
.
ÓÓb c"
GetRuntimeProperties
ÓÓc w
(
ÓÓw x
)
ÓÓx y
.
ÓÓy z
Where
ÓÓz 
(ÓÓ Ä
pÓÓÄ Å
=>ÓÓÇ Ñ
pÓÓÖ Ü
.ÓÓÜ á
GetSetMethodÓÓá ì
(ÓÓì î
)ÓÓî ï
==ÓÓñ ò
nullÓÓô ù
)ÓÓù û
;ÓÓû ü
public
ÔÔ 

void
ÔÔ 
ConvertUsing
ÔÔ 
(
ÔÔ 

Expression
ÔÔ '
<
ÔÔ' (
Func
ÔÔ( ,
<
ÔÔ, -
TSource
ÔÔ- 4
,
ÔÔ4 5
TDestination
ÔÔ6 B
>
ÔÔB C
>
ÔÔC D
mappingFunction
ÔÔE T
)
ÔÔT U
=>
ÔÔV X
SetTypeConverter
ÔÔZ j
(
ÔÔj k
new
ÔÔk n&
ExpressionTypeConverterÔÔo Ü
(ÔÔÜ á
mappingFunctionÔÔá ñ
)ÔÔñ ó
)ÔÔó ò
;ÔÔò ô
public
 
 
TMappingExpression
 
AsProxy
 %
(
% &
)
& '
{
ÒÒ 
if
ÚÚ 

(
ÚÚ 
!
ÚÚ 
DestinationType
ÚÚ 
.
ÚÚ 
IsInterface
ÚÚ (
)
ÚÚ( )
{
ÛÛ 	
throw
ÙÙ 
new
ÙÙ '
InvalidOperationException
ÙÙ /
(
ÙÙ/ 0
$str
ÙÙ0 R
+
ÙÙS T
DestinationType
ÙÙU d
)
ÙÙd e
;
ÙÙe f
}
ıı 	
TypeMapActions
ˆˆ 
.
ˆˆ 
Add
ˆˆ 
(
ˆˆ 
tm
ˆˆ 
=>
ˆˆ  
tm
ˆˆ! #
.
ˆˆ# $
AsProxy
ˆˆ$ +
(
ˆˆ+ ,
)
ˆˆ, -
)
ˆˆ- .
;
ˆˆ. /
return
˜˜ 
this
˜˜ 
as
˜˜  
TMappingExpression
˜˜ )
;
˜˜) *
}
¯¯ 
}˘˘ ¯
aC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\SourceMappingExpression.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
public 
	interface &
ISourceMemberConfiguration +
{ 
void 
	Configure	 
( 
TypeMap 
typeMap "
)" #
;# $
} 
public		 
	interface		 0
$ISourceMemberConfigurationExpression		 5
{

 
void 
DoNotValidate	 
( 
) 
; 
} 
public 
sealed 
class #
SourceMappingExpression +
(+ ,

MemberInfo, 6
sourceMember7 C
)C D
:E F0
$ISourceMemberConfigurationExpressionG k
,k l'
ISourceMemberConfiguration	m á
{ 
private 
readonly 

MemberInfo 
_sourceMember  -
=. /
sourceMember0 <
;< =
private 
readonly 
List 
< 
Action  
<  !
SourceMemberConfig! 3
>3 4
>4 5 
_sourceMemberActions6 J
=K L
[M N
]N O
;O P
public 

void 
DoNotValidate 
( 
) 
=>  " 
_sourceMemberActions# 7
.7 8
Add8 ;
(; <
smc< ?
=>@ B
smcC F
.F G
IgnoredG N
=O P
trueQ U
)U V
;V W
public 

void 
	Configure 
( 
TypeMap !
typeMap" )
)) *
{ 
var  
sourcePropertyConfig  
=! "
typeMap# *
.* +-
!FindOrCreateSourceMemberConfigFor+ L
(L M
_sourceMemberM Z
)Z [
;[ \
foreach 
( 
var 
action 
in  
_sourceMemberActions 3
)3 4
{ 	
action 
(  
sourcePropertyConfig '
)' (
;( )
} 	
} 
} 
["" 
EditorBrowsable"" 
(""  
EditorBrowsableState"" %
.""% &
Never""& +
)""+ ,
]"", -
public## 
sealed## 
class## 
SourceMemberConfig## &
(##& '

MemberInfo##' 1
sourceMember##2 >
)##> ?
{$$ 
public%% 


MemberInfo%% 
SourceMember%% "
{%%# $
get%%% (
;%%( )
}%%* +
=%%, -
sourceMember%%. :
;%%: ;
public&& 

bool&& 
Ignored&& 
{&& 
get&& 
;&& 
set&& "
;&&" #
}&&$ %
}'' ÌÕ
QC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Profile.cs
	namespace 	

AutoMapper
 
; 
public 
	interface !
IProfileConfiguration &
{ 
bool 
? 	
FieldMappingEnabled
 
{ 
get  #
;# $
}% &
bool 
? 	 
MethodMappingEnabled
 
{  
get! $
;$ %
}& '
bool 
? 	%
ConstructorMappingEnabled
 #
{$ %
get& )
;) *
}+ ,
bool		 
?		 	&
AllowNullDestinationValues		
 $
{		% &
get		' *
;		* +
}		, -
bool

 
?

 	 
AllowNullCollections


 
{

  
get

! $
;

$ %
}

& '
bool 
? 	0
$EnableNullPropagationForQueryMapping
 .
{/ 0
get1 4
;4 5
}6 7
IReadOnlyCollection 
< 
Action 
< 
TypeMap &
,& '
IMappingExpression( :
>: ;
>; <
AllTypeMapActions= N
{O P
getQ T
;T U
}V W
IReadOnlyCollection 
< 
PropertyMapAction )
>) *!
AllPropertyMapActions+ @
{A B
getC F
;F G
}H I
IReadOnlyCollection 
< 

MethodInfo "
>" #"
SourceExtensionMethods$ :
{; <
get= @
;@ A
}B C
Func 
< 	
PropertyInfo	 
, 
bool 
> 
ShouldMapProperty .
{/ 0
get1 4
;4 5
}6 7
Func 
< 	
	FieldInfo	 
, 
bool 
> 
ShouldMapField (
{) *
get+ .
;. /
}0 1
Func$$ 
<$$ 	

MethodInfo$$	 
,$$ 
bool$$ 
>$$ 
ShouldMapMethod$$ *
{$$+ ,
get$$- 0
;$$0 1
}$$2 3
Func** 
<** 	
ConstructorInfo**	 
,** 
bool** 
>**  
ShouldUseConstructor**  4
{**5 6
get**7 :
;**: ;
}**< =
string,, 

ProfileName,, 
{,, 
get,, 
;,, 
},, 
IReadOnlyCollection-- 
<-- 
string-- 
>-- 
GlobalIgnores--  -
{--. /
get--0 3
;--3 4
}--5 6
INamingConvention.. (
SourceMemberNamingConvention.. 2
{..3 4
get..5 8
;..8 9
}..: ;
INamingConvention// -
!DestinationMemberNamingConvention// 7
{//8 9
get//: =
;//= >
}//? @
IReadOnlyCollection00 
<00  
TypeMapConfiguration00 ,
>00, -
TypeMapConfigs00. <
{00= >
get00? B
;00B C
}00D E
IReadOnlyCollection11 
<11  
TypeMapConfiguration11 ,
>11, -
OpenTypeMapConfigs11. @
{11A B
get11C F
;11F G
}11H I
IReadOnlyCollection22 
<22 )
ValueTransformerConfiguration22 5
>225 6
ValueTransformers227 H
{22I J
get22K N
;22N O
}22P Q
}33 
public77 
class77 
Profile77 
:77 &
IProfileExpressionInternal77 1
,771 2!
IProfileConfiguration773 H
{88 
private99 
readonly99 
List99 
<99 
string99  
>99  !
	_prefixes99" +
=99, -
[99. /
$str99/ 4
]994 5
;995 6
private:: 
readonly:: 
List:: 
<:: 
string::  
>::  !

_postfixes::" ,
=::- .
[::/ 0
]::0 1
;::1 2
private;; 
readonly;; 
List;; 
<;;  
TypeMapConfiguration;; .
>;;. /
_typeMapConfigs;;0 ?
=;;@ A
[;;B C
];;C D
;;;D E
private<< 
readonly<< 
PrePostfixName<< #
_prePostfixName<<$ 3
=<<4 5
new<<6 9
(<<9 :
)<<: ;
;<<; <
private== 
ReplaceName== 
_replaceName== $
;==$ %
private>> 
readonly>> 
MemberConfiguration>> ( 
_memberConfiguration>>) =
;>>= >
private?? 
List?? 
<?? 
PropertyMapAction?? "
>??" #"
_allPropertyMapActions??$ :
;??: ;
private@@ 
List@@ 
<@@ 
Action@@ 
<@@ 
TypeMap@@ 
,@@  
IMappingExpression@@! 3
>@@3 4
>@@4 5
_allTypeMapActions@@6 H
;@@H I
privateAA 
ListAA 
<AA 
stringAA 
>AA 
_globalIgnoresAA '
;AA' (
privateBB 
ListBB 
<BB  
TypeMapConfigurationBB %
>BB% &
_openTypeMapConfigsBB' :
;BB: ;
privateCC 
ListCC 
<CC 

MethodInfoCC 
>CC #
_sourceExtensionMethodsCC 4
;CC4 5
privateDD 
ListDD 
<DD )
ValueTransformerConfigurationDD .
>DD. /$
_valueTransformerConfigsDD0 H
;DDH I
privateEE 
boolEE 
?EE &
_constructorMappingEnabledEE ,
;EE, -
	protectedFF 
internalFF 
ProfileFF 
(FF 
stringFF %
profileNameFF& 1
)FF1 2
:FF3 4
thisFF5 9
(FF9 :
)FF: ;
=>FF< >
ProfileNameFF? J
=FFK L
profileNameFFM X
;FFX Y
	protectedGG 
ProfileGG 
(GG 
)GG 
{HH 
ProfileNameII 
=II 
GetTypeII 
(II 
)II 
.II  
FullNameII  (
;II( ) 
_memberConfigurationJJ 
=JJ 
newJJ "
(JJ" #
)JJ# $
{JJ$ %
NameToMemberMappersJJ& 9
=JJ: ;
{JJ< =
_prePostfixNameJJ> M
}JJN O
}JJP Q
;JJQ R
}KK 
	protectedLL 
internalLL 
ProfileLL 
(LL 
stringLL %
profileNameLL& 1
,LL1 2
ActionLL3 9
<LL9 :
IProfileExpressionLL: L
>LLL M
configurationActionLLN a
)LLa b
:LLc d
thisLLe i
(LLi j
profileNameLLj u
)LLu v
=>LLx z 
configurationAction	LL{ é
(
LLé è
this
LLè ì
)
LLì î
;
LLî ï
MemberConfigurationMM &
IProfileExpressionInternalMM 2
.MM2 3
MemberConfigurationMM3 F
=>MMG I 
_memberConfigurationMMJ ^
;MM^ _
boolNN 
?NN 	!
IProfileConfigurationNN
 
.NN  %
ConstructorMappingEnabledNN  9
=>NN: <&
_constructorMappingEnabledNN= W
;NNW X
boolOO 
?OO 	&
IProfileExpressionInternalOO
 $
.OO$ % 
MethodMappingEnabledOO% 9
{OO: ;
getOO< ?
;OO? @
setOOA D
;OOD E
}OOF G
boolPP 
?PP 	!
IProfileConfigurationPP
 
.PP   
MethodMappingEnabledPP  4
=>PP5 7
thisPP8 <
.PP< =
InternalPP= E
(PPE F
)PPF G
.PPG H 
MethodMappingEnabledPPH \
;PP\ ]
boolQQ 
?QQ 	&
IProfileExpressionInternalQQ
 $
.QQ$ %
FieldMappingEnabledQQ% 8
{QQ9 :
getQQ; >
;QQ> ?
setQQ@ C
;QQC D
}QQE F
boolRR 
?RR 	!
IProfileConfigurationRR
 
.RR  
FieldMappingEnabledRR  3
=>RR4 6
thisRR7 ;
.RR; <
InternalRR< D
(RRD E
)RRE F
.RRF G
FieldMappingEnabledRRG Z
;RRZ [
boolSS 
?SS 	!
IProfileConfigurationSS
 
.SS  0
$EnableNullPropagationForQueryMappingSS  D
=>SSE G
thisSSH L
.SSL M
InternalSSM U
(SSU V
)SSV W
.SSW X0
$EnableNullPropagationForQueryMappingSSX |
;SS| }
IReadOnlyCollectionTT 
<TT 
PropertyMapActionTT )
>TT) *!
IProfileConfigurationTT+ @
.TT@ A!
AllPropertyMapActionsTTA V
=>UU 
"
_allPropertyMapActionsUU !
.UU! "
	NullCheckUU" +
(UU+ ,
)UU, -
;UU- .
IReadOnlyCollectionVV 
<VV 
ActionVV 
<VV 
TypeMapVV &
,VV& '
IMappingExpressionVV( :
>VV: ;
>VV; <!
IProfileConfigurationVV= R
.VVR S
AllTypeMapActionsVVS d
=>VVe g
_allTypeMapActionsVVh z
.VVz {
	NullCheck	VV{ Ñ
(
VVÑ Ö
)
VVÖ Ü
;
VVÜ á
IReadOnlyCollectionWW 
<WW 
stringWW 
>WW !
IProfileConfigurationWW  5
.WW5 6
GlobalIgnoresWW6 C
=>WWD F
_globalIgnoresWWG U
.WWU V
	NullCheckWWV _
(WW_ `
)WW` a
;WWa b
IReadOnlyCollectionXX 
<XX 

MethodInfoXX "
>XX" #!
IProfileConfigurationXX$ 9
.XX9 :"
SourceExtensionMethodsXX: P
=>XXQ S#
_sourceExtensionMethodsXXT k
.XXk l
	NullCheckXXl u
(XXu v
)XXv w
;XXw x
IReadOnlyCollectionYY 
<YY  
TypeMapConfigurationYY ,
>YY, -!
IProfileConfigurationYY. C
.YYC D
TypeMapConfigsYYD R
=>YYS U
_typeMapConfigsYYV e
;YYe f
IReadOnlyCollectionZZ 
<ZZ  
TypeMapConfigurationZZ ,
>ZZ, -!
IProfileConfigurationZZ. C
.ZZC D
OpenTypeMapConfigsZZD V
=>ZZW Y
_openTypeMapConfigsZZZ m
.ZZm n
	NullCheckZZn w
(ZZw x
)ZZx y
;ZZy z
IReadOnlyCollection[[ 
<[[ )
ValueTransformerConfiguration[[ 5
>[[5 6!
IProfileConfiguration[[7 L
.[[L M
ValueTransformers[[M ^
=>[[_ a$
_valueTransformerConfigs[[b z
.[[z {
	NullCheck	[[{ Ñ
(
[[Ñ Ö
)
[[Ö Ü
;
[[Ü á
public]] 

virtual]] 
string]] 
ProfileName]] %
{]]& '
get]]( +
;]]+ ,
}]]- .
public^^ 

bool^^ 
?^^ &
AllowNullDestinationValues^^ +
{^^, -
get^^. 1
;^^1 2
set^^3 6
;^^6 7
}^^8 9
public__ 

bool__ 
?__  
AllowNullCollections__ %
{__& '
get__( +
;__+ ,
set__- 0
;__0 1
}__2 3
bool`` 
?`` 	&
IProfileExpressionInternal``
 $
.``$ %0
$EnableNullPropagationForQueryMapping``% I
{``J K
get``L O
;``O P
set``Q T
;``T U
}``V W
publicaa 

Funcaa 
<aa 
PropertyInfoaa 
,aa 
boolaa "
>aa" #
ShouldMapPropertyaa$ 5
{aa6 7
getaa8 ;
;aa; <
setaa= @
;aa@ A
}aaB C
publicbb 

Funcbb 
<bb 
	FieldInfobb 
,bb 
boolbb 
>bb  
ShouldMapFieldbb! /
{bb0 1
getbb2 5
;bb5 6
setbb7 :
;bb: ;
}bb< =
publiccc 

Funccc 
<cc 

MethodInfocc 
,cc 
boolcc  
>cc  !
ShouldMapMethodcc" 1
{cc2 3
getcc4 7
;cc7 8
setcc9 <
;cc< =
}cc> ?
publicdd 

Funcdd 
<dd 
ConstructorInfodd 
,dd  
booldd! %
>dd% & 
ShouldUseConstructordd' ;
{dd< =
getdd> A
;ddA B
setddC F
;ddF G
}ddH I
publicee 

INamingConventionee (
SourceMemberNamingConventionee 9
{ff 
getgg 
=>gg  
_memberConfigurationgg #
.gg# $"
SourceNamingConventiongg$ :
;gg: ;
sethh 
=>hh  
_memberConfigurationhh #
.hh# $"
SourceNamingConventionhh$ :
=hh; <
valuehh= B
;hhB C
}ii 
publicjj 

INamingConventionjj -
!DestinationMemberNamingConventionjj >
{kk 
getll 
=>ll  
_memberConfigurationll #
.ll# $'
DestinationNamingConventionll$ ?
;ll? @
setmm 
=>mm  
_memberConfigurationmm #
.mm# $'
DestinationNamingConventionmm$ ?
=mm@ A
valuemmB G
;mmG H
}nn 
publicoo 

Listoo 
<oo )
ValueTransformerConfigurationoo -
>oo- .
ValueTransformersoo/ @
=>ooA C$
_valueTransformerConfigsooD \
??=oo] `
[ooa b
]oob c
;ooc d
Listpp 
<pp 	
stringpp	 
>pp &
IProfileExpressionInternalpp +
.pp+ ,
Prefixespp, 4
=>pp5 7
	_prefixespp8 A
;ppA B
Listqq 
<qq 	
stringqq	 
>qq &
IProfileExpressionInternalqq +
.qq+ ,
	Postfixesqq, 5
=>qq6 8

_postfixesqq9 C
;qqC D
publicrr 

voidrr %
DisableConstructorMappingrr )
(rr) *
)rr* +
=>rr, .&
_constructorMappingEnabledrr/ I
=rrJ K
falserrL Q
;rrQ R
voidtt &
IProfileExpressionInternaltt	 #
.tt# $

ForAllMapstt$ .
(tt. /
Actiontt/ 5
<tt5 6
TypeMaptt6 =
,tt= >
IMappingExpressiontt? Q
>ttQ R
configurationttS `
)tt` a
{uu 
_allTypeMapActionsvv 
??=vv 
[vv  
]vv  !
;vv! "
_allTypeMapActionsww 
.ww 
Addww 
(ww 
configurationww ,
)ww, -
;ww- .
}xx 
voidzz &
IProfileExpressionInternalzz	 #
.zz# $
ForAllPropertyMapszz$ 6
(zz6 7
Funczz7 ;
<zz; <
PropertyMapzz< G
,zzG H
boolzzI M
>zzM N
	conditionzzO X
,zzX Y
ActionzzZ `
<zz` a
PropertyMapzza l
,zzl m+
IMemberConfigurationExpression	zzn å
>
zzå ç
configuration
zzé õ
)
zzõ ú
{{{ "
_allPropertyMapActions|| 
??=|| "
[||# $
]||$ %
;||% &"
_allPropertyMapActions}} 
.}} 
Add}} "
(}}" #
new}}# &
(}}& '
	condition}}' 0
,}}0 1
configuration}}2 ?
)}}? @
)}}@ A
;}}A B
}~~ 
public 
!
IProjectionExpression  
<  !
TSource! (
,( )
TDestination* 6
>6 7
CreateProjection8 H
<H I
TSourceI P
,P Q
TDestinationR ^
>^ _
(_ `
)` a
=>b d
CreateProjection
ÄÄ 
<
ÄÄ 
TSource
ÄÄ  
,
ÄÄ  !
TDestination
ÄÄ" .
>
ÄÄ. /
(
ÄÄ/ 0

MemberList
ÄÄ0 :
.
ÄÄ: ;
Destination
ÄÄ; F
)
ÄÄF G
;
ÄÄG H
public
ÅÅ 
#
IProjectionExpression
ÅÅ  
<
ÅÅ  !
TSource
ÅÅ! (
,
ÅÅ( )
TDestination
ÅÅ* 6
>
ÅÅ6 7
CreateProjection
ÅÅ8 H
<
ÅÅH I
TSource
ÅÅI P
,
ÅÅP Q
TDestination
ÅÅR ^
>
ÅÅ^ _
(
ÅÅ_ `

MemberList
ÅÅ` j

memberList
ÅÅk u
)
ÅÅu v
=>
ÅÅw y
(
ÇÇ 	#
IProjectionExpression
ÇÇ	 
<
ÇÇ 
TSource
ÇÇ &
,
ÇÇ& '
TDestination
ÇÇ( 4
>
ÇÇ4 5
)
ÇÇ5 6
CreateMapCore
ÇÇ6 C
<
ÇÇC D
TSource
ÇÇD K
,
ÇÇK L
TDestination
ÇÇM Y
>
ÇÇY Z
(
ÇÇZ [

memberList
ÇÇ[ e
,
ÇÇe f

projection
ÇÇg q
:
ÇÇq r
true
ÇÇs w
)
ÇÇw x
;
ÇÇx y
public
ÉÉ 
 
IMappingExpression
ÉÉ 
<
ÉÉ 
TSource
ÉÉ %
,
ÉÉ% &
TDestination
ÉÉ' 3
>
ÉÉ3 4
	CreateMap
ÉÉ5 >
<
ÉÉ> ?
TSource
ÉÉ? F
,
ÉÉF G
TDestination
ÉÉH T
>
ÉÉT U
(
ÉÉU V
)
ÉÉV W
=>
ÉÉX Z
CreateMapCore
ÑÑ 
<
ÑÑ 
TSource
ÑÑ 
,
ÑÑ 
TDestination
ÑÑ +
>
ÑÑ+ ,
(
ÑÑ, -

MemberList
ÑÑ- 7
.
ÑÑ7 8
Destination
ÑÑ8 C
)
ÑÑC D
;
ÑÑD E
public
ÖÖ 
 
IMappingExpression
ÖÖ 
<
ÖÖ 
TSource
ÖÖ %
,
ÖÖ% &
TDestination
ÖÖ' 3
>
ÖÖ3 4
	CreateMap
ÖÖ5 >
<
ÖÖ> ?
TSource
ÖÖ? F
,
ÖÖF G
TDestination
ÖÖH T
>
ÖÖT U
(
ÖÖU V

MemberList
ÖÖV `

memberList
ÖÖa k
)
ÖÖk l
=>
ÖÖm o
CreateMapCore
ÜÜ 
<
ÜÜ 
TSource
ÜÜ 
,
ÜÜ 
TDestination
ÜÜ +
>
ÜÜ+ ,
(
ÜÜ, -

memberList
ÜÜ- 7
)
ÜÜ7 8
;
ÜÜ8 9
private
áá  
IMappingExpression
áá 
<
áá 
TSource
áá &
,
áá& '
TDestination
áá( 4
>
áá4 5
CreateMapCore
áá6 C
<
ááC D
TSource
ááD K
,
ááK L
TDestination
ááM Y
>
ááY Z
(
ááZ [

MemberList
áá[ e

memberList
ááf p
,
ááp q
bool
áár v

projectionááw Å
=ááÇ É
falseááÑ â
)ááâ ä
{
àà 
MappingExpression
ââ 
<
ââ 
TSource
ââ !
,
ââ! "
TDestination
ââ# /
>
ââ/ 0

mappingExp
ââ1 ;
=
ââ< =
new
ââ> A
(
ââA B

memberList
ââB L
,
ââL M

projection
ââN X
)
ââX Y
;
ââY Z
_typeMapConfigs
ää 
.
ää 
Add
ää 
(
ää 

mappingExp
ää &
)
ää& '
;
ää' (
return
ãã 

mappingExp
ãã 
;
ãã 
}
åå 
public
éé 
 
IMappingExpression
éé 
	CreateMap
éé '
(
éé' (
Type
éé( ,

sourceType
éé- 7
,
éé7 8
Type
éé9 =
destinationType
éé> M
)
ééM N
=>
ééO Q
	CreateMap
èè 
(
èè 

sourceType
èè 
,
èè 
destinationType
èè -
,
èè- .

MemberList
èè/ 9
.
èè9 :
Destination
èè: E
)
èèE F
;
èèF G
public
ëë 
 
IMappingExpression
ëë 
	CreateMap
ëë '
(
ëë' (
Type
ëë( ,

sourceType
ëë- 7
,
ëë7 8
Type
ëë9 =
destinationType
ëë> M
,
ëëM N

MemberList
ëëO Y

memberList
ëëZ d
)
ëëd e
{
íí 
TypePair
ìì 
types
ìì 
=
ìì 
new
ìì 
(
ìì 

sourceType
ìì '
,
ìì' (
destinationType
ìì) 8
)
ìì8 9
;
ìì9 :
MappingExpression
îî 
map
îî 
=
îî 
new
îî  #
(
îî# $

memberList
îî$ .
,
îî. /
types
îî0 5
)
îî5 6
;
îî6 7
_typeMapConfigs
ïï 
.
ïï 
Add
ïï 
(
ïï 
map
ïï 
)
ïï  
;
ïï  !
if
ññ 

(
ññ 
types
ññ 
.
ññ '
ContainsGenericParameters
ññ +
)
ññ+ ,
{
óó 	!
_openTypeMapConfigs
òò 
??=
òò  #
[
òò$ %
]
òò% &
;
òò& '!
_openTypeMapConfigs
ôô 
.
ôô  
Add
ôô  #
(
ôô# $
map
ôô$ '
)
ôô' (
;
ôô( )
}
öö 	
return
õõ 
map
õõ 
;
õõ 
}
úú 
public
ùù 

void
ùù 
ClearPrefixes
ùù 
(
ùù 
)
ùù 
=>
ùù  "
	_prefixes
ùù# ,
.
ùù, -
Clear
ùù- 2
(
ùù2 3
)
ùù3 4
;
ùù4 5
public
ûû 

void
ûû 
ReplaceMemberName
ûû !
(
ûû! "
string
ûû" (
original
ûû) 1
,
ûû1 2
string
ûû3 9
newValue
ûû: B
)
ûûB C
{
üü 
if
†† 

(
†† 
_replaceName
†† 
==
†† 
null
††  
)
††  !
{
°° 	
_replaceName
¢¢ 
=
¢¢ 
new
¢¢ 
(
¢¢ 
)
¢¢  
;
¢¢  !"
_memberConfiguration
££  
.
££  !!
NameToMemberMappers
££! 4
.
££4 5
Add
££5 8
(
££8 9
_replaceName
££9 E
)
££E F
;
££F G
}
§§ 	
_replaceName
•• 
.
•• !
MemberNameReplacers
•• (
.
••( )
TryAdd
••) /
(
••/ 0
new
••0 3 
MemberNameReplacer
••4 F
(
••F G
original
••G O
,
••O P
newValue
••Q Y
)
••Y Z
)
••Z [
;
••[ \
}
¶¶ 
public
ßß 

void
ßß 
RecognizePrefixes
ßß !
(
ßß! "
params
ßß" (
string
ßß) /
[
ßß/ 0
]
ßß0 1
prefixes
ßß2 :
)
ßß: ;
=>
ßß< >
	_prefixes
ßß? H
.
ßßH I
TryAdd
ßßI O
(
ßßO P
prefixes
ßßP X
)
ßßX Y
;
ßßY Z
public
®® 

void
®®  
RecognizePostfixes
®® "
(
®®" #
params
®®# )
string
®®* 0
[
®®0 1
]
®®1 2
	postfixes
®®3 <
)
®®< =
=>
®®> @

_postfixes
®®A K
.
®®K L
TryAdd
®®L R
(
®®R S
	postfixes
®®S \
)
®®\ ]
;
®®] ^
public
©© 

void
©© *
RecognizeDestinationPrefixes
©© ,
(
©©, -
params
©©- 3
string
©©4 :
[
©©: ;
]
©©; <
prefixes
©©= E
)
©©E F
=>
©©G I
_prePostfixName
©©J Y
.
©©Y Z!
DestinationPrefixes
©©Z m
.
©©m n
TryAdd
©©n t
(
©©t u
prefixes
©©u }
)
©©} ~
;
©©~ 
public
™™ 

void
™™ +
RecognizeDestinationPostfixes
™™ -
(
™™- .
params
™™. 4
string
™™5 ;
[
™™; <
]
™™< =
	postfixes
™™> G
)
™™G H
=>
™™I K
_prePostfixName
™™L [
.
™™[ \"
DestinationPostfixes
™™\ p
.
™™p q
TryAdd
™™q w
(
™™w x
	postfixes™™x Å
)™™Å Ç
;™™Ç É
public
´´ 

void
´´ 
AddGlobalIgnore
´´ 
(
´´  
string
´´  &&
propertyNameStartingWith
´´' ?
)
´´? @
{
¨¨ 
_globalIgnores
≠≠ 
??=
≠≠ 
[
≠≠ 
]
≠≠ 
;
≠≠ 
_globalIgnores
ÆÆ 
.
ÆÆ 
Add
ÆÆ 
(
ÆÆ &
propertyNameStartingWith
ÆÆ 3
)
ÆÆ3 4
;
ÆÆ4 5
}
ØØ 
public
∞∞ 

void
∞∞ +
IncludeSourceExtensionMethods
∞∞ -
(
∞∞- .
Type
∞∞. 2
type
∞∞3 7
)
∞∞7 8
{
±± %
_sourceExtensionMethods
≤≤ 
??=
≤≤  #
[
≤≤$ %
]
≤≤% &
;
≤≤& '%
_sourceExtensionMethods
≥≥ 
.
≥≥  
AddRange
≥≥  (
(
≥≥( )
type
¥¥ 
.
¥¥ 

GetMethods
¥¥ 
(
¥¥ 
Internal
¥¥ $
.
¥¥$ %
TypeExtensions
¥¥% 3
.
¥¥3 4
StaticFlags
¥¥4 ?
)
¥¥? @
.
¥¥@ A
Where
¥¥A F
(
¥¥F G
m
¥¥G H
=>
¥¥I K
m
¥¥L M
.
¥¥M N
Has
¥¥N Q
<
¥¥Q R 
ExtensionAttribute
¥¥R d
>
¥¥d e
(
¥¥e f
)
¥¥f g
&&
¥¥h j
m
¥¥k l
.
¥¥l m
GetParameters
¥¥m z
(
¥¥z {
)
¥¥{ |
.
¥¥| }
Length¥¥} É
==¥¥Ñ Ü
$num¥¥á à
)¥¥à â
)¥¥â ä
;¥¥ä ã
}
µµ 
}∂∂ 
public∑∑ 
readonly
∑∑ 
record
∑∑ 
struct
∑∑ 
PropertyMapAction
∑∑ /
(
∑∑/ 0
Func
∑∑0 4
<
∑∑4 5
PropertyMap
∑∑5 @
,
∑∑@ A
bool
∑∑B F
>
∑∑F G
	Condition
∑∑H Q
,
∑∑Q R
Action
∑∑S Y
<
∑∑Y Z
PropertyMap
∑∑Z e
,
∑∑e f-
IMemberConfigurationExpression∑∑g Ö
>∑∑Ö Ü
Action∑∑á ç
)∑∑ç é
;∑∑é èÚR
eC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\PathConfigurationExpression.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
public 
	interface (
IPathConfigurationExpression -
<- .
TSource. 5
,5 6
TDestination7 C
,C D
TMemberE L
>L M
{		 
void 
MapFrom	 
< 
TSourceMember 
> 
(  

Expression  *
<* +
Func+ /
</ 0
TSource0 7
,7 8
TSourceMember9 F
>F G
>G H
sourceMemberI U
)U V
;V W
void 
Ignore	 
( 
) 
; 
void 
	Condition	 
( 
Func 
< 
ConditionParameters +
<+ ,
TSource, 3
,3 4
TDestination5 A
,A B
TMemberC J
>J K
,K L
boolM Q
>Q R
	conditionS \
)\ ]
;] ^
} 
public 
readonly 
record 
struct 
ConditionParameters 1
<1 2
TSource2 9
,9 :
TDestination; G
,G H
TMemberI P
>P Q
(Q R
TSourceR Y
SourceZ `
,` a
TDestinationb n
Destinationo z
,z {
TMember	| É
SourceMember
Ñ ê
,
ê ë
TMember
í ô
DestinationMember
ö ´
,
´ ¨
ResolutionContext
≠ æ
Context
ø ∆
)
∆ «
;
« »
public 
sealed 
class '
PathConfigurationExpression /
</ 0
TSource0 7
,7 8
TDestination9 E
,E F
TMemberG N
>N O
(O P
LambdaExpressionP `!
destinationExpressiona v
,v w
Stackx }
<} ~
Member	~ Ñ
>
Ñ Ö
chain
Ü ã
)
ã å
:
ç é*
IPathConfigurationExpression
è ´
<
´ ¨
TSource
¨ ≥
,
≥ ¥
TDestination
µ ¡
,
¡ ¬
TMember
√  
>
  À
,
À Ã'
IPropertyMapConfiguration
Õ Ê
{ 
private 
readonly 
LambdaExpression %"
_destinationExpression& <
== >!
destinationExpression? T
;T U
private 
LambdaExpression 
_sourceExpression .
;. /
List 
< 	
Action	 
< 
PathMap 
> 
> 
PathMapActions (
{) *
get+ .
;. /
}0 1
=2 3
[4 5
]5 6
;6 7
public 


MemberPath 

MemberPath  
{! "
get# &
;& '
}( )
=* +
new, /
(/ 0
chain0 5
)5 6
;6 7
public 


MemberInfo 
DestinationMember '
=>( *

MemberPath+ 5
.5 6
Last6 :
;: ;
public 

void 
MapFrom 
< 
TSourceMember %
>% &
(& '

Expression' 1
<1 2
Func2 6
<6 7
TSource7 >
,> ?
TSourceMember@ M
>M N
>N O
sourceExpressionP `
)` a
=>b d
MapFromUntypede s
(s t
sourceExpression	t Ñ
)
Ñ Ö
;
Ö Ü
public   

void   
Ignore   
(   
)   
=>   
PathMapActions   *
.  * +
Add  + .
(  . /
pm  / 1
=>  2 4
pm  5 7
.  7 8
Ignored  8 ?
=  @ A
true  B F
)  F G
;  G H
public!! 

void!! 
MapFromUntyped!! 
(!! 
LambdaExpression!! /
sourceExpression!!0 @
)!!@ A
{"" 
_sourceExpression## 
=## 
sourceExpression## ,
??##- /
throw##0 5
new##6 9!
ArgumentNullException##: O
(##O P
nameof##P V
(##V W
sourceExpression##W g
)##g h
,##h i
$"##j l
{##l m
nameof##m s
(##s t
sourceExpression	##t Ñ
)
##Ñ Ö
}
##Ö Ü
$str
##Ü §
{
##§ •
DestinationMember
##• ∂
.
##∂ ∑
Name
##∑ ª
}
##ª º
$str
##º ¬
{
##¬ √
typeof
##√ …
(
##…  
TSource
##  —
)
##— “
}
##“ ”
$str
##” ◊
{
##◊ ÿ
typeof
##ÿ ﬁ
(
##ﬁ ﬂ
TDestination
##ﬂ Î
)
##Î Ï
}
##Ï Ì
$str
##Ì Ó
"
##Ó Ô
)
##Ô 
;
## Ò
PathMapActions$$ 
.$$ 
Add$$ 
($$ 
pm$$ 
=>$$  
pm$$! #
.$$# $
MapFrom$$$ +
($$+ ,
sourceExpression$$, <
)$$< =
)$$= >
;$$> ?
}%% 
public&& 

void&& 
	Configure&& 
(&& 
TypeMap&& !
typeMap&&" )
)&&) *
{'' 
var(( 
pathMap(( 
=(( 
typeMap(( 
.(( "
FindOrCreatePathMapFor(( 4
(((4 5"
_destinationExpression((5 K
,((K L

MemberPath((M W
,((W X
typeMap((Y `
)((` a
;((a b
Apply)) 
()) 
pathMap)) 
))) 
;)) 
}** 
private++ 
void++ 
Apply++ 
(++ 
PathMap++ 
pathMap++ &
)++& '
{,, 
foreach-- 
(-- 
var-- 
action-- 
in-- 
PathMapActions-- -
)--- .
{.. 	
action// 
(// 
pathMap// 
)// 
;// 
}00 	
}11 
internal22 
static22 %
IPropertyMapConfiguration22 -
Create22. 4
(224 5
LambdaExpression225 E
destination22F Q
,22Q R
LambdaExpression22S c
source22d j
)22j k
{33 
if44 

(44 
destination44 
==44 
null44 
||44  "
!44# $
destination44$ /
.44/ 0
IsMemberPath440 <
(44< =
out44= @
var44A D
chain44E J
)44J K
)44K L
{55 	
return66 
null66 
;66 
}77 	'
PathConfigurationExpression88 #
<88# $
TSource88$ +
,88+ ,
TDestination88- 9
,889 :
object88; A
>88A B
reversed88C K
=88L M
new88N Q
(88Q R
destination88R ]
,88] ^
chain88_ d
)88d e
;88e f
if99 

(99 
reversed99 
.99 

MemberPath99 
.99  
Length99  &
==99' )
$num99* +
)99+ ,
{:: 	)
MemberConfigurationExpression;; )
<;;) *
TSource;;* 1
,;;1 2
TDestination;;3 ?
,;;? @
object;;A G
>;;G H$
reversedMemberExpression;;I a
=;;b c
new;;d g
(;;g h
reversed;;h p
.;;p q
DestinationMember	;;q Ç
,
;;Ç É
typeof
;;Ñ ä
(
;;ä ã
TSource
;;ã í
)
;;í ì
)
;;ì î
;
;;î ï$
reversedMemberExpression<< $
.<<$ %
MapFromExpression<<% 6
(<<6 7
source<<7 =
)<<= >
;<<> ?
return== $
reversedMemberExpression== +
;==+ ,
}>> 	
reversed?? 
.?? 
MapFromUntyped?? 
(??  
source??  &
)??& '
;??' (
return@@ 
reversed@@ 
;@@ 
}AA 
publicBB 

LambdaExpressionBB 
SourceExpressionBB ,
=>BB- /
_sourceExpressionBB0 A
;BBA B
publicCC 

LambdaExpressionCC $
GetDestinationExpressionCC 4
(CC4 5
)CC5 6
=>CC7 9"
_destinationExpressionCC: P
;CCP Q
publicDD 
%
IPropertyMapConfigurationDD $
ReverseDD% ,
(DD, -
)DD- .
=>DD/ 1
CreateDD2 8
(DD8 9
_sourceExpressionDD9 J
,DDJ K"
_destinationExpressionDDL b
)DDb c
;DDc d
publicEE 

voidEE 
	ConditionEE 
(EE 
FuncEE 
<EE 
ConditionParametersEE 2
<EE2 3
TSourceEE3 :
,EE: ;
TDestinationEE< H
,EEH I
TMemberEEJ Q
>EEQ R
,EER S
boolEET X
>EEX Y
	conditionEEZ c
)EEc d
=>EEe g
PathMapActionsFF 
.FF 
AddFF 
(FF 
pmFF 
=>FF  
{GG 	

ExpressionHH 
<HH 
FuncHH 
<HH 
TSourceHH #
,HH# $
TDestinationHH% 1
,HH1 2
TMemberHH3 :
,HH: ;
TMemberHH< C
,HHC D
ResolutionContextHHE V
,HHV W
boolHHX \
>HH\ ]
>HH] ^
exprHH_ c
=HHd e
(II 
srcII 
,II 
destII 
,II 
	srcMemberII %
,II% &

destMemberII' 1
,II1 2
ctxtII3 7
)II7 8
=>II9 ;
	conditionII< E
(IIE F
newIIF I
(III J
srcIIJ M
,IIM N
destIIO S
,IIS T
	srcMemberIIU ^
,II^ _

destMemberII` j
,IIj k
ctxtIIl p
)IIp q
)IIq r
;IIr s
pmJJ 
.JJ 
	ConditionJJ 
=JJ 
exprJJ 
;JJ  
}KK 	
)KK	 

;KK
 
}LL ÏÀ
gC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\MemberConfigurationExpression.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
public 
	interface %
IPropertyMapConfiguration *
{ 
void 
	Configure	 
( 
TypeMap 
typeMap "
)" #
;# $

MemberInfo 
DestinationMember  
{! "
get# &
;& '
}( )
LambdaExpression 
SourceExpression %
{& '
get( +
;+ ,
}- .
LambdaExpression $
GetDestinationExpression -
(- .
). /
;/ 0%
IPropertyMapConfiguration 
Reverse %
(% &
)& '
;' (
bool		 
Ignored			 
=>		 
false		 
;		 
}

 
public 
class )
MemberConfigurationExpression *
<* +
TSource+ 2
,2 3
TDestination4 @
,@ A
TMemberB I
>I J
(J K

MemberInfoK U
destinationMemberV g
,g h
Typei m

sourceTypen x
)x y
:z {+
IMemberConfigurationExpression	| ö
<
ö õ
TSource
õ ¢
,
¢ £
TDestination
§ ∞
,
∞ ±
TMember
≤ π
>
π ∫
,
∫ ª'
IPropertyMapConfiguration
º ’
{ 
private 

MemberInfo 
[ 
] 
_sourceMembers '
;' (
private 
readonly 
Type 
_sourceType %
=& '

sourceType( 2
;2 3
	protected 
List 
< 
Action 
< 
PropertyMap %
>% &
>& '
PropertyMapActions( :
{; <
get= @
;@ A
}B C
=D E
[F G
]G H
;H I
public 


MemberInfo 
DestinationMember '
{( )
get* -
;- .
}/ 0
=1 2
destinationMember3 D
;D E
public 

void 
MapAtRuntime 
( 
) 
=> !
PropertyMapActions" 4
.4 5
Add5 8
(8 9
pm9 ;
=>< >
pm? A
.A B
InlineB H
=I J
falseK P
)P Q
;Q R
public 

void 
NullSubstitute 
( 
object %
nullSubstitute& 4
)4 5
=>6 8
PropertyMapActions9 K
.K L
AddL O
(O P
pmP R
=>S U
pmV X
.X Y
NullSubstituteY g
=h i
nullSubstitutej x
)x y
;y z
public 

void 
MapFrom 
< 
TValueResolver &
>& '
(' (
)( )
where* /
TValueResolver0 >
:? @
IValueResolverA O
<O P
TSourceP W
,W X
TDestinationY e
,e f
TMemberg n
>n o
=>p r
MapFromCore 
( 
new 
( 
typeof 
( 
TValueResolver -
)- .
,. /
typeof0 6
(6 7
IValueResolver7 E
<E F
TSourceF M
,M N
TDestinationO [
,[ \
TMember] d
>d e
)e f
)f g
)g h
;h i
	protected 
void 
MapFromCore 
( 
ClassValueResolver 1
config2 8
)8 9
=>: <
SetResolver= H
(H I
configI O
)O P
;P Q
	protected 
void 
SetResolver 
( 
IValueResolver -
config. 4
)4 5
=>6 8
PropertyMapActions9 K
.K L
AddL O
(O P
pmP R
=>S U
pmV X
.X Y
SetResolverY d
(d e
confige k
)k l
)l m
;m n
public 

void 
MapFrom 
< 
TValueResolver &
,& '
TSourceMember( 5
>5 6
(6 7

Expression7 A
<A B
FuncB F
<F G
TSourceG N
,N O
TSourceMemberP ]
>] ^
>^ _
sourceMember` l
)l m
where 
TValueResolver 
:  
IMemberValueResolver 3
<3 4
TSource4 ;
,; <
TDestination= I
,I J
TSourceMemberK X
,X Y
TMemberZ a
>a b
=>c e
MapFromCore 
< 
TValueResolver &
,& '
TSourceMember( 5
>5 6
(6 7
sourceMember7 C
)C D
;D E
public 

void 
MapFrom 
< 
TValueResolver &
,& '
TSourceMember( 5
>5 6
(6 7
string7 =
sourceMemberName> N
)N O
whereP U
TValueResolverV d
:e f 
IMemberValueResolverg {
<{ |
TSource	| É
,
É Ñ
TDestination
Ö ë
,
ë í
TSourceMember
ì †
,
† °
TMember
¢ ©
>
© ™
=>
´ ≠
MapFromCore 
< 
TValueResolver &
,& '
TSourceMember( 5
>5 6
(6 7
null7 ;
,; <
sourceMemberName= M
)M N
;N O
private 
void 
MapFromCore 
< 
TValueResolver +
,+ ,
TSourceMember- :
>: ;
(; <

Expression< F
<F G
FuncG K
<K L
TSourceL S
,S T
TSourceMemberU b
>b c
>c d
sourceMembere q
,q r
strings y
sourceMemberName	z ä
=
ã å
null
ç ë
)
ë í
where
ì ò
TValueResolver
ô ß
:
® ©"
IMemberValueResolver
™ æ
<
æ ø
TSource
ø ∆
,
∆ «
TDestination
» ‘
,
‘ ’
TSourceMember
÷ „
,
„ ‰
TMember
Â Ï
>
Ï Ì
=>
Ó 
MapFromCore 
( 
new 
( 
typeof 
( 
TValueResolver -
)- .
,. /
typeof0 6
(6 7 
IMemberValueResolver7 K
<K L
TSourceL S
,S T
TDestinationU a
,a b
TSourceMemberc p
,p q
TMemberr y
>y z
)z {
,{ |
sourceMemberName	} ç
)
ç é
{ 	
SourceMemberLambda 
=  
sourceMember! -
}   	
)  	 

;  
 
public!! 

void!! 
MapFrom!! 
(!! 
IValueResolver!! &
<!!& '
TSource!!' .
,!!. /
TDestination!!0 <
,!!< =
TMember!!> E
>!!E F
valueResolver!!G T
)!!T U
=>!!V X
MapFromCore"" 
("" 
new"" 
("" 
valueResolver"" %
,""% &
typeof""' -
(""- .
IValueResolver"". <
<""< =
TSource""= D
,""D E
TDestination""F R
,""R S
TMember""T [
>""[ \
)""\ ]
)""] ^
)""^ _
;""_ `
public## 

void## 
MapFrom## 
<## 
TSourceMember## %
>##% &
(##& ' 
IMemberValueResolver##' ;
<##; <
TSource##< C
,##C D
TDestination##E Q
,##Q R
TSourceMember##S `
,##` a
TMember##b i
>##i j
valueResolver##k x
,##x y

Expression	##z Ñ
<
##Ñ Ö
Func
##Ö â
<
##â ä
TSource
##ä ë
,
##ë í
TSourceMember
##ì †
>
##† °
>
##° ¢
sourceMember
##£ Ø
)
##Ø ∞
=>
##± ≥
MapFromCore$$ 
($$ 
new$$ 
($$ 
valueResolver$$ %
,$$% &
typeof$$' -
($$- . 
IMemberValueResolver$$. B
<$$B C
TSource$$C J
,$$J K
TDestination$$L X
,$$X Y
TSourceMember$$Z g
,$$g h
TMember$$i p
>$$p q
)$$q r
)$$r s
{%% 	
SourceMemberLambda&& 
=&&  
sourceMember&&! -
}'' 	
)''	 

;''
 
public(( 

void(( 
MapFrom(( 
<(( 
TResult(( 
>((  
(((  !
Func((! %
<((% &
TSource((& -
,((- .
TDestination((/ ;
,((; <
TResult((= D
>((D E
mappingFunction((F U
)((U V
=>((W Y
MapFromFunc)) 
()) 
()) 
src)) 
,)) 
dest)) 
,)) 

destMember))  *
,))* +
ctxt)), 0
)))0 1
=>))2 4
mappingFunction))5 D
())D E
src))E H
,))H I
dest))J N
)))N O
)))O P
;))P Q
public** 

void** 
MapFrom** 
<** 
TResult** 
>**  
(**  !
Func**! %
<**% &
TSource**& -
,**- .
TDestination**/ ;
,**; <
TMember**= D
,**D E
TResult**F M
>**M N
mappingFunction**O ^
)**^ _
=>**` b
MapFromFunc++ 
(++ 
(++ 
src++ 
,++ 
dest++ 
,++ 

destMember++  *
,++* +
ctxt++, 0
)++0 1
=>++2 4
mappingFunction++5 D
(++D E
src++E H
,++H I
dest++J N
,++N O

destMember++P Z
)++Z [
)++[ \
;++\ ]
public,, 

void,, 
MapFrom,, 
<,, 
TResult,, 
>,,  
(,,  !
Func,,! %
<,,% &
TSource,,& -
,,,- .
TDestination,,/ ;
,,,; <
TMember,,= D
,,,D E
ResolutionContext,,F W
,,,W X
TResult,,Y `
>,,` a
mappingFunction,,b q
),,q r
=>,,s u
MapFromFunc-- 
(-- 
(-- 
src-- 
,-- 
dest-- 
,-- 

destMember--  *
,--* +
ctxt--, 0
)--0 1
=>--2 4
mappingFunction--5 D
(--D E
src--E H
,--H I
dest--J N
,--N O

destMember--P Z
,--Z [
ctxt--\ `
)--` a
)--a b
;--b c
private.. 
void.. 
MapFromFunc.. 
<.. 
TResult.. $
>..$ %
(..% &

Expression..& 0
<..0 1
Func..1 5
<..5 6
TSource..6 =
,..= >
TDestination..? K
,..K L
TMember..M T
,..T U
ResolutionContext..V g
,..g h
TResult..i p
>..p q
>..q r
expr..s w
)..w x
=>..y {
SetResolver// 
(// 
new// 
FuncResolver// $
(//$ %
expr//% )
)//) *
)//* +
;//+ ,
public00 

void00 
MapFrom00 
<00 
TSourceMember00 %
>00% &
(00& '

Expression00' 1
<001 2
Func002 6
<006 7
TSource007 >
,00> ?
TSourceMember00@ M
>00M N
>00N O
mapExpression00P ]
)00] ^
=>00_ a
MapFromExpression00b s
(00s t
mapExpression	00t Å
)
00Å Ç
;
00Ç É
internal11 
void11 
MapFromExpression11 #
(11# $
LambdaExpression11$ 4
sourceExpression115 E
)11E F
{22 
SourceExpression33 
=33 
sourceExpression33 +
;33+ ,
PropertyMapActions44 
.44 
Add44 
(44 
pm44 !
=>44" $
pm44% '
.44' (
MapFrom44( /
(44/ 0
sourceExpression440 @
)44@ A
)44A B
;44B C
}55 
public66 

void66 
MapFrom66 
(66 
string66 
sourceMembersPath66 0
)660 1
{77 
_sourceMembers88 
=88 
ReflectionHelper88 )
.88) *
GetMemberPath88* 7
(887 8
_sourceType888 C
,88C D
sourceMembersPath88E V
)88V W
;88W X
PropertyMapActions99 
.99 
Add99 
(99 
pm99 !
=>99" $
pm99% '
.99' (
MapFrom99( /
(99/ 0
sourceMembersPath990 A
,99A B
_sourceMembers99C Q
)99Q R
)99R S
;99S T
}:: 
public;; 

void;; 
	Condition;; 
(;; 
Func;; 
<;; 
TSource;; &
,;;& '
TDestination;;( 4
,;;4 5
TMember;;6 =
,;;= >
TMember;;? F
,;;F G
ResolutionContext;;H Y
,;;Y Z
bool;;[ _
>;;_ `
	condition;;a j
);;j k
=>;;l n
ConditionCore<< 
(<< 
(<< 
src<< 
,<< 
dest<<  
,<<  !
	srcMember<<" +
,<<+ ,

destMember<<- 7
,<<7 8
ctxt<<9 =
)<<= >
=><<? A
	condition<<B K
(<<K L
src<<L O
,<<O P
dest<<Q U
,<<U V
	srcMember<<W `
,<<` a

destMember<<b l
,<<l m
ctxt<<n r
)<<r s
)<<s t
;<<t u
public== 

void== 
	Condition== 
(== 
Func== 
<== 
TSource== &
,==& '
TDestination==( 4
,==4 5
TMember==6 =
,=== >
TMember==? F
,==F G
bool==H L
>==L M
	condition==N W
)==W X
=>==Y [
ConditionCore>> 
(>> 
(>> 
src>> 
,>> 
dest>>  
,>>  !
	srcMember>>" +
,>>+ ,

destMember>>- 7
,>>7 8
ctxt>>9 =
)>>= >
=>>>? A
	condition>>B K
(>>K L
src>>L O
,>>O P
dest>>Q U
,>>U V
	srcMember>>W `
,>>` a

destMember>>b l
)>>l m
)>>m n
;>>n o
public?? 

void?? 
	Condition?? 
(?? 
Func?? 
<?? 
TSource?? &
,??& '
TDestination??( 4
,??4 5
TMember??6 =
,??= >
bool??? C
>??C D
	condition??E N
)??N O
=>??P R
ConditionCore@@ 
(@@ 
(@@ 
src@@ 
,@@ 
dest@@  
,@@  !
	srcMember@@" +
,@@+ ,

destMember@@- 7
,@@7 8
ctxt@@9 =
)@@= >
=>@@? A
	condition@@B K
(@@K L
src@@L O
,@@O P
dest@@Q U
,@@U V
	srcMember@@W `
)@@` a
)@@a b
;@@b c
publicAA 

voidAA 
	ConditionAA 
(AA 
FuncAA 
<AA 
TSourceAA &
,AA& '
TDestinationAA( 4
,AA4 5
boolAA6 :
>AA: ;
	conditionAA< E
)AAE F
=>AAG I
ConditionCoreAAJ W
(AAW X
(AAX Y
srcAAY \
,AA\ ]
destAA^ b
,AAb c
	srcMemberAAd m
,AAm n

destMemberAAo y
,AAy z
ctxtAA{ 
)	AA Ä
=>
AAÅ É
	condition
AAÑ ç
(
AAç é
src
AAé ë
,
AAë í
dest
AAì ó
)
AAó ò
)
AAò ô
;
AAô ö
publicBB 

voidBB 
	ConditionBB 
(BB 
FuncBB 
<BB 
TSourceBB &
,BB& '
boolBB( ,
>BB, -
	conditionBB. 7
)BB7 8
=>BB9 ;
ConditionCoreBB< I
(BBI J
(BBJ K
srcBBK N
,BBN O
destBBP T
,BBT U
	srcMemberBBV _
,BB_ `

destMemberBBa k
,BBk l
ctxtBBm q
)BBq r
=>BBs u
	conditionBBv 
(	BB Ä
src
BBÄ É
)
BBÉ Ñ
)
BBÑ Ö
;
BBÖ Ü
privateCC 
voidCC 
ConditionCoreCC 
(CC 

ExpressionCC )
<CC) *
FuncCC* .
<CC. /
TSourceCC/ 6
,CC6 7
TDestinationCC8 D
,CCD E
TMemberCCF M
,CCM N
TMemberCCO V
,CCV W
ResolutionContextCCX i
,CCi j
boolCCk o
>CCo p
>CCp q
exprCCr v
)CCv w
=>CCx z
PropertyMapActionsDD 
.DD 
AddDD 
(DD 
pmDD !
=>DD" $
pmDD% '
.DD' (
	ConditionDD( 1
=DD2 3
exprDD4 8
)DD8 9
;DD9 :
publicEE 

voidEE 
PreConditionEE 
(EE 
FuncEE !
<EE! "
TSourceEE" )
,EE) *
boolEE+ /
>EE/ 0
	conditionEE1 :
)EE: ;
=>EE< >
PreConditionCoreEE? O
(EEO P
(EEP Q
srcEEQ T
,EET U
destEEV Z
,EEZ [
ctxtEE\ `
)EE` a
=>EEb d
	conditionEEe n
(EEn o
srcEEo r
)EEr s
)EEs t
;EEt u
publicFF 

voidFF 
PreConditionFF 
(FF 
FuncFF !
<FF! "
ResolutionContextFF" 3
,FF3 4
boolFF5 9
>FF9 :
	conditionFF; D
)FFD E
=>FFF H
PreConditionCoreFFI Y
(FFY Z
(FFZ [
srcFF[ ^
,FF^ _
destFF` d
,FFd e
ctxtFFf j
)FFj k
=>FFl n
	conditionFFo x
(FFx y
ctxtFFy }
)FF} ~
)FF~ 
;	FF Ä
publicGG 

voidGG 
PreConditionGG 
(GG 
FuncGG !
<GG! "
TSourceGG" )
,GG) *
ResolutionContextGG+ <
,GG< =
boolGG> B
>GGB C
	conditionGGD M
)GGM N
=>GGO Q
PreConditionCoreGGR b
(GGb c
(GGc d
srcGGd g
,GGg h
destGGi m
,GGm n
ctxtGGo s
)GGs t
=>GGu w
	condition	GGx Å
(
GGÅ Ç
src
GGÇ Ö
,
GGÖ Ü
ctxt
GGá ã
)
GGã å
)
GGå ç
;
GGç é
publicHH 

voidHH 
PreConditionHH 
(HH 
FuncHH !
<HH! "
TSourceHH" )
,HH) *
TDestinationHH+ 7
,HH7 8
ResolutionContextHH9 J
,HHJ K
boolHHL P
>HHP Q
	conditionHHR [
)HH[ \
=>HH] _
PreConditionCoreHH` p
(HHp q
(HHq r
srcHHr u
,HHu v
destHHw {
,HH{ |
ctxt	HH} Å
)
HHÅ Ç
=>
HHÉ Ö
	condition
HHÜ è
(
HHè ê
src
HHê ì
,
HHì î
dest
HHï ô
,
HHô ö
ctxt
HHõ ü
)
HHü †
)
HH† °
;
HH° ¢
privateII 
voidII 
PreConditionCoreII !
(II! "

ExpressionII" ,
<II, -
FuncII- 1
<II1 2
TSourceII2 9
,II9 :
TDestinationII; G
,IIG H
ResolutionContextIII Z
,IIZ [
boolII\ `
>II` a
>IIa b
exprIIc g
)IIg h
=>IIi k
PropertyMapActionsJJ 
.JJ 
AddJJ 
(JJ 
pmJJ !
=>JJ" $
pmJJ% '
.JJ' (
PreConditionJJ( 4
=JJ5 6
exprJJ7 ;
)JJ; <
;JJ< =
publicKK 

voidKK 
AddTransformKK 
(KK 

ExpressionKK '
<KK' (
FuncKK( ,
<KK, -
TMemberKK- 4
,KK4 5
TMemberKK6 =
>KK= >
>KK> ?
transformerKK@ K
)KKK L
=>KKM O
PropertyMapActionsLL 
.LL 
AddLL 
(LL 
pmLL !
=>LL" $
pmLL% '
.LL' ("
AddValueTransformationLL( >
(LL> ?
newLL? B)
ValueTransformerConfigurationLLC `
(LL` a
pmLLa c
.LLc d
DestinationTypeLLd s
,LLs t
transformer	LLu Ä
)
LLÄ Å
)
LLÅ Ç
)
LLÇ É
;
LLÉ Ñ
publicMM 

voidMM 
ExplicitExpansionMM !
(MM! "
boolMM" &
valueMM' ,
)MM, -
=>MM. 0
PropertyMapActionsMM1 C
.MMC D
AddMMD G
(MMG H
pmMMH J
=>MMK M
pmMMN P
.MMP Q
ExplicitExpansionMMQ b
=MMc d
valueMMe j
)MMj k
;MMk l
publicNN 

voidNN 
IgnoreNN 
(NN 
)NN 
=>NN 
IgnoreNN "
(NN" #
ignorePathsNN# .
:NN. /
trueNN0 4
)NN4 5
;NN5 6
publicOO 

voidOO 
IgnoreOO 
(OO 
boolOO 
ignorePathsOO '
)OO' (
{PP 
IgnoredQQ 
=QQ 
trueQQ 
;QQ 
PropertyMapActionsRR 
.RR 
AddRR 
(RR 
pmRR !
=>RR" $
{SS 	
pmTT 
.TT 
IgnoredTT 
=TT 
trueTT 
;TT 
ifUU 
(UU 
ignorePathsUU 
&&UU 
pmUU !
.UU! "
TypeMapUU" )
.UU) *
PathMapsUU* 2
.UU2 3
CountUU3 8
>UU9 :
$numUU; <
)UU< =
{VV 
pmWW 
.WW 
TypeMapWW 
.WW 
IgnorePathsWW &
(WW& '
DestinationMemberWW' 8
)WW8 9
;WW9 :
}XX 
}YY 	
)YY	 

;YY
 
}ZZ 
public[[ 

void[[ 
	AllowNull[[ 
([[ 
)[[ 
=>[[ 
SetAllowNull[[ +
([[+ ,
true[[, 0
)[[0 1
;[[1 2
public\\ 

void\\ 
DoNotAllowNull\\ 
(\\ 
)\\  
=>\\! #
SetAllowNull\\$ 0
(\\0 1
false\\1 6
)\\6 7
;\\7 8
private]] 
void]] 
SetAllowNull]] 
(]] 
bool]] "
value]]# (
)]]( )
=>]]* ,
PropertyMapActions]]- ?
.]]? @
Add]]@ C
(]]C D
pm]]D F
=>]]G I
pm]]J L
.]]L M
	AllowNull]]M V
=]]W X
value]]Y ^
)]]^ _
;]]_ `
public^^ 

void^^ 
UseDestinationValue^^ #
(^^# $
)^^$ %
=>^^& ("
SetUseDestinationValue^^) ?
(^^? @
true^^@ D
)^^D E
;^^E F
private__ 
void__ "
SetUseDestinationValue__ '
(__' (
bool__( ,
value__- 2
)__2 3
=>__4 6
PropertyMapActions__7 I
.__I J
Add__J M
(__M N
pm__N P
=>__Q S
pm__T V
.__V W
UseDestinationValue__W j
=__k l
value__m r
)__r s
;__s t
public`` 

void`` 
SetMappingOrder`` 
(``  
int``  #
mappingOrder``$ 0
)``0 1
=>``2 4
PropertyMapActions``5 G
.``G H
Add``H K
(``K L
pm``L N
=>``O Q
pm``R T
.``T U
MappingOrder``U a
=``b c
mappingOrder``d p
)``p q
;``q r
publicaa 

voidaa 
ConvertUsingaa 
<aa 
TValueConverteraa ,
,aa, -
TSourceMemberaa. ;
>aa; <
(aa< =
)aa= >
whereaa? D
TValueConverteraaE T
:aaU V
IValueConverteraaW f
<aaf g
TSourceMemberaag t
,aat u
TMemberaav }
>aa} ~
=>	aa Å
ConvertUsingCorebb 
<bb 
TValueConverterbb (
,bb( )
TSourceMemberbb* 7
>bb7 8
(bb8 9
)bb9 :
;bb: ;
publiccc 

voidcc 
ConvertUsingcc 
<cc 
TValueConvertercc ,
,cc, -
TSourceMembercc. ;
>cc; <
(cc< =

Expressioncc= G
<ccG H
FuncccH L
<ccL M
TSourceccM T
,ccT U
TSourceMemberccV c
>ccc d
>ccd e
sourceMemberccf r
)ccr s
wherecct y
TValueConverter	ccz â
:
ccä ã
IValueConverter
ccå õ
<
ccõ ú
TSourceMember
ccú ©
,
cc© ™
TMember
cc´ ≤
>
cc≤ ≥
=>
cc¥ ∂
ConvertUsingCoredd 
<dd 
TValueConverterdd (
,dd( )
TSourceMemberdd* 7
>dd7 8
(dd8 9
sourceMemberdd9 E
)ddE F
;ddF G
publicee 

voidee 
ConvertUsingee 
<ee 
TValueConverteree ,
,ee, -
TSourceMemberee. ;
>ee; <
(ee< =
stringee= C
sourceMemberNameeeD T
)eeT U
whereeeV [
TValueConverteree\ k
:eel m
IValueConvertereen }
<ee} ~
TSourceMember	ee~ ã
,
eeã å
TMember
eeç î
>
eeî ï
=>
eeñ ò
ConvertUsingCoreff 
<ff 
TValueConverterff (
,ff( )
TSourceMemberff* 7
>ff7 8
(ff8 9
nullff9 =
,ff= >
sourceMemberNameff? O
)ffO P
;ffP Q
publicgg 

voidgg 
ConvertUsinggg 
<gg 
TSourceMembergg *
>gg* +
(gg+ ,
IValueConvertergg, ;
<gg; <
TSourceMembergg< I
,ggI J
TMemberggK R
>ggR S
valueConverterggT b
)ggb c
=>ggd f
ConvertUsingCoreggg w
(ggw x
valueConverter	ggx Ü
)
ggÜ á
;
ggá à
publichh 

voidhh 
ConvertUsinghh 
<hh 
TSourceMemberhh *
>hh* +
(hh+ ,
IValueConverterhh, ;
<hh; <
TSourceMemberhh< I
,hhI J
TMemberhhK R
>hhR S
valueConverterhhT b
,hhb c

Expressionhhd n
<hhn o
Funchho s
<hhs t
TSourcehht {
,hh{ |
TSourceMember	hh} ä
>
hhä ã
>
hhã å
sourceMember
hhç ô
)
hhô ö
=>
hhõ ù
ConvertUsingCoreii 
(ii 
valueConverterii '
,ii' (
sourceMemberii) 5
)ii5 6
;ii6 7
publicjj 

voidjj 
ConvertUsingjj 
<jj 
TSourceMemberjj *
>jj* +
(jj+ ,
IValueConverterjj, ;
<jj; <
TSourceMemberjj< I
,jjI J
TMemberjjK R
>jjR S
valueConverterjjT b
,jjb c
stringjjd j
sourceMemberNamejjk {
)jj{ |
=>	jj~ Ä
ConvertUsingCorekk 
(kk 
valueConverterkk '
,kk' (
nullkk) -
,kk- .
sourceMemberNamekk/ ?
)kk? @
;kk@ A
privatell 
voidll 
ConvertUsingCorell !
<ll! "
TValueConverterll" 1
,ll1 2
TSourceMemberll3 @
>ll@ A
(llA B

ExpressionllB L
<llL M
FuncllM Q
<llQ R
TSourcellR Y
,llY Z
TSourceMemberll[ h
>llh i
>lli j
sourceMemberllk w
=llx y
nullllz ~
,ll~ 
string
llÄ Ü
sourceMemberName
llá ó
=
llò ô
null
llö û
)
llû ü
=>
ll† ¢
ConvertUsingCoremm 
(mm 
newmm 
(mm 
typeofmm #
(mm# $
TValueConvertermm$ 3
)mm3 4
,mm4 5
typeofmm6 <
(mm< =
IValueConvertermm= L
<mmL M
TSourceMembermmM Z
,mmZ [
TMembermm\ c
>mmc d
)mmd e
,mme f
sourceMemberNamemmg w
)mmw x
{nn 	
SourceMemberLambdaoo 
=oo  
sourceMemberoo! -
,oo- .
}pp 	
)pp	 

;pp
 
	protectedqq 
voidqq 
ConvertUsingCoreqq #
(qq# $
ValueConverterqq$ 2
	converterqq3 <
)qq< =
=>qq> @
SetResolverqqA L
(qqL M
	converterqqM V
)qqV W
;qqW X
privaterr 
voidrr 
ConvertUsingCorerr !
<rr! "
TSourceMemberrr" /
>rr/ 0
(rr0 1
IValueConverterrr1 @
<rr@ A
TSourceMemberrrA N
,rrN O
TMemberrrP W
>rrW X
valueConverterrrY g
,rrg h

Expressionss 
<ss 
Funcss 
<ss 
TSourcess 
,ss  
TSourceMemberss! .
>ss. /
>ss/ 0
sourceMemberss1 =
=ss> ?
nullss@ D
,ssD E
stringssF L
sourceMemberNamessM ]
=ss^ _
nullss` d
)ssd e
=>ssf h
ConvertUsingCorett 
(tt 
newtt 
(tt 
valueConvertertt +
,tt+ ,
typeoftt- 3
(tt3 4
IValueConvertertt4 C
<ttC D
TSourceMemberttD Q
,ttQ R
TMemberttS Z
>ttZ [
)tt[ \
,tt\ ]
sourceMemberNamett^ n
)ttn o
{uu 	
SourceMemberLambdavv 
=vv  
sourceMembervv! -
,vv- .
}ww 	
)ww	 

;ww
 
publicxx 

voidxx 
	Configurexx 
(xx 
TypeMapxx !
typeMapxx" )
)xx) *
{yy 
varzz 

destMemberzz 
=zz 
DestinationMemberzz *
;zz* +
if{{ 

({{
 

destMember{{ 
.{{ 
DeclaringType{{ #
.{{# $%
ContainsGenericParameters{{$ =
){{= >
{|| 	

destMember}} 
=}} 
Array}} 
.}} 
Find}} #
(}}# $
typeMap}}$ +
.}}+ ,"
DestinationTypeDetails}}, B
.}}B C
ReadAccessors}}C P
,}}P Q
m}}R S
=>}}T V
m}}W X
.}}X Y
MetadataToken}}Y f
==}}g i

destMember}}j t
.}}t u
MetadataToken	}}u Ç
)
}}Ç É
;
}}É Ñ
}~~ 	
var 
propertyMap 
= 
typeMap !
.! "&
FindOrCreatePropertyMapFor" <
(< =

destMember= G
,G H
typeofI O
(O P
TMemberP W
)W X
==Y [
typeof\ b
(b c
objectc i
)i j
?k l

destMemberm w
.w x
GetMemberType	x Ö
(
Ö Ü
)
Ü á
:
à â
typeof
ä ê
(
ê ë
TMember
ë ò
)
ò ô
)
ô ö
;
ö õ
Apply
ÄÄ 
(
ÄÄ 
propertyMap
ÄÄ 
)
ÄÄ 
;
ÄÄ 
}
ÅÅ 
private
ÇÇ 
void
ÇÇ 
Apply
ÇÇ 
(
ÇÇ 
PropertyMap
ÇÇ "
propertyMap
ÇÇ# .
)
ÇÇ. /
{
ÉÉ 
foreach
ÑÑ 
(
ÑÑ 
var
ÑÑ 
action
ÑÑ 
in
ÑÑ  
PropertyMapActions
ÑÑ 0
)
ÑÑ0 1
{
ÖÖ 	
action
ÜÜ 
(
ÜÜ 
propertyMap
ÜÜ 
)
ÜÜ 
;
ÜÜ  
}
áá 	
}
àà 
public
ââ 

LambdaExpression
ââ 
SourceExpression
ââ ,
{
ââ- .
get
ââ/ 2
;
ââ2 3
private
ââ4 ;
set
ââ< ?
;
ââ? @
}
ââA B
public
ää 

bool
ää 
Ignored
ää 
{
ää 
get
ää 
;
ää 
private
ää &
set
ää' *
;
ää* +
}
ää, -
public
ãã 

LambdaExpression
ãã &
GetDestinationExpression
ãã 4
(
ãã4 5
)
ãã5 6
=>
ãã7 9
DestinationMember
ãã: K
.
ããK L
Lambda
ããL R
(
ããR S
)
ããS T
;
ããT U
public
åå 
'
IPropertyMapConfiguration
åå $
Reverse
åå% ,
(
åå, -
)
åå- .
{
çç 
var
éé 
destinationType
éé 
=
éé 
DestinationMember
éé /
.
éé/ 0
DeclaringType
éé0 =
;
éé= >
if
èè 

(
èè 
_sourceMembers
èè 
!=
èè 
null
èè "
)
èè" #
{
êê 	
if
ëë 
(
ëë 
_sourceMembers
ëë 
.
ëë 
Length
ëë %
>
ëë& '
$num
ëë( )
)
ëë) *
{
íí 
return
ìì 
null
ìì 
;
ìì 
}
îî +
MemberConfigurationExpression
ïï )
<
ïï) *
TDestination
ïï* 6
,
ïï6 7
TSource
ïï8 ?
,
ïï? @
object
ïïA G
>
ïïG H)
reversedMemberConfiguration
ïïI d
=
ïïe f
new
ïïg j
(
ïïj k
_sourceMembers
ïïk y
[
ïïy z
$num
ïïz {
]
ïï{ |
,
ïï| }
destinationTypeïï~ ç
)ïïç é
;ïïé è)
reversedMemberConfiguration
ññ '
.
ññ' (
MapFrom
ññ( /
(
ññ/ 0
DestinationMember
ññ0 A
.
ññA B
Name
ññB F
)
ññF G
;
ññG H
return
óó )
reversedMemberConfiguration
óó .
;
óó. /
}
òò 	
if
ôô 

(
ôô 
destinationType
ôô 
.
ôô %
IsGenericTypeDefinition
ôô 3
)
ôô3 4
{
öö 	
return
õõ 
null
õõ 
;
õõ 
}
úú 	
return
ùù )
PathConfigurationExpression
ùù *
<
ùù* +
TDestination
ùù+ 7
,
ùù7 8
TSource
ùù9 @
,
ùù@ A
object
ùùB H
>
ùùH I
.
ùùI J
Create
ùùJ P
(
ùùP Q
SourceExpression
ùùQ a
,
ùùa b&
GetDestinationExpression
ùùc {
(
ùù{ |
)
ùù| }
)
ùù} ~
;
ùù~ 
}
ûû 
public
üü 

void
üü &
DoNotUseDestinationValue
üü (
(
üü( )
)
üü) *
=>
üü+ -$
SetUseDestinationValue
üü. D
(
üüD E
false
üüE J
)
üüJ K
;
üüK L
}†† 
public°° 
sealed
°° 
class
°° +
MemberConfigurationExpression
°° 1
(
°°1 2

MemberInfo
°°2 <
destinationMember
°°= N
,
°°N O
Type
°°P T

sourceType
°°U _
)
°°_ `
:
°°a b,
MemberConfigurationExpression°°c Ä
<°°Ä Å
object°°Å á
,°°á à
object°°â è
,°°è ê
object°°ë ó
>°°ó ò
(°°ò ô!
destinationMember°°ô ™
,°°™ ´

sourceType°°¨ ∂
)°°∂ ∑
,°°∑ ∏.
IMemberConfigurationExpression°°π ◊
{¢¢ 
public
££ 

void
££ 
MapFrom
££ 
(
££ 
Type
££ 
valueResolverType
££ .
)
££. /
=>
££0 2
MapFromCore
££3 >
(
££> ?
new
££? B
(
££B C
valueResolverType
££C T
,
££T U
valueResolverType
££V g
.
££g h!
GetGenericInterface
££h {
(
££{ |
typeof££| Ç
(££Ç É
IValueResolver££É ë
<££ë í
,££í ì
,££ì î
>££î ï
)££ï ñ
)££ñ ó
)££ó ò
)££ò ô
;££ô ö
public
§§ 

void
§§ 
MapFrom
§§ 
(
§§ 
Type
§§ 
valueResolverType
§§ .
,
§§. /
string
§§0 6
sourceMemberName
§§7 G
)
§§G H
=>
§§I K
MapFromCore
•• 
(
•• 
new
•• 
(
•• 
valueResolverType
•• -
,
••- .
valueResolverType
••/ @
.
••@ A!
GetGenericInterface
••A T
(
••T U
typeof
••U [
(
••[ \"
IMemberValueResolver
••\ p
<
••p q
,
••q r
,
••r s
,
••s t
>
••t u
)
••u v
)
••v w
,
••w x
sourceMemberName••y â
)••â ä
)••ä ã
;••ã å
public
¶¶ 

void
¶¶ 
MapFrom
¶¶ 
<
¶¶ 
TSource
¶¶ 
,
¶¶  
TDestination
¶¶! -
,
¶¶- .
TSourceMember
¶¶/ <
,
¶¶< =
TDestMember
¶¶> I
>
¶¶I J
(
¶¶J K"
IMemberValueResolver
¶¶K _
<
¶¶_ `
TSource
¶¶` g
,
¶¶g h
TDestination
¶¶i u
,
¶¶u v
TSourceMember¶¶w Ñ
,¶¶Ñ Ö
TDestMember¶¶Ü ë
>¶¶ë í
resolver¶¶ì õ
,¶¶õ ú
string¶¶ù £ 
sourceMemberName¶¶§ ¥
)¶¶¥ µ
=>¶¶∂ ∏
MapFromCore
ßß 
(
ßß 
new
ßß 
(
ßß 
resolver
ßß  
,
ßß  !
typeof
ßß" (
(
ßß( )"
IMemberValueResolver
ßß) =
<
ßß= >
TSource
ßß> E
,
ßßE F
TDestination
ßßG S
,
ßßS T
TSourceMember
ßßU b
,
ßßb c
TDestMember
ßßd o
>
ßßo p
)
ßßp q
,
ßßq r
sourceMemberNameßßs É
)ßßÉ Ñ
)ßßÑ Ö
;ßßÖ Ü
public
®® 

void
®® 
ConvertUsing
®® 
(
®® 
Type
®® ! 
valueConverterType
®®" 4
)
®®4 5
=>
®®6 8
ConvertUsingCore
®®9 I
(
®®I J 
valueConverterType
®®J \
)
®®\ ]
;
®®] ^
public
©© 

void
©© 
ConvertUsing
©© 
(
©© 
Type
©© ! 
valueConverterType
©©" 4
,
©©4 5
string
©©6 <
sourceMemberName
©©= M
)
©©M N
=>
©©O Q
ConvertUsingCore
©©R b
(
©©b c 
valueConverterType
©©c u
,
©©u v
sourceMemberName©©w á
)©©á à
;©©à â
public
™™ 

void
™™ 
ConvertUsing
™™ 
<
™™ 
TSourceMember
™™ *
,
™™* + 
TDestinationMember
™™, >
>
™™> ?
(
™™? @
IValueConverter
™™@ O
<
™™O P
TSourceMember
™™P ]
,
™™] ^ 
TDestinationMember
™™_ q
>
™™q r
valueConverter™™s Å
,™™Å Ç
string™™É â 
sourceMemberName™™ä ö
)™™ö õ
=>™™ú û
base
´´ 
.
´´ 
ConvertUsingCore
´´ 
(
´´ 
new
´´ !
(
´´! "
valueConverter
´´" 0
,
´´0 1
typeof
´´2 8
(
´´8 9
IValueConverter
´´9 H
<
´´H I
TSourceMember
´´I V
,
´´V W 
TDestinationMember
´´X j
>
´´j k
)
´´k l
,
´´l m
sourceMemberName
´´n ~
)
´´~ 
)´´ Ä
;´´Ä Å
private
¨¨ 
void
¨¨ 
ConvertUsingCore
¨¨ !
(
¨¨! "
Type
¨¨" & 
valueConverterType
¨¨' 9
,
¨¨9 :
string
¨¨; A
sourceMemberName
¨¨B R
=
¨¨S T
null
¨¨U Y
)
¨¨Y Z
=>
¨¨[ ]
base
≠≠ 
.
≠≠ 
ConvertUsingCore
≠≠ 
(
≠≠ 
new
≠≠ !
(
≠≠! " 
valueConverterType
≠≠" 4
,
≠≠4 5 
valueConverterType
≠≠6 H
.
≠≠H I!
GetGenericInterface
≠≠I \
(
≠≠\ ]
typeof
≠≠] c
(
≠≠c d
IValueConverter
≠≠d s
<
≠≠s t
,
≠≠t u
>
≠≠u v
)
≠≠v w
)
≠≠w x
,
≠≠x y
sourceMemberName≠≠z ä
)≠≠ä ã
)≠≠ã å
;≠≠å ç
}ÆÆ ÷Ô
[C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\MappingExpression.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
public 
sealed 
class 
MappingExpression %
(% &

MemberList& 0

memberList1 ;
,; <
TypePair= E
typesF K
)K L
:M N!
MappingExpressionBaseO d
<d e
objecte k
,k l
objectm s
,s t
IMappingExpression	u á
>
á à
(
à â

memberList
â ì
,
ì î
types
ï ö
)
ö õ
,
õ ú 
IMappingExpression
ù Ø
{ 
public 

MappingExpression 
( 
TypeMap $
typeMap% ,
), -
:. /
this0 4
(4 5
typeMap5 <
.< = 
ConfiguredMemberList= Q
,Q R
typeMapS Z
.Z [
Types[ `
)` a
=>b d

Projectione o
=p q
typeMapr y
.y z

Projection	z Ñ
;
Ñ Ö
public 

string 
[ 
]  
IncludedMembersNames (
{) *
get+ .
;. /
internal0 8
set9 <
;< =
}> ?
=@ A
[B C
]C D
;D E
public 

IMappingExpression 

ReverseMap (
(( )
)) *
{ 
MappingExpression 

reverseMap $
=% &
new' *
(* +

MemberList+ 5
.5 6
None6 :
,: ;
Types< A
.A B
ReverseB I
(I J
)J K
)K L
{M N
IsReverseMapO [
=\ ]
true^ b
}c d
;d e
ReverseMapCore		 
(		 

reverseMap		 !
)		! "
;		" #

reverseMap

 
.

 
IncludeMembers

 !
(

! "
MapToSourceMembers

" 4
(

4 5
)

5 6
.

6 7
Select

7 =
(

= >
m

> ?
=>

@ B
m

C D
.

D E
DestinationMember

E V
.

V W
Name

W [
)

[ \
.

\ ]
ToArray

] d
(

d e
)

e f
)

f g
;

g h
foreach 
( 
var 
includedMemberName '
in( * 
IncludedMembersNames+ ?
)? @
{ 	

reverseMap 
. 
	ForMember  
(  !
includedMemberName! 3
,3 4
m5 6
=>7 9
m: ;
.; <
MapFrom< C
(C D
sD E
=>F H
sI J
)J K
)K L
;L M
} 	
return 

reverseMap 
; 
} 
public 

IMappingExpression 
IncludeMembers ,
(, -
params- 3
string4 :
[: ;
]; <
memberNames= H
)H I
{  
IncludedMembersNames 
= 
memberNames *
;* +
foreach 
( 
var 

memberName 
in !
memberNames" -
)- .
{ 	

SourceType 
. 
GetFieldOrProperty )
() *

memberName* 4
)4 5
;5 6
} 	
TypeMapActions 
. 
Add 
( 
tm 
=>  
tm! #
.# $ 
IncludedMembersNames$ 8
=9 :
memberNames; F
)F G
;G H
return 
this 
; 
} 
public 

void 
ForAllMembers 
( 
Action $
<$ %*
IMemberConfigurationExpression% C
>C D
memberOptionsE R
)R S
{ 
TypeMapActions 
. 
Add 
( 
typeMap "
=># %
{ 	
foreach 
( 
var 
accessor !
in" $
typeMap% ,
., -
DestinationSetters- ?
)? @
{   
	ForMember!! 
(!! 
accessor!! "
,!!" #
memberOptions!!$ 1
)!!1 2
;!!2 3
}"" 
}## 	
)##	 

;##
 
}$$ 
public%% 

IMappingExpression%% 
	ForMember%% '
(%%' (
string%%( .
name%%/ 3
,%%3 4
Action%%5 ;
<%%; <*
IMemberConfigurationExpression%%< Z
>%%Z [
memberOptions%%\ i
)%%i j
{&& 
var'' 
member'' 
='' 
DestinationType'' $
.''$ %
GetFieldOrProperty''% 7
(''7 8
name''8 <
)''< =
;''= >
	ForMember(( 
((( 
member(( 
,(( 
memberOptions(( '
)((' (
;((( )
return)) 
this)) 
;)) 
}** 
	protected++ 
override++ 
void++ #
IgnoreDestinationMember++ 3
(++3 4

MemberInfo++4 >
property++? G
,++G H
bool++I M
ignorePaths++N Y
=++Z [
true++\ `
)++` a
=>++b d
	ForMember++e n
(++n o
property++o w
,++w x
o++y z
=>++z |
o++| }
.++} ~
Ignore	++~ Ñ
(
++Ñ Ö
)
++Ö Ü
)
++Ü á
;
++á à
internal,, )
MemberConfigurationExpression,, *
	ForMember,,+ 4
(,,4 5

MemberInfo,,5 ?
destinationProperty,,@ S
,,,S T
Action,,U [
<,,[ \*
IMemberConfigurationExpression,,\ z
>,,z {
memberOptions	,,| â
)
,,â ä
{-- )
MemberConfigurationExpression.. %

expression..& 0
=..1 2
new..3 6
(..6 7
destinationProperty..7 J
,..J K

SourceType..L V
)..V W
;..W X 
MemberConfigurations// 
.// 
Add//  
(//  !

expression//! +
)//+ ,
;//, -
memberOptions00 
(00 

expression00  
)00  !
;00! "
return11 

expression11 
;11 
}22 
}33 
public44 
class44 
MappingExpression44 
<44 
TSource44 &
,44& '
TDestination44( 4
>444 5
:446 7!
MappingExpressionBase448 M
<44M N
TSource44N U
,44U V
TDestination44W c
,44c d
IMappingExpression44e w
<44w x
TSource44x 
,	44 Ä
TDestination
44Å ç
>
44ç é
>
44é è
,
44è ê
IMappingExpression55 
<55 
TSource55 
,55 
TDestination55  ,
>55, -
,55- .!
IProjectionExpression55/ D
<55D E
TSource55E L
,55L M
TDestination55N Z
>55Z [
{66 
public77 

MappingExpression77 
(77 

MemberList77 '

memberList77( 2
,772 3
bool774 8

projection779 C
)77C D
:77E F
base77G K
(77K L

memberList77L V
)77V W
=>77X Z

Projection77[ e
=77f g

projection77h r
;77r s
public88 

MappingExpression88 
(88 

MemberList88 '

memberList88( 2
,882 3
TypePair884 <
types88= B
)88B C
:88D E
base88F J
(88J K

memberList88K U
,88U V
types88W \
)88\ ]
{88^ _
}88` a
public99 

IMappingExpression99 
<99 
TSource99 %
,99% &
TDestination99' 3
>993 4
ForPath995 <
<99< =
TMember99= D
>99D E
(99E F

Expression99F P
<99P Q
Func99Q U
<99U V
TDestination99V b
,99b c
TMember99d k
>99k l
>99l m
destinationMember99n 
,	99 Ä
Action:: 
<:: (
IPathConfigurationExpression:: +
<::+ ,
TSource::, 3
,::3 4
TDestination::5 A
,::A B
TMember::C J
>::J K
>::K L
memberOptions::M Z
)::Z [
{;; 
if<< 

(<< 
!<< 
destinationMember<< 
.<< 
IsMemberPath<< +
(<<+ ,
out<<, /
var<<0 3
chain<<4 9
)<<9 :
)<<: ;
{== 	
throw>> 
new>> '
ArgumentOutOfRangeException>> 1
(>>1 2
nameof>>2 8
(>>8 9
destinationMember>>9 J
)>>J K
,>>K L
$str>>M q
+>>r s
destinationMember	>>t Ö
)
>>Ö Ü
;
>>Ü á
}?? 	'
PathConfigurationExpression@@ #
<@@# $
TSource@@$ +
,@@+ ,
TDestination@@- 9
,@@9 :
TMember@@; B
>@@B C

expression@@D N
=@@O P
new@@Q T
(@@T U
destinationMember@@U f
,@@f g
chain@@h m
)@@m n
;@@n o
varAA 
firstMemberAA 
=AA 

expressionAA $
.AA$ %

MemberPathAA% /
.AA/ 0
FirstAA0 5
;AA5 6
varBB 
firstMemberConfigBB 
=BB -
!GetDestinationMemberConfigurationBB  A
(BBA B
firstMemberBBB M
)BBM N
;BBN O
ifCC 

(CC
 
firstMemberConfigCC 
==CC 
nullCC  $
)CC$ %
{DD 	#
IgnoreDestinationMemberEE #
(EE# $
firstMemberEE$ /
,EE/ 0
ignorePathsEE1 <
:EE< =
falseEE> C
)EEC D
;EED E
}FF 	 
MemberConfigurationsGG 
.GG 
AddGG  
(GG  !

expressionGG! +
)GG+ ,
;GG, -
memberOptionsHH 
(HH 

expressionHH  
)HH  !
;HH! "
returnII 
thisII 
;II 
}JJ 
publicKK 

IMappingExpressionKK 
<KK 
TSourceKK %
,KK% &
TDestinationKK' 3
>KK3 4
	ForMemberKK5 >
<KK> ?
TMemberKK? F
>KKF G
(KKG H

ExpressionKKH R
<KKR S
FuncKKS W
<KKW X
TDestinationKKX d
,KKd e
TMemberKKf m
>KKm n
>KKn o
destinationMember	KKp Å
,
KKÅ Ç
Action
KKÉ â
<
KKâ ä,
IMemberConfigurationExpression
KKä ®
<
KK® ©
TSource
KK© ∞
,
KK∞ ±
TDestination
KK≤ æ
,
KKæ ø
TMember
KK¿ «
>
KK« »
>
KK» …
memberOptions
KK  ◊
)
KK◊ ÿ
{LL 
varMM 

memberInfoMM 
=MM 
ReflectionHelperMM )
.MM) *
FindPropertyMM* 6
(MM6 7
destinationMemberMM7 H
)MMH I
;MMI J
returnNN  
ForDestinationMemberNN #
(NN# $

memberInfoNN$ .
,NN. /
memberOptionsNN0 =
)NN= >
;NN> ?
}OO 
privatePP 
voidPP 
IncludeMembersCorePP #
(PP# $
LambdaExpressionPP$ 4
[PP4 5
]PP5 6
memberExpressionsPP7 H
)PPH I
=>PPJ L
TypeMapActionsPPM [
.PP[ \
AddPP\ _
(PP_ `
tmPP` b
=>PPc e
tmPPf h
.PPh i
IncludedMembersPPi x
=PPy z
memberExpressions	PP{ å
)
PPå ç
;
PPç é
publicQQ 

IMappingExpressionQQ 
<QQ 
TSourceQQ %
,QQ% &
TDestinationQQ' 3
>QQ3 4
IncludeMembersQQ5 C
(QQC D
paramsQQD J

ExpressionQQK U
<QQU V
FuncQQV Z
<QQZ [
TSourceQQ[ b
,QQb c
objectQQd j
>QQj k
>QQk l
[QQl m
]QQm n
memberExpressions	QQo Ä
)
QQÄ Å
{RR 
varSS 0
$memberExpressionsWithoutCastToObjectSS 0
=SS1 2
ArraySS3 8
.SS8 9

ConvertAllSS9 C
(SSC D
memberExpressionsTT 
,TT 
eUU 
=>UU 
{VV 
varWW 
bodyIsCastToObjectWW &
=WW' (
eWW) *
.WW* +
BodyWW+ /
.WW/ 0
NodeTypeWW0 8
==WW9 ;
ExpressionTypeWW< J
.WWJ K
ConvertWWK R
&&WWS U
eWWV W
.WWW X
BodyWWX \
.WW\ ]
TypeWW] a
==WWb d
typeofWWe k
(WWk l
objectWWl r
)WWr s
;WWs t
returnXX 
bodyIsCastToObjectXX )
?XX* +
LambdaXX, 2
(XX2 3
(XX3 4
(XX4 5
UnaryExpressionXX5 D
)XXD E
eXXE F
.XXF G
BodyXXG K
)XXK L
.XXL M
OperandXXM T
,XXT U
eXXV W
.XXW X

ParametersXXX b
)XXb c
:XXd e
eXXf g
;XXg h
}YY 
)YY 
;YY 
IncludeMembersCoreZZ 
(ZZ 0
$memberExpressionsWithoutCastToObjectZZ ?
)ZZ? @
;ZZ@ A
return[[ 
this[[ 
;[[ 
}\\ 
public]] 

IMappingExpression]] 
<]] 
TSource]] %
,]]% &
TDestination]]' 3
>]]3 4
	ForMember]]5 >
(]]> ?
string]]? E
name]]F J
,]]J K
Action]]L R
<]]R S*
IMemberConfigurationExpression]]S q
<]]q r
TSource]]r y
,]]y z
TDestination	]]{ á
,
]]á à
object
]]â è
>
]]è ê
>
]]ê ë
memberOptions
]]í ü
)
]]ü †
{^^ 
var__ 
member__ 
=__ 
DestinationType__ $
.__$ %
GetFieldOrProperty__% 7
(__7 8
name__8 <
)__< =
;__= >
return``  
ForDestinationMember`` #
(``# $
member``$ *
,``* +
memberOptions``, 9
)``9 :
;``: ;
}aa 
publicbb 

voidbb 
ForAllMembersbb 
(bb 
Actionbb $
<bb$ %*
IMemberConfigurationExpressionbb% C
<bbC D
TSourcebbD K
,bbK L
TDestinationbbM Y
,bbY Z
objectbb[ a
>bba b
>bbb c
memberOptionsbbd q
)bbq r
{cc 
TypeMapActionsdd 
.dd 
Adddd 
(dd 
typeMapdd "
=>dd# %
{ee 	
foreachff 
(ff 
varff 
accessorff !
inff" $
typeMapff% ,
.ff, -
DestinationSettersff- ?
)ff? @
{gg  
ForDestinationMemberhh $
(hh$ %
accessorhh% -
,hh- .
memberOptionshh/ <
)hh< =
;hh= >
}ii 
}jj 	
)jj	 

;jj
 
}kk 
publicll 

IMappingExpressionll 
<ll 
TSourcell %
,ll% &
TDestinationll' 3
>ll3 4
Includell5 <
<ll< =
TOtherSourcell= I
,llI J
TOtherDestinationllK \
>ll\ ]
(ll] ^
)ll^ _
wherell` e
TOtherSourcellf r
:lls t
TSourcellu |
where	ll} Ç
TOtherDestination
llÉ î
:
llï ñ
TDestination
lló £
{mm 
IncludeCorenn 
(nn 
typeofnn 
(nn 
TOtherSourcenn '
)nn' (
,nn( )
typeofnn* 0
(nn0 1
TOtherDestinationnn1 B
)nnB C
)nnC D
;nnD E
returnoo 
thisoo 
;oo 
}pp 
publicqq 

IMappingExpressionqq 
<qq 
TSourceqq %
,qq% &
TDestinationqq' 3
>qq3 4
IncludeBaseqq5 @
<qq@ A
TSourceBaseqqA L
,qqL M
TDestinationBaseqqN ^
>qq^ _
(qq_ `
)qq` a
=>qqb d
IncludeBaseqqe p
(qqp q
typeofqqq w
(qqw x
TSourceBase	qqx É
)
qqÉ Ñ
,
qqÑ Ö
typeof
qqÜ å
(
qqå ç
TDestinationBase
qqç ù
)
qqù û
)
qqû ü
;
qqü †
publicrr 

IMappingExpressionrr 
<rr 
TSourcerr %
,rr% &
TDestinationrr' 3
>rr3 4
ForSourceMemberrr5 D
(rrD E

ExpressionrrE O
<rrO P
FuncrrP T
<rrT U
TSourcerrU \
,rr\ ]
objectrr^ d
>rrd e
>rre f
sourceMemberrrg s
,rrs t
Actionrru {
<rr{ |1
$ISourceMemberConfigurationExpression	rr| †
>
rr† °
memberOptions
rr¢ Ø
)
rrØ ∞
{ss 
vartt 

memberInfott 
=tt 
ReflectionHelpertt )
.tt) *
FindPropertytt* 6
(tt6 7
sourceMembertt7 C
)ttC D
;ttD E#
SourceMappingExpressionuu 
	srcConfiguu  )
=uu* +
newuu, /
(uu/ 0

memberInfouu0 :
)uu: ;
;uu; <
memberOptionsvv 
(vv 
	srcConfigvv 
)vv  
;vv  !&
SourceMemberConfigurationsww "
.ww" #
Addww# &
(ww& '
	srcConfigww' 0
)ww0 1
;ww1 2
returnxx 
thisxx 
;xx 
}yy 
publiczz 

voidzz 
Aszz 
<zz 
Tzz 
>zz 
(zz 
)zz 
wherezz 
Tzz 
:zz  !
TDestinationzz" .
=>zz/ 1
Aszz2 4
(zz4 5
typeofzz5 ;
(zz; <
Tzz< =
)zz= >
)zz> ?
;zz? @
public{{ 

IMappingExpression{{ 
<{{ 
TSource{{ %
,{{% &
TDestination{{' 3
>{{3 4
AddTransform{{5 A
<{{A B
TValue{{B H
>{{H I
({{I J

Expression{{J T
<{{T U
Func{{U Y
<{{Y Z
TValue{{Z `
,{{` a
TValue{{b h
>{{h i
>{{i j
transformer{{k v
){{v w
{|| )
ValueTransformerConfiguration}} %
config}}& ,
=}}- .
new}}/ 2
(}}2 3
typeof}}3 9
(}}9 :
TValue}}: @
)}}@ A
,}}A B
transformer}}C N
)}}N O
;}}O P
ValueTransformers~~ 
.~~ 
Add~~ 
(~~ 
config~~ $
)~~$ %
;~~% &
return 
this 
; 
}
ÄÄ 
public
ÅÅ 
 
IMappingExpression
ÅÅ 
<
ÅÅ 
TDestination
ÅÅ *
,
ÅÅ* +
TSource
ÅÅ, 3
>
ÅÅ3 4

ReverseMap
ÅÅ5 ?
(
ÅÅ? @
)
ÅÅ@ A
{
ÇÇ 
MappingExpression
ÉÉ 
<
ÉÉ 
TDestination
ÉÉ &
,
ÉÉ& '
TSource
ÉÉ( /
>
ÉÉ/ 0

reverseMap
ÉÉ1 ;
=
ÉÉ< =
new
ÉÉ> A
(
ÉÉA B

MemberList
ÉÉB L
.
ÉÉL M
None
ÉÉM Q
,
ÉÉQ R
Types
ÉÉS X
.
ÉÉX Y
Reverse
ÉÉY `
(
ÉÉ` a
)
ÉÉa b
)
ÉÉb c
{
ÉÉc d
IsReverseMap
ÉÉe q
=
ÉÉr s
true
ÉÉt x
}
ÉÉy z
;
ÉÉz {
ReverseMapCore
ÑÑ 
(
ÑÑ 

reverseMap
ÑÑ !
)
ÑÑ! "
;
ÑÑ" #

reverseMap
ÖÖ 
.
ÖÖ  
IncludeMembersCore
ÖÖ %
(
ÖÖ% & 
MapToSourceMembers
ÖÖ& 8
(
ÖÖ8 9
)
ÖÖ9 :
.
ÖÖ: ;
Select
ÖÖ; A
(
ÖÖA B
m
ÖÖB C
=>
ÖÖD F
m
ÖÖG H
.
ÖÖH I&
GetDestinationExpression
ÖÖI a
(
ÖÖa b
)
ÖÖb c
)
ÖÖc d
.
ÖÖd e
ToArray
ÖÖe l
(
ÖÖl m
)
ÖÖm n
)
ÖÖn o
;
ÖÖo p
return
ÜÜ 

reverseMap
ÜÜ 
;
ÜÜ 
}
áá 
private
àà  
IMappingExpression
àà 
<
àà 
TSource
àà &
,
àà& '
TDestination
àà( 4
>
àà4 5"
ForDestinationMember
àà6 J
<
ààJ K
TMember
ààK R
>
ààR S
(
ààS T

MemberInfo
ààT ^!
destinationProperty
àà_ r
,
ààr s
Action
ààt z
<
ààz {,
MemberConfigurationExpressionàà{ ò
<ààò ô
TSourceààô †
,àà† °
TDestinationàà¢ Æ
,ààÆ Ø
TMemberàà∞ ∑
>àà∑ ∏
>àà∏ π
memberOptionsàà∫ «
)àà« »
{
ââ +
MemberConfigurationExpression
ää %
<
ää% &
TSource
ää& -
,
ää- .
TDestination
ää/ ;
,
ää; <
TMember
ää= D
>
ääD E

expression
ääF P
=
ääQ R
new
ääS V
(
ääV W!
destinationProperty
ääW j
,
ääj k

SourceType
ääl v
)
ääv w
;
ääw x"
MemberConfigurations
ãã 
.
ãã 
Add
ãã  
(
ãã  !

expression
ãã! +
)
ãã+ ,
;
ãã, -
memberOptions
åå 
(
åå 

expression
åå  
)
åå  !
;
åå! "
return
çç 
this
çç 
;
çç 
}
éé 
	protected
èè 
override
èè 
void
èè %
IgnoreDestinationMember
èè 3
(
èè3 4

MemberInfo
èè4 >
property
èè? G
,
èèG H
bool
èèI M
ignorePaths
èèN Y
=
èèZ [
true
èè\ `
)
èè` a
=>
èèb d"
ForDestinationMember
êê 
<
êê 
object
êê #
>
êê# $
(
êê$ %
property
êê% -
,
êê- .
options
êê/ 6
=>
êê7 9
options
êê: A
.
êêA B
Ignore
êêB H
(
êêH I
ignorePaths
êêI T
)
êêT U
)
êêU V
;
êêV W#
IProjectionExpression
ëë 
<
ëë 
TSource
ëë !
,
ëë! "
TDestination
ëë# /
>
ëë/ 0#
IProjectionExpression
ëë1 F
<
ëëF G
TSource
ëëG N
,
ëëN O
TDestination
ëëP \
>
ëë\ ]
.
ëë] ^
	ForMember
ëë^ g
<
ëëg h
TMember
ëëh o
>
ëëo p
(
ëëp q

Expression
ëëq {
<
ëë{ |
Funcëë| Ä
<ëëÄ Å
TDestinationëëÅ ç
,ëëç é
TMemberëëè ñ
>ëëñ ó
>ëëó ò!
destinationMemberëëô ™
,ëë™ ´
Action
íí 
<
íí ,
IProjectionMemberConfiguration
íí -
<
íí- .
TSource
íí. 5
,
íí5 6
TDestination
íí7 C
,
ííC D
TMember
ííE L
>
ííL M
>
ííM N
memberOptions
ííO \
)
íí\ ]
=>
íí^ `
(
ìì 	#
IProjectionExpression
ìì	 
<
ìì 
TSource
ìì &
,
ìì& '
TDestination
ìì( 4
>
ìì4 5
)
ìì5 6
	ForMember
ìì6 ?
(
ìì? @
destinationMember
ìì@ Q
,
ììQ R
memberOptions
ììS `
)
ìì` a
;
ììa b#
IProjectionExpression
îî 
<
îî 
TSource
îî !
,
îî! "
TDestination
îî# /
>
îî/ 0#
IProjectionExpression
îî1 F
<
îîF G
TSource
îîG N
,
îîN O
TDestination
îîP \
,
îî\ ]#
IProjectionExpression
îî^ s
<
îîs t
TSource
îît {
,
îî{ |
TDestinationîî} â
>îîâ ä
>îîä ã
.îîã å
AddTransformîîå ò
<îîò ô
TValueîîô ü
>îîü †
(îî† °

Expression
ïï 
<
ïï 
Func
ïï 
<
ïï 
TValue
ïï 
,
ïï 
TValue
ïï  &
>
ïï& '
>
ïï' (
transformer
ïï) 4
)
ïï4 5
=>
ïï6 8
(
ïï9 :#
IProjectionExpression
ïï: O
<
ïïO P
TSource
ïïP W
,
ïïW X
TDestination
ïïY e
>
ïïe f
)
ïïf g
AddTransform
ïïg s
(
ïïs t
transformer
ïït 
)ïï Ä
;ïïÄ Å#
IProjectionExpression
ññ 
<
ññ 
TSource
ññ !
,
ññ! "
TDestination
ññ# /
>
ññ/ 0#
IProjectionExpression
ññ1 F
<
ññF G
TSource
ññG N
,
ññN O
TDestination
ññP \
,
ññ\ ]#
IProjectionExpression
ññ^ s
<
ññs t
TSource
ññt {
,
ññ{ |
TDestinationññ} â
>ññâ ä
>ññä ã
.ññã å
IncludeMembersññå ö
(ññö õ
params
óó 

Expression
óó 
<
óó 
Func
óó 
<
óó 
TSource
óó &
,
óó& '
object
óó( .
>
óó. /
>
óó/ 0
[
óó0 1
]
óó1 2
memberExpressions
óó3 D
)
óóD E
=>
óóF H
(
óóI J#
IProjectionExpression
óóJ _
<
óó_ `
TSource
óó` g
,
óóg h
TDestination
óói u
>
óóu v
)
óóv w
IncludeMembersóów Ö
(óóÖ Ü!
memberExpressionsóóÜ ó
)óóó ò
;óóò ô#
IProjectionExpression
òò 
<
òò 
TSource
òò !
,
òò! "
TDestination
òò# /
>
òò/ 0'
IProjectionExpressionBase
òò1 J
<
òòJ K
TSource
òòK R
,
òòR S
TDestination
òòT `
,
òò` a#
IProjectionExpression
òòb w
<
òòw x
TSource
òòx 
,òò Ä
TDestinationòòÅ ç
>òòç é
>òòé è
.òòè ê
MaxDepthòòê ò
(òòò ô
intòòô ú
depthòòù ¢
)òò¢ £
=>òò§ ¶
(
ôô 	#
IProjectionExpression
ôô	 
<
ôô 
TSource
ôô &
,
ôô& '
TDestination
ôô( 4
>
ôô4 5
)
ôô5 6
MaxDepth
ôô6 >
(
ôô> ?
depth
ôô? D
)
ôôD E
;
ôôE F#
IProjectionExpression
öö 
<
öö 
TSource
öö !
,
öö! "
TDestination
öö# /
>
öö/ 0'
IProjectionExpressionBase
öö1 J
<
ööJ K
TSource
ööK R
,
ööR S
TDestination
ööT `
,
öö` a#
IProjectionExpression
ööb w
<
ööw x
TSource
ööx 
,öö Ä
TDestinationööÅ ç
>ööç é
>ööé è
.ööè ê"
ValidateMemberListööê ¢
(öö¢ £

MemberList
õõ 

memberList
õõ 
)
õõ 
=>
õõ !
(
õõ" ##
IProjectionExpression
õõ# 8
<
õõ8 9
TSource
õõ9 @
,
õõ@ A
TDestination
õõB N
>
õõN O
)
õõO P 
ValidateMemberList
õõP b
(
õõb c

memberList
õõc m
)
õõm n
;
õõn o#
IProjectionExpression
úú 
<
úú 
TSource
úú !
,
úú! "
TDestination
úú# /
>
úú/ 0'
IProjectionExpressionBase
úú1 J
<
úúJ K
TSource
úúK R
,
úúR S
TDestination
úúT `
,
úú` a#
IProjectionExpression
úúb w
<
úúw x
TSource
úúx 
,úú Ä
TDestinationúúÅ ç
>úúç é
>úúé è
.úúè ê
ConstructUsingúúê û
(úúû ü

Expression
ùù 
<
ùù 
Func
ùù 
<
ùù 
TSource
ùù 
,
ùù  
TDestination
ùù! -
>
ùù- .
>
ùù. /
ctor
ùù0 4
)
ùù4 5
=>
ùù6 8
(
ùù9 :#
IProjectionExpression
ùù: O
<
ùùO P
TSource
ùùP W
,
ùùW X
TDestination
ùùY e
>
ùùe f
)
ùùf g
ConstructUsing
ùùg u
(
ùùu v
ctor
ùùv z
)
ùùz {
;
ùù{ |#
IProjectionExpression
ûû 
<
ûû 
TSource
ûû !
,
ûû! "
TDestination
ûû# /
>
ûû/ 0'
IProjectionExpressionBase
ûû1 J
<
ûûJ K
TSource
ûûK R
,
ûûR S
TDestination
ûûT `
,
ûû` a#
IProjectionExpression
ûûb w
<
ûûw x
TSource
ûûx 
,ûû Ä
TDestinationûûÅ ç
>ûûç é
>ûûé è
.ûûè ê
ForCtorParamûûê ú
(ûûú ù
string
üü 
ctorParamName
üü 
,
üü 
Action
üü $
<
üü$ %/
!ICtorParamConfigurationExpression
üü% F
<
üüF G
TSource
üüG N
>
üüN O
>
üüO P
paramOptions
üüQ ]
)
üü] ^
=>
üü_ a
(
†† 	#
IProjectionExpression
††	 
<
†† 
TSource
†† &
,
††& '
TDestination
††( 4
>
††4 5
)
††5 6
ForCtorParam
††6 B
(
††B C
ctorParamName
††C P
,
††P Q
paramOptions
††R ^
)
††^ _
;
††_ `
}°° ê|
gC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\MapperConfigurationExpression.cs
	namespace 	

AutoMapper
 
; 
public 
	interface *
IMapperConfigurationExpression /
:0 1
IProfileExpression2 D
{ 
void 

AddProfile	 
( 
Profile 
profile #
)# $
;$ %
void 

AddProfile	 
< 
TProfile 
> 
( 
) 
where  %
TProfile& .
:/ 0
Profile1 8
,8 9
new: =
(= >
)> ?
;? @
void 

AddProfile	 
( 
Type 
profileType $
)$ %
;% &
void 
AddProfiles	 
( 
IEnumerable  
<  !
Profile! (
>( ) 
enumerableOfProfiles* >
)> ?
;? @
void&& 
AddMaps&&	 
(&& 
IEnumerable&& 
<&& 
Assembly&& %
>&&% &
assembliesToScan&&' 7
)&&7 8
;&&8 9
void-- 
AddMaps--	 
(-- 
params-- 
Assembly--  
[--  !
]--! "
assembliesToScan--# 3
)--3 4
;--4 5
void44 
AddMaps44	 
(44 
IEnumerable44 
<44 
string44 #
>44# $
assemblyNamesToScan44% 8
)448 9
;449 :
void;; 
AddMaps;;	 
(;; 
params;; 
string;; 
[;; 
];;  
assemblyNamesToScan;;! 4
);;4 5
;;;5 6
voidBB 
AddMapsBB	 
(BB 
IEnumerableBB 
<BB 
TypeBB !
>BB! ";
/typesFromAssembliesContainingMappingDefinitionsBB# R
)BBR S
;BBS T
voidII 
AddMapsII	 
(II 
paramsII 
TypeII 
[II 
]II ;
/typesFromAssembliesContainingMappingDefinitionsII N
)IIN O
;IIO P
voidOO "
ConstructServicesUsingOO	 
(OO  
FuncOO  $
<OO$ %
TypeOO% )
,OO) *
objectOO+ 1
>OO1 2
constructorOO3 >
)OO> ?
;OO? @
voidVV 
CreateProfileVV	 
(VV 
stringVV 
profileNameVV )
,VV) *
ActionVV+ 1
<VV1 2
IProfileExpressionVV2 D
>VVD E
configVVF L
)VVL M
;VVM N
}WW 
publicXX 
sealedXX 
classXX )
MapperConfigurationExpressionXX 1
:XX2 3
ProfileXX4 ;
,XX; <*
IGlobalConfigurationExpressionXX= [
{YY 
privateZZ 
readonlyZZ 
ListZZ 
<ZZ 
ProfileZZ !
>ZZ! "
	_profilesZZ# ,
=ZZ- .
[ZZ/ 0
]ZZ0 1
;ZZ1 2
private[[ 
readonly[[ 
List[[ 
<[[ 
	Validator[[ #
>[[# $
_validators[[% 0
=[[1 2
[[[3 4
][[4 5
;[[5 6
private\\ 
Func\\ 
<\\ 
Type\\ 
,\\ 
object\\ 
>\\ 
_serviceCtor\\ +
=\\, -
	Activator\\. 7
.\\7 8
CreateInstance\\8 F
;\\F G
private]] 
List]] 
<]] 
IProjectionMapper]] "
>]]" #
_projectionMappers]]$ 6
;]]6 7
voidbb *
IGlobalConfigurationExpressionbb	 '
.bb' (
	Validatorbb( 1
(bb1 2
	Validatorbb2 ;
	validatorbb< E
)bbE F
=>bbG I
_validatorscc 
.cc 
Addcc 
(cc 
	validatorcc !
??cc" $
throwcc% *
newcc+ .!
ArgumentNullExceptioncc/ D
(ccD E
nameofccE K
(ccK L
	validatorccL U
)ccU V
)ccV W
)ccW X
;ccX Y
inthh *
IGlobalConfigurationExpressionhh &
.hh& '!
MaxExecutionPlanDepthhh' <
{hh= >
gethh? B
;hhB C
sethhD G
;hhG H
}hhI J
=hhK L
$numhhM N
;hhN O
Listjj 
<jj 	
	Validatorjj	 
>jj *
IGlobalConfigurationExpressionjj 2
.jj2 3

Validatorsjj3 =
=>jj> @
_validatorsjjA L
;jjL M
Listll 
<ll 	
IProjectionMapperll	 
>ll *
IGlobalConfigurationExpressionll :
.ll: ;
ProjectionMappersll; L
=>llM O
_projectionMappersllP b
??=llc f
ProjectionBuilderllg x
.llx y%
DefaultProjectionMappers	lly ë
(
llë í
)
llí ì
;
llì î
intrr *
IGlobalConfigurationExpressionrr &
.rr& '$
RecursiveQueriesMaxDepthrr' ?
{rr@ A
getrrB E
;rrE F
setrrG J
;rrJ K
}rrL M
IReadOnlyCollectiontt 
<tt !
IProfileConfigurationtt -
>tt- .*
IGlobalConfigurationExpressiontt/ M
.ttM N
ProfilesttN V
=>ttW Y
	_profilesttZ c
;ttc d
Funcuu 
<uu 	
Typeuu	 
,uu 
objectuu 
>uu *
IGlobalConfigurationExpressionuu 5
.uu5 6
ServiceCtoruu6 A
=>uuB D
_serviceCtoruuE Q
;uuQ R
publicww 

voidww 
CreateProfileww 
(ww 
stringww $
profileNameww% 0
,ww0 1
Actionww2 8
<ww8 9
IProfileExpressionww9 K
>wwK L
configwwM S
)wwS T
=>xx 


AddProfilexx 
(xx 
newxx 
Profilexx !
(xx! "
profileNamexx" -
,xx- .
configxx/ 5
)xx5 6
)xx6 7
;xx7 8
Listzz 
<zz 	
IObjectMapperzz	 
>zz *
IGlobalConfigurationExpressionzz 6
.zz6 7
Mapperszz7 >
{zz? @
getzzA D
;zzD E
}zzF G
=zzH I
MapperRegistryzzJ X
.zzX Y
MapperszzY `
(zz` a
)zza b
;zzb c
Features|| 
<|| 
IGlobalFeature|| 
>|| *
IGlobalConfigurationExpression|| ;
.||; <
Features||< D
{||E F
get||G J
;||J K
}||L M
=||N O
new||P S
(||S T
)||T U
;||U V
public~~ 

void~~ 

AddProfile~~ 
(~~ 
Profile~~ "
profile~~# *
)~~* +
=>~~, .
	_profiles~~/ 8
.~~8 9
Add~~9 <
(~~< =
profile~~= D
)~~D E
;~~E F
public
ÄÄ 

void
ÄÄ 

AddProfile
ÄÄ 
<
ÄÄ 
TProfile
ÄÄ #
>
ÄÄ# $
(
ÄÄ$ %
)
ÄÄ% &
where
ÄÄ' ,
TProfile
ÄÄ- 5
:
ÄÄ6 7
Profile
ÄÄ8 ?
,
ÄÄ? @
new
ÄÄA D
(
ÄÄD E
)
ÄÄE F
=>
ÄÄG I

AddProfile
ÄÄJ T
(
ÄÄT U
new
ÄÄU X
TProfile
ÄÄY a
(
ÄÄa b
)
ÄÄb c
)
ÄÄc d
;
ÄÄd e
public
ÇÇ 

void
ÇÇ 

AddProfile
ÇÇ 
(
ÇÇ 
Type
ÇÇ 
profileType
ÇÇ  +
)
ÇÇ+ ,
=>
ÇÇ- /

AddProfile
ÇÇ0 :
(
ÇÇ: ;
(
ÇÇ; <
Profile
ÇÇ< C
)
ÇÇC D
	Activator
ÇÇD M
.
ÇÇM N
CreateInstance
ÇÇN \
(
ÇÇ\ ]
profileType
ÇÇ] h
)
ÇÇh i
)
ÇÇi j
;
ÇÇj k
public
ÑÑ 

void
ÑÑ 
AddProfiles
ÑÑ 
(
ÑÑ 
IEnumerable
ÑÑ '
<
ÑÑ' (
Profile
ÑÑ( /
>
ÑÑ/ 0"
enumerableOfProfiles
ÑÑ1 E
)
ÑÑE F
{
ÖÖ 
foreach
ÜÜ 
(
ÜÜ 
var
ÜÜ 
profile
ÜÜ 
in
ÜÜ "
enumerableOfProfiles
ÜÜ  4
)
ÜÜ4 5
{
áá 	

AddProfile
àà 
(
àà 
profile
àà 
)
àà 
;
àà  
}
ââ 	
}
ää 
public
åå 

void
åå 
AddMaps
åå 
(
åå 
IEnumerable
åå #
<
åå# $
Assembly
åå$ ,
>
åå, -
assembliesToScan
åå. >
)
åå> ?
=>
çç 

AddMapsCore
çç 
(
çç 
assembliesToScan
çç '
)
çç' (
;
çç( )
public
èè 

void
èè 
AddMaps
èè 
(
èè 
params
èè 
Assembly
èè '
[
èè' (
]
èè( )
assembliesToScan
èè* :
)
èè: ;
=>
êê 

AddMapsCore
êê 
(
êê 
assembliesToScan
êê '
)
êê' (
;
êê( )
public
íí 

void
íí 
AddMaps
íí 
(
íí 
IEnumerable
íí #
<
íí# $
string
íí$ *
>
íí* +!
assemblyNamesToScan
íí, ?
)
íí? @
=>
ìì 

AddMapsCore
ìì 
(
ìì !
assemblyNamesToScan
ìì *
.
ìì* +
Select
ìì+ 1
(
ìì1 2
Assembly
ìì2 :
.
ìì: ;
Load
ìì; ?
)
ìì? @
)
ìì@ A
;
ììA B
public
ïï 

void
ïï 
AddMaps
ïï 
(
ïï 
params
ïï 
string
ïï %
[
ïï% &
]
ïï& '!
assemblyNamesToScan
ïï( ;
)
ïï; <
=>
ññ 

AddMaps
ññ 
(
ññ 
(
ññ 
IEnumerable
ññ 
<
ññ  
string
ññ  &
>
ññ& '
)
ññ' (!
assemblyNamesToScan
ññ( ;
)
ññ; <
;
ññ< =
public
òò 

void
òò 
AddMaps
òò 
(
òò 
IEnumerable
òò #
<
òò# $
Type
òò$ (
>
òò( )=
/typesFromAssembliesContainingMappingDefinitions
òò* Y
)
òòY Z
=>
ôô 

AddMapsCore
ôô 
(
ôô =
/typesFromAssembliesContainingMappingDefinitions
ôô F
.
ôôF G
Select
ôôG M
(
ôôM N
t
ôôN O
=>
ôôP R
t
ôôS T
.
ôôT U
GetTypeInfo
ôôU `
(
ôô` a
)
ôôa b
.
ôôb c
Assembly
ôôc k
)
ôôk l
)
ôôl m
;
ôôm n
public
õõ 

void
õõ 
AddMaps
õõ 
(
õõ 
params
õõ 
Type
õõ #
[
õõ# $
]
õõ$ %=
/typesFromAssembliesContainingMappingDefinitions
õõ& U
)
õõU V
=>
úú 

AddMaps
úú 
(
úú 
(
úú 
IEnumerable
úú 
<
úú  
Type
úú  $
>
úú$ %
)
úú% &=
/typesFromAssembliesContainingMappingDefinitions
úú& U
)
úúU V
;
úúV W
private
ûû 
void
ûû 
AddMapsCore
ûû 
(
ûû 
IEnumerable
ûû (
<
ûû( )
Assembly
ûû) 1
>
ûû1 2
assembliesToScan
ûû3 C
)
ûûC D
{
üü 
Profile
†† %
autoMapAttributeProfile
†† '
=
††( )
new
††* -
(
††- .
nameof
††. 4
(
††4 5
AutoMapAttribute
††5 E
)
††E F
)
††F G
;
††G H
foreach
°° 
(
°° 
var
°° 
type
°° 
in
°° 
assembliesToScan
°° -
.
°°- .
Where
°°. 3
(
°°3 4
a
°°4 5
=>
°°6 8
!
°°9 :
a
°°: ;
.
°°; <
	IsDynamic
°°< E
&&
°°F H
a
°°I J
!=
°°K M
typeof
°°N T
(
°°T U
Profile
°°U \
)
°°\ ]
.
°°] ^
Assembly
°°^ f
)
°°f g
.
°°g h

SelectMany
°°h r
(
°°r s
a
°°s t
=>
°°u w
a
°°x y
.
°°y z
GetTypes°°z Ç
(°°Ç É
)°°É Ñ
)°°Ñ Ö
)°°Ö Ü
{
¢¢ 	
if
££ 
(
££ 
typeof
££ 
(
££ 
Profile
££ 
)
££ 
.
££  
IsAssignableFrom
££  0
(
££0 1
type
££1 5
)
££5 6
&&
££7 9
!
££: ;
type
££; ?
.
££? @

IsAbstract
££@ J
&&
££K M
!
££N O
type
££O S
.
££S T'
ContainsGenericParameters
££T m
)
££m n
{
§§ 

AddProfile
•• 
(
•• 
type
•• 
)
••  
;
••  !
}
¶¶ 
foreach
®® 
(
®® 
var
®® 
autoMapAttribute
®® )
in
®®* ,
type
®®- 1
.
®®1 2!
GetCustomAttributes
®®2 E
<
®®E F
AutoMapAttribute
®®F V
>
®®V W
(
®®W X
)
®®X Y
)
®®Y Z
{
©© 
var
™™ 
mappingExpression
™™ %
=
™™& '
(
™™( )
MappingExpression
™™) :
)
™™: ;%
autoMapAttributeProfile
™™< S
.
™™S T
	CreateMap
™™T ]
(
™™] ^
autoMapAttribute
™™^ n
.
™™n o

SourceType
™™o y
,
™™y z
type
™™{ 
)™™ Ä
;™™Ä Å
foreach
¨¨ 
(
¨¨ 
var
¨¨ 

memberInfo
¨¨ '
in
¨¨( *
type
¨¨+ /
.
¨¨/ 0

GetMembers
¨¨0 :
(
¨¨: ;
BindingFlags
¨¨; G
.
¨¨G H
Public
¨¨H N
|
¨¨O P
BindingFlags
¨¨Q ]
.
¨¨] ^
Instance
¨¨^ f
)
¨¨f g
)
¨¨g h
{
≠≠ 
foreach
ÆÆ 
(
ÆÆ 
var
ÆÆ  )
memberConfigurationProvider
ÆÆ! <
in
ÆÆ= ?

memberInfo
ÆÆ@ J
.
ÆÆJ K!
GetCustomAttributes
ÆÆK ^
(
ÆÆ^ _
)
ÆÆ_ `
.
ÆÆ` a
OfType
ÆÆa g
<
ÆÆg h+
IMemberConfigurationProviderÆÆh Ñ
>ÆÆÑ Ö
(ÆÆÖ Ü
)ÆÆÜ á
)ÆÆá à
{
ØØ 
mappingExpression
∞∞ )
.
∞∞) *
	ForMember
∞∞* 3
(
∞∞3 4

memberInfo
∞∞4 >
,
∞∞> ?)
memberConfigurationProvider
∞∞@ [
.
∞∞[ \ 
ApplyConfiguration
∞∞\ n
)
∞∞n o
;
∞∞o p
}
±± 
}
≤≤ 
autoMapAttribute
¥¥  
.
¥¥  ! 
ApplyConfiguration
¥¥! 3
(
¥¥3 4
mappingExpression
¥¥4 E
)
¥¥E F
;
¥¥F G
}
µµ 
}
∂∂ 	

AddProfile
∏∏ 
(
∏∏ %
autoMapAttributeProfile
∏∏ *
)
∏∏* +
;
∏∏+ ,
}
ππ 
public
ªª 

void
ªª $
ConstructServicesUsing
ªª &
(
ªª& '
Func
ªª' +
<
ªª+ ,
Type
ªª, 0
,
ªª0 1
object
ªª2 8
>
ªª8 9
constructor
ªª: E
)
ªªE F
=>
ªªG I
_serviceCtor
ªªJ V
=
ªªW X
constructor
ªªY d
??
ªªe g
throw
ªªh m
new
ªªn q$
ArgumentNullExceptionªªr á
(ªªá à
nameofªªà é
(ªªé è
constructorªªè ö
)ªªö õ
)ªªõ ú
;ªªú ù
}ºº ˇÎ
]C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\MapperConfiguration.cs
	namespace 	

AutoMapper
 
; 
public 
	interface "
IConfigurationProvider '
{ 
void

 &
AssertConfigurationIsValid

	 #
(

# $
)

$ %
;

% &
IMapper 
CreateMapper 
( 
) 
; 
IMapper 
CreateMapper 
( 
Func 
< 
Type "
," #
object$ *
>* +
serviceCtor, 7
)7 8
;8 9
LambdaExpression 
BuildExecutionPlan '
(' (
Type( ,

sourceType- 7
,7 8
Type9 =
destinationType> M
)M N
;N O
void## 
CompileMappings##	 
(## 
)## 
;## 
}$$ 
public%% 
sealed%% 
class%% 
MapperConfiguration%% '
:%%( ) 
IGlobalConfiguration%%* >
{&& 
private'' 
static'' 
readonly'' 

MethodInfo'' &
MappingError''' 3
=''4 5
typeof''6 <
(''< =
MapperConfiguration''= P
)''P Q
.''Q R
	GetMethod''R [
(''[ \
nameof''\ b
(''b c
GetMappingError''c r
)''r s
)''s t
;''t u
private(( 
readonly(( 
IObjectMapper(( "
[((" #
]((# $
_mappers((% -
;((- .
private)) 
readonly)) 

Dictionary)) 
<))  
TypePair))  (
,))( )
TypeMap))* 1
>))1 2
_configuredMaps))3 B
;))B C
private** 
readonly** 

Dictionary** 
<**  
TypePair**  (
,**( )
TypeMap*** 1
>**1 2
_resolvedMaps**3 @
;**@ A
private++ 
readonly++ '
LockingConcurrentDictionary++ 0
<++0 1
TypePair++1 9
,++9 :
TypeMap++; B
>++B C
_runtimeMaps++D P
;++P Q
private,, 
	LazyValue,, 
<,, 
ProjectionBuilder,, '
>,,' (
_projectionBuilder,,) ;
;,,; <
private-- 
readonly-- '
LockingConcurrentDictionary-- 0
<--0 1

MapRequest--1 ;
,--; <
Delegate--= E
>--E F
_executionPlans--G V
;--V W
private.. 
readonly.. )
MapperConfigurationExpression.. 2$
_configurationExpression..3 K
;..K L
private// 
readonly// 
Features// 
<// 
IRuntimeFeature// -
>//- .
	_features/// 8
=//9 :
new//; >
(//> ?
)//? @
;//@ A
private00 
readonly00 
bool00 
_hasOpenMaps00 &
;00& '
private11 
readonly11 
HashSet11 
<11 
TypeMap11 $
>11$ %
_typeMapsPath11& 3
=114 5
[116 7
]117 8
;118 9
private22 
readonly22 
List22 
<22 

MemberInfo22 $
>22$ %
_sourceMembers22& 4
=225 6
[227 8
]228 9
;229 :
private33 
readonly33 
List33 
<33 
ParameterExpression33 -
>33- .

_variables33/ 9
=33: ;
[33< =
]33= >
;33> ?
private44 
readonly44 
ParameterExpression44 (
[44( )
]44) *
_parameters44+ 6
=447 8
[449 :
null44: >
,44> ?
null44@ D
,44D E
ContextParameter44F V
]44V W
;44W X
private55 
readonly55 

CatchBlock55 
[55  
]55  !
_catches55" *
=55+ ,
[55- .
null55. 2
]552 3
;553 4
private66 
readonly66 
List66 
<66 

Expression66 $
>66$ %
_expressions66& 2
=663 4
[665 6
]666 7
;667 8
private77 
readonly77 

Dictionary77 
<77  
Type77  $
,77$ %
DefaultExpression77& 7
>777 8
	_defaults779 B
;77B C
private88 
readonly88 #
ParameterReplaceVisitor88 ,$
_parameterReplaceVisitor88- E
=88F G
new88H K
(88K L
)88L M
;88M N
private99 
readonly99 *
ConvertParameterReplaceVisitor99 3+
_convertParameterReplaceVisitor994 S
=99T U
new99V Y
(99Y Z
)99Z [
;99[ \
private:: 
readonly:: 
List:: 
<:: 
Type:: 
>:: 
_typesInheritance::  1
=::2 3
[::4 5
]::5 6
;::6 7
public;; 

MapperConfiguration;; 
(;; )
MapperConfigurationExpression;; <#
configurationExpression;;= T
);;T U
{<< $
_configurationExpression==  
===  !#
configurationExpression==! 8
;==8 9
var>> 
configuration>> 
=>> 
(>> *
IGlobalConfigurationExpression>> ;
)>>; <#
configurationExpression>>< S
;>>S T
if?? 

(?? 
configuration?? 
.??  
MethodMappingEnabled?? .
!=??/ 1
false??2 7
)??7 8
{@@ 	
configurationAA 
.AA )
IncludeSourceExtensionMethodsAA 7
(AA7 8
typeofAA8 >
(AA> ?

EnumerableAA? I
)AAI J
)AAJ K
;AAK L
}BB 	
_mappersCC 
=CC 
[CC 
..CC 
configurationCC #
.CC# $
MappersCC$ +
]CC+ ,
;CC, -
_executionPlansDD 
=DD 
newDD 
(DD  
CompileExecutionPlanDD 2
)DD2 3
;DD3 4
_projectionBuilderEE 
=EE 
newEE  
(EE  !#
CreateProjectionBuilderEE! 8
)EE8 9
;EE9 :
ConfigurationFF 
=FF 
newFF 
(FF 
(FF !
IProfileConfigurationFF 2
)FF2 3
configurationFF3 @
)FF@ A
;FFA B
intGG 
typeMapsCountGG 
=GG 
ConfigurationGG )
.GG) *
TypeMapsCountGG* 7
;GG7 8
intHH 
openTypeMapsCountHH 
=HH 
ConfigurationHH  -
.HH- .
OpenTypeMapsCountHH. ?
;HH? @
ProfilesII 
=II 
newII 

ProfileMapII !
[II! "
configurationII" /
.II/ 0
ProfilesII0 8
.II8 9
CountII9 >
+II? @
$numIIA B
]IIB C
;IIC D
ProfilesJJ 
[JJ 
$numJJ 
]JJ 
=JJ 
ConfigurationJJ #
;JJ# $
intKK 
indexKK 
=KK 
$numKK 
;KK 
foreachLL 
(LL 
varLL 
profileLL 
inLL 
configurationLL  -
.LL- .
ProfilesLL. 6
)LL6 7
{MM 	

ProfileMapNN 

profileMapNN !
=NN" #
newNN$ '
(NN' (
profileNN( /
,NN/ 0
configurationNN1 >
)NN> ?
;NN? @
ProfilesOO 
[OO 
indexOO 
++OO 
]OO 
=OO 

profileMapOO  *
;OO* +
typeMapsCountPP 
+=PP 

profileMapPP '
.PP' (
TypeMapsCountPP( 5
;PP5 6
openTypeMapsCountQQ 
+=QQ  

profileMapQQ! +
.QQ+ ,
OpenTypeMapsCountQQ, =
;QQ= >
}RR 	
	_defaultsSS 
=SS 
newSS 
(SS 
$numSS 
*SS 
typeMapsCountSS )
)SS) *
;SS* +
_configuredMapsTT 
=TT 
newTT 
(TT 
typeMapsCountTT +
)TT+ ,
;TT, -
_hasOpenMapsUU 
=UU 
openTypeMapsCountUU (
>UU) *
$numUU+ ,
;UU, -
_resolvedMapsVV 
=VV 
newVV 
(VV 
$numVV 
*VV 
typeMapsCountVV  -
)VV- .
;VV. /
configurationWW 
.WW 
FeaturesWW 
.WW 
	ConfigureWW (
(WW( )
thisWW) -
)WW- .
;WW. /
SealYY 
(YY 
)YY 
;YY 
foreach[[ 
([[ 
var[[ 
profile[[ 
in[[ 
Profiles[[  (
)[[( )
{\\ 	
profile]] 
.]] 
Clear]] 
(]] 
)]] 
;]] 
}^^ 	
_configuredMaps__ 
.__ 

TrimExcess__ "
(__" #
)__# $
;__$ %
_resolvedMaps`` 
.`` 

TrimExcess``  
(``  !
)``! "
;``" #
_typeMapsPathaa 
=aa 
nullaa 
;aa 
_sourceMembersbb 
=bb 
nullbb 
;bb 
_expressionscc 
=cc 
nullcc 
;cc 

_variablesdd 
=dd 
nulldd 
;dd 
_parametersee 
=ee 
nullee 
;ee 
_catchesff 
=ff 
nullff 
;ff 
	_defaultsgg 
=gg 
nullgg 
;gg +
_convertParameterReplaceVisitorhh '
=hh( )
nullhh* .
;hh. /$
_parameterReplaceVisitorii  
=ii! "
nullii# '
;ii' (
_typesInheritancejj 
=jj 
nulljj  
;jj  !
_runtimeMapskk 
=kk 
newkk 
(kk 

GetTypeMapkk %
,kk% &
openTypeMapsCountkk' 8
)kk8 9
;kk9 :
returnll 
;ll 
voidmm 
Sealmm 
(mm 
)mm 
{nn 	
foreachoo 
(oo 
varoo 
profileoo  
inoo! #
Profilesoo$ ,
)oo, -
{pp 
profileqq 
.qq 
Registerqq  
(qq  !
thisqq! %
)qq% &
;qq& '
}rr 
foreachss 
(ss 
varss 
profiless  
inss! #
Profilesss$ ,
)ss, -
{tt 
profileuu 
.uu 
	Configureuu !
(uu! "
thisuu" &
)uu& '
;uu' (
}vv  
IGlobalConfigurationww  
globalConfigurationww! 4
=ww5 6
thisww7 ;
;ww; <
Listxx 
<xx 
TypeMapxx 
>xx 
derivedMapsxx %
=xx& '
[xx( )
]xx) *
;xx* +
foreachyy 
(yy 
varyy 
typeMapyy  
inyy! #
_configuredMapsyy$ 3
.yy3 4
Valuesyy4 :
)yy: ;
{zz 
_resolvedMaps{{ 
[{{ 
typeMap{{ %
.{{% &
Types{{& +
]{{+ ,
={{- .
typeMap{{/ 6
;{{6 7
derivedMaps|| 
.|| 
Clear|| !
(||! "
)||" #
;||# $
GetDerivedTypeMaps}} "
(}}" #
typeMap}}# *
,}}* +
derivedMaps}}, 7
)}}7 8
;}}8 9
foreach~~ 
(~~ 
var~~ 

derivedMap~~ '
in~~( *
derivedMaps~~+ 6
)~~6 7
{ 
_resolvedMaps
ÄÄ !
.
ÄÄ! "
TryAdd
ÄÄ" (
(
ÄÄ( )
new
ÄÄ) ,
(
ÄÄ, -

derivedMap
ÄÄ- 7
.
ÄÄ7 8

SourceType
ÄÄ8 B
,
ÄÄB C
typeMap
ÄÄD K
.
ÄÄK L
DestinationType
ÄÄL [
)
ÄÄ[ \
,
ÄÄ\ ]

derivedMap
ÄÄ^ h
)
ÄÄh i
;
ÄÄi j
}
ÅÅ 
}
ÇÇ 
foreach
ÉÉ 
(
ÉÉ 
var
ÉÉ 
typeMap
ÉÉ  
in
ÉÉ! #
_configuredMaps
ÉÉ$ 3
.
ÉÉ3 4
Values
ÉÉ4 :
)
ÉÉ: ;
{
ÑÑ 
typeMap
ÖÖ 
.
ÖÖ 
Seal
ÖÖ 
(
ÖÖ 
this
ÖÖ !
)
ÖÖ! "
;
ÖÖ" #
}
ÜÜ 
	_features
áá 
.
áá 
Seal
áá 
(
áá 
this
áá 
)
áá  
;
áá  !
}
àà 	
void
ââ  
GetDerivedTypeMaps
ââ 
(
ââ  
TypeMap
ââ  '
typeMap
ââ( /
,
ââ/ 0
List
ââ1 5
<
ââ5 6
TypeMap
ââ6 =
>
ââ= >
typeMaps
ââ? G
)
ââG H
{
ää 	
foreach
ãã 
(
ãã 
var
ãã 

derivedMap
ãã #
in
ãã$ &
this
ãã' +
.
ãã+ ,
Internal
ãã, 4
(
ãã4 5
)
ãã5 6
.
ãã6 7!
GetIncludedTypeMaps
ãã7 J
(
ããJ K
typeMap
ããK R
)
ããR S
)
ããS T
{
åå 
typeMaps
çç 
.
çç 
Add
çç 
(
çç 

derivedMap
çç '
)
çç' (
;
çç( ) 
GetDerivedTypeMaps
éé "
(
éé" #

derivedMap
éé# -
,
éé- .
typeMaps
éé/ 7
)
éé7 8
;
éé8 9
}
èè 
}
êê 	
Delegate
ëë "
CompileExecutionPlan
ëë %
(
ëë% &

MapRequest
ëë& 0

mapRequest
ëë1 ;
)
ëë; <
{
íí 	
var
ìì 
executionPlan
ìì 
=
ìì 
(
ìì  !
(
ìì! ""
IGlobalConfiguration
ìì" 6
)
ìì6 7
this
ìì7 ;
)
ìì; <
.
ìì< = 
BuildExecutionPlan
ìì= O
(
ììO P

mapRequest
ììP Z
)
ììZ [
;
ìì[ \
return
îî 
executionPlan
îî  
.
îî  !
Compile
îî! (
(
îî( )
)
îî) *
;
îî* +
}
ïï 	
}
ññ 
public
óó 
!
MapperConfiguration
óó 
(
óó 
Action
óó %
<
óó% &,
IMapperConfigurationExpression
óó& D
>
óóD E
	configure
óóF O
)
óóO P
:
óóQ R
this
óóS W
(
óóW X
Build
óóX ]
(
óó] ^
	configure
óó^ g
)
óóg h
)
óóh i
{
óói j
}
óój k
static
òò 
+
MapperConfigurationExpression
òò (
Build
òò) .
(
òò. /
Action
òò/ 5
<
òò5 6,
IMapperConfigurationExpression
òò6 T
>
òòT U
	configure
òòV _
)
òò_ `
{
ôô +
MapperConfigurationExpression
öö %
expr
öö& *
=
öö+ ,
new
öö- 0
(
öö0 1
)
öö1 2
;
öö2 3
	configure
õõ 
(
õõ 
expr
õõ 
)
õõ 
;
õõ 
return
úú 
expr
úú 
;
úú 
}
ùù 
public
ûû 

void
ûû (
AssertConfigurationIsValid
ûû *
(
ûû* +
)
ûû+ ,
=>
ûû- /
	Validator
ûû0 9
(
ûû9 :
)
ûû: ;
.
ûû; <2
$AssertConfigurationExpressionIsValid
ûû< `
(
ûû` a
[
ûûa b
..
ûûb d
_configuredMaps
ûûd s
.
ûûs t
Values
ûût z
]
ûûz {
)
ûû{ |
;
ûû| }$
ConfigurationValidator
üü 
	Validator
üü $
(
üü$ %
)
üü% &
=>
üü' )
new
üü* -
(
üü- .
this
üü. 2
)
üü2 3
;
üü3 4
public
†† 

IMapper
†† 
CreateMapper
†† 
(
††  
)
††  !
=>
††" $
new
††% (
Mapper
††) /
(
††/ 0
this
††0 4
)
††4 5
;
††5 6
public
°° 

IMapper
°° 
CreateMapper
°° 
(
°°  
Func
°°  $
<
°°$ %
Type
°°% )
,
°°) *
object
°°+ 1
>
°°1 2
serviceCtor
°°3 >
)
°°> ?
=>
°°@ B
new
°°C F
Mapper
°°G M
(
°°M N
this
°°N R
,
°°R S
serviceCtor
°°T _
)
°°_ `
;
°°` a
public
¢¢ 

void
¢¢ 
CompileMappings
¢¢ 
(
¢¢  
)
¢¢  !
{
££ 
foreach
§§ 
(
§§ 
var
§§ 
request
§§ 
in
§§ 
_resolvedMaps
§§  -
.
§§- .
Keys
§§. 2
.
§§2 3
Where
§§3 8
(
§§8 9
t
§§9 :
=>
§§; =
!
§§> ?
t
§§? @
.
§§@ A'
ContainsGenericParameters
§§A Z
)
§§Z [
.
§§[ \
Select
§§\ b
(
§§b c
types
§§c h
=>
§§i k
new
§§l o

MapRequest
§§p z
(
§§z {
types§§{ Ä
)§§Ä Å
)§§Å Ç
.§§Ç É
ToArray§§É ä
(§§ä ã
)§§ã å
)§§å ç
{
•• 	
GetExecutionPlan
¶¶ 
(
¶¶ 
request
¶¶ $
)
¶¶$ %
;
¶¶% &
}
ßß 	
}
®® 
public
©© 

LambdaExpression
©©  
BuildExecutionPlan
©© .
(
©©. /
Type
©©/ 3

sourceType
©©4 >
,
©©> ?
Type
©©@ D
destinationType
©©E T
)
©©T U
=>
©©V X
this
©©Y ]
.
©©] ^
Internal
©©^ f
(
©©f g
)
©©g h
.
©©h i 
BuildExecutionPlan
©©i {
(
©©{ |
new
©©| 
(©© Ä
new©©Ä É
(©©É Ñ

sourceType©©Ñ é
,©©é è
destinationType©©ê ü
)©©ü †
)©©† °
)©©° ¢
;©©¢ £
LambdaExpression
™™ "
IGlobalConfiguration
™™ )
.
™™) * 
BuildExecutionPlan
™™* <
(
™™< =
in
™™= ?

MapRequest
™™@ J

mapRequest
™™K U
)
™™U V
{
´´ 
var
¨¨ 
typeMap
¨¨ 
=
¨¨ 
ResolveTypeMap
¨¨ $
(
¨¨$ %

mapRequest
¨¨% /
.
¨¨/ 0
RuntimeTypes
¨¨0 <
)
¨¨< =
??
¨¨> @
ResolveTypeMap
¨¨A O
(
¨¨O P

mapRequest
¨¨P Z
.
¨¨Z [
RequestedTypes
¨¨[ i
)
¨¨i j
;
¨¨j k
if
≠≠ 

(
≠≠ 
typeMap
≠≠ 
!=
≠≠ 
null
≠≠ 
)
≠≠ 
{
ÆÆ 	
return
ØØ '
GenerateTypeMapExpression
ØØ ,
(
ØØ, -

mapRequest
ØØ- 7
.
ØØ7 8
RequestedTypes
ØØ8 F
,
ØØF G
typeMap
ØØH O
)
ØØO P
;
ØØP Q
}
∞∞ 	
var
±± 
mapperToUse
±± 
=
±± 

FindMapper
±± $
(
±±$ %

mapRequest
±±% /
.
±±/ 0
RuntimeTypes
±±0 <
)
±±< =
;
±±= >
return
≤≤ ,
GenerateObjectMapperExpression
≤≤ -
(
≤≤- .

mapRequest
≤≤. 8
,
≤≤8 9
mapperToUse
≤≤: E
)
≤≤E F
;
≤≤F G
static
≥≥ 
LambdaExpression
≥≥ '
GenerateTypeMapExpression
≥≥  9
(
≥≥9 :
TypePair
≥≥: B
requestedTypes
≥≥C Q
,
≥≥Q R
TypeMap
≥≥S Z
typeMap
≥≥[ b
)
≥≥b c
{
¥¥ 	
typeMap
µµ 
.
µµ 
CheckProjection
µµ #
(
µµ# $
)
µµ$ %
;
µµ% &
if
∂∂ 
(
∂∂ 
requestedTypes
∂∂ 
==
∂∂ !
typeMap
∂∂" )
.
∂∂) *
Types
∂∂* /
)
∂∂/ 0
{
∑∑ 
return
∏∏ 
typeMap
∏∏ 
.
∏∏ 
MapExpression
∏∏ ,
;
∏∏, -
}
ππ 
var
∫∫ &
requestedDestinationType
∫∫ (
=
∫∫) *
requestedTypes
∫∫+ 9
.
∫∫9 :
DestinationType
∫∫: I
;
∫∫I J
var
ªª 
source
ªª 
=
ªª 
	Parameter
ªª "
(
ªª" #
requestedTypes
ªª# 1
.
ªª1 2

SourceType
ªª2 <
,
ªª< =
$str
ªª> F
)
ªªF G
;
ªªG H
var
ºº 
destination
ºº 
=
ºº 
	Parameter
ºº '
(
ºº' (&
requestedDestinationType
ºº( @
,
ºº@ A
$str
ººB V
)
ººV W
;
ººW X
var
ΩΩ $
checkNullValueTypeDest
ΩΩ &
=
ΩΩ' ( 
CheckNullValueType
ΩΩ) ;
(
ΩΩ; <
destination
ΩΩ< G
,
ΩΩG H
typeMap
ΩΩI P
.
ΩΩP Q
DestinationType
ΩΩQ `
)
ΩΩ` a
;
ΩΩa b
return
ææ 
Lambda
ææ 
(
ææ 
ToType
ææ  
(
ææ  !
typeMap
ææ! (
.
ææ( )
Invoke
ææ) /
(
ææ/ 0
source
ææ0 6
,
ææ6 7$
checkNullValueTypeDest
ææ8 N
)
ææN O
,
ææO P&
requestedDestinationType
ææQ i
)
ææi j
,
ææj k
source
ææl r
,
æær s
destination
ææt 
,ææ Ä 
ContextParameterææÅ ë
)ææë í
;ææí ì
}
øø 	
static
¿¿ 

Expression
¿¿  
CheckNullValueType
¿¿ ,
(
¿¿, -

Expression
¿¿- 7

expression
¿¿8 B
,
¿¿B C
Type
¿¿D H
runtimeType
¿¿I T
)
¿¿T U
=>
¿¿V X
!
¡¡ 

expression
¡¡ 
.
¡¡ 
Type
¡¡ 
.
¡¡ 
IsValueType
¡¡ (
&&
¡¡) +
runtimeType
¡¡, 7
.
¡¡7 8
IsValueType
¡¡8 C
?
¡¡D E
Coalesce
¡¡F N
(
¡¡N O

expression
¡¡O Y
,
¡¡Y Z
Default
¡¡[ b
(
¡¡b c
runtimeType
¡¡c n
)
¡¡n o
)
¡¡o p
:
¡¡q r

expression
¡¡s }
;
¡¡} ~
LambdaExpression
¬¬ ,
GenerateObjectMapperExpression
¬¬ 7
(
¬¬7 8
in
¬¬8 :

MapRequest
¬¬; E

mapRequest
¬¬F P
,
¬¬P Q
IObjectMapper
¬¬R _
mapper
¬¬` f
)
¬¬f g
{
√√ 	
var
ƒƒ 
source
ƒƒ 
=
ƒƒ 
	Parameter
ƒƒ "
(
ƒƒ" #

mapRequest
ƒƒ# -
.
ƒƒ- .
RequestedTypes
ƒƒ. <
.
ƒƒ< =

SourceType
ƒƒ= G
,
ƒƒG H
$str
ƒƒI Q
)
ƒƒQ R
;
ƒƒR S
var
≈≈ 
destinationType
≈≈ 
=
≈≈  !

mapRequest
≈≈" ,
.
≈≈, -
RequestedTypes
≈≈- ;
.
≈≈; <
DestinationType
≈≈< K
;
≈≈K L
var
∆∆ 
destination
∆∆ 
=
∆∆ 
	Parameter
∆∆ '
(
∆∆' (
destinationType
∆∆( 7
,
∆∆7 8
$str
∆∆9 L
)
∆∆L M
;
∆∆M N
var
«« $
runtimeDestinationType
«« &
=
««' (

mapRequest
««) 3
.
««3 4
RuntimeTypes
««4 @
.
««@ A
DestinationType
««A P
;
««P Q

Expression
»» 
fullExpression
»» %
;
»»% &
if
…… 
(
…… 
mapper
…… 
==
…… 
null
…… 
)
…… 
{
   (
AutoMapperMappingException
ÀÀ *
	exception
ÀÀ+ 4
=
ÀÀ5 6
new
ÀÀ7 :
(
ÀÀ: ;
$str
ÀÀ; s
,
ÀÀs t
null
ÀÀu y
,
ÀÀy z

mapRequestÀÀ{ Ö
.ÀÀÖ Ü
RuntimeTypesÀÀÜ í
)ÀÀí ì
{
ÃÃ 
	MemberMap
ÕÕ 
=
ÕÕ 

mapRequest
ÕÕ  *
.
ÕÕ* +
	MemberMap
ÕÕ+ 4
}
ŒŒ 
;
ŒŒ 
fullExpression
œœ 
=
œœ  
Throw
œœ! &
(
œœ& '
Constant
œœ' /
(
œœ/ 0
	exception
œœ0 9
)
œœ9 :
,
œœ: ;$
runtimeDestinationType
œœ< R
)
œœR S
;
œœS T
}
–– 
else
—— 
{
““ 
var
”” $
checkNullValueTypeDest
”” *
=
””+ , 
CheckNullValueType
””- ?
(
””? @
destination
””@ K
,
””K L$
runtimeDestinationType
””M c
)
””c d
;
””d e
var
‘‘ 
mapperSource
‘‘  
=
‘‘! "
ToType
‘‘# )
(
‘‘) *
source
‘‘* 0
,
‘‘0 1

mapRequest
‘‘2 <
.
‘‘< =
RuntimeTypes
‘‘= I
.
‘‘I J

SourceType
‘‘J T
)
‘‘T U
;
‘‘U V
var
’’ 
map
’’ 
=
’’ 
mapper
’’  
.
’’  !
MapExpression
’’! .
(
’’. /
this
’’/ 3
,
’’3 4
Configuration
’’5 B
,
’’B C

mapRequest
’’D N
.
’’N O
	MemberMap
’’O X
,
’’X Y
mapperSource
’’Z f
,
’’f g
ToType
’’h n
(
’’n o%
checkNullValueTypeDest’’o Ö
,’’Ö Ü&
runtimeDestinationType’’á ù
)’’ù û
)’’û ü
;’’ü †
var
÷÷ 
newException
÷÷  
=
÷÷! "
Call
÷÷# '
(
÷÷' (
MappingError
÷÷( 4
,
÷÷4 5 
ExceptionParameter
÷÷6 H
,
÷÷H I
Constant
÷÷J R
(
÷÷R S

mapRequest
÷÷S ]
)
÷÷] ^
)
÷÷^ _
;
÷÷_ `
fullExpression
◊◊ 
=
◊◊  
TryCatch
◊◊! )
(
◊◊) *
ToType
◊◊* 0
(
◊◊0 1
map
◊◊1 4
,
◊◊4 5
destinationType
◊◊6 E
)
◊◊E F
,
◊◊F G
Catch
◊◊H M
(
◊◊M N 
ExceptionParameter
◊◊N `
,
◊◊` a
Throw
◊◊b g
(
◊◊g h
newException
◊◊h t
,
◊◊t u
destinationType◊◊v Ö
)◊◊Ö Ü
)◊◊Ü á
)◊◊á à
;◊◊à â
}
ÿÿ 
var
ŸŸ 

profileMap
ŸŸ 
=
ŸŸ 

mapRequest
ŸŸ '
.
ŸŸ' (
	MemberMap
ŸŸ( 1
?
ŸŸ1 2
.
ŸŸ2 3
Profile
ŸŸ3 :
??
ŸŸ; =
Configuration
ŸŸ> K
;
ŸŸK L
fullExpression
⁄⁄ 
=
⁄⁄ 
this
⁄⁄ !
.
⁄⁄! "
NullCheckSource
⁄⁄" 1
(
⁄⁄1 2

profileMap
⁄⁄2 <
,
⁄⁄< =
source
⁄⁄> D
,
⁄⁄D E
destination
⁄⁄F Q
,
⁄⁄Q R
fullExpression
⁄⁄S a
,
⁄⁄a b

mapRequest
⁄⁄c m
.
⁄⁄m n
	MemberMap
⁄⁄n w
)
⁄⁄w x
;
⁄⁄x y
return
€€ 
Lambda
€€ 
(
€€ 
fullExpression
€€ (
,
€€( )
source
€€* 0
,
€€0 1
destination
€€2 =
,
€€= >
ContextParameter
€€? O
)
€€O P
;
€€P Q
}
‹‹ 	
}
›› 
internal
ﬁﬁ ,
IGlobalConfigurationExpression
ﬁﬁ +%
ConfigurationExpression
ﬁﬁ, C
=>
ﬁﬁD F&
_configurationExpression
ﬁﬁG _
;
ﬁﬁ_ `
ProjectionBuilder
ﬂﬂ %
CreateProjectionBuilder
ﬂﬂ -
(
ﬂﬂ- .
)
ﬂﬂ. /
=>
ﬂﬂ0 2
new
ﬂﬂ3 6
(
ﬂﬂ6 7
this
ﬂﬂ7 ;
,
ﬂﬂ; <
[
ﬂﬂ= >
..
ﬂﬂ> @%
ConfigurationExpression
ﬂﬂ@ W
.
ﬂﬂW X
ProjectionMappers
ﬂﬂX i
]
ﬂﬂi j
)
ﬂﬂj k
;
ﬂﬂk l 
IProjectionBuilder
‡‡ "
IGlobalConfiguration
‡‡ +
.
‡‡+ ,
ProjectionBuilder
‡‡, =
=>
‡‡> @ 
_projectionBuilder
‡‡A S
.
‡‡S T
Value
‡‡T Y
;
‡‡Y Z
Func
·· 
<
·· 	
Type
··	 
,
·· 
object
·· 
>
·· "
IGlobalConfiguration
·· +
.
··+ ,
ServiceCtor
··, 7
=>
··8 :%
ConfigurationExpression
··; R
.
··R S
ServiceCtor
··S ^
;
··^ _
bool
‚‚ "
IGlobalConfiguration
‚‚	 
.
‚‚ 2
$EnableNullPropagationForQueryMapping
‚‚ B
=>
‚‚C E%
ConfigurationExpression
‚‚F ]
.
‚‚] ^3
$EnableNullPropagationForQueryMapping‚‚^ Ç
.‚‚Ç É!
GetValueOrDefault‚‚É î
(‚‚î ï
)‚‚ï ñ
;‚‚ñ ó
int
„„ "
IGlobalConfiguration
„„ 
.
„„ #
MaxExecutionPlanDepth
„„ 2
=>
„„3 5%
ConfigurationExpression
„„6 M
.
„„M N#
MaxExecutionPlanDepth
„„N c
+
„„d e
$num
„„f g
;
„„g h
private
‰‰ 

ProfileMap
‰‰ 
Configuration
‰‰ $
{
‰‰% &
get
‰‰' *
;
‰‰* +
}
‰‰, -

ProfileMap
ÂÂ 
[
ÂÂ 
]
ÂÂ "
IGlobalConfiguration
ÂÂ %
.
ÂÂ% &
Profiles
ÂÂ& .
=>
ÂÂ/ 1
Profiles
ÂÂ2 :
;
ÂÂ: ;
internal
ÊÊ 

ProfileMap
ÊÊ 
[
ÊÊ 
]
ÊÊ 
Profiles
ÊÊ "
{
ÊÊ# $
get
ÊÊ% (
;
ÊÊ( )
}
ÊÊ* +
int
ÁÁ "
IGlobalConfiguration
ÁÁ 
.
ÁÁ &
RecursiveQueriesMaxDepth
ÁÁ 5
=>
ÁÁ6 8%
ConfigurationExpression
ÁÁ9 P
.
ÁÁP Q&
RecursiveQueriesMaxDepth
ÁÁQ i
;
ÁÁi j
Features
ËË 
<
ËË 
IRuntimeFeature
ËË 
>
ËË "
IGlobalConfiguration
ËË 2
.
ËË2 3
Features
ËË3 ;
=>
ËË< >
	_features
ËË? H
;
ËËH I
List
ÈÈ 
<
ÈÈ 	

MemberInfo
ÈÈ	 
>
ÈÈ "
IGlobalConfiguration
ÈÈ )
.
ÈÈ) *
SourceMembers
ÈÈ* 7
=>
ÈÈ8 :
_sourceMembers
ÈÈ; I
;
ÈÈI J
List
ÍÍ 
<
ÍÍ 	!
ParameterExpression
ÍÍ	 
>
ÍÍ "
IGlobalConfiguration
ÍÍ 2
.
ÍÍ2 3
	Variables
ÍÍ3 <
=>
ÍÍ= ?

_variables
ÍÍ@ J
;
ÍÍJ K
List
ÎÎ 
<
ÎÎ 	

Expression
ÎÎ	 
>
ÎÎ "
IGlobalConfiguration
ÎÎ )
.
ÎÎ) *
Expressions
ÎÎ* 5
=>
ÎÎ6 8
_expressions
ÎÎ9 E
;
ÎÎE F
HashSet
ÏÏ 
<
ÏÏ 
TypeMap
ÏÏ 
>
ÏÏ "
IGlobalConfiguration
ÏÏ )
.
ÏÏ) *
TypeMapsPath
ÏÏ* 6
=>
ÏÏ7 9
_typeMapsPath
ÏÏ: G
;
ÏÏG H!
ParameterExpression
ÌÌ 
[
ÌÌ 
]
ÌÌ "
IGlobalConfiguration
ÌÌ .
.
ÌÌ. /

Parameters
ÌÌ/ 9
=>
ÌÌ: <
_parameters
ÌÌ= H
;
ÌÌH I

CatchBlock
ÓÓ 
[
ÓÓ 
]
ÓÓ "
IGlobalConfiguration
ÓÓ %
.
ÓÓ% &
Catches
ÓÓ& -
=>
ÓÓ. 0
_catches
ÓÓ1 9
;
ÓÓ9 :,
ConvertParameterReplaceVisitor
ÔÔ ""
IGlobalConfiguration
ÔÔ# 7
.
ÔÔ7 8,
ConvertParameterReplaceVisitor
ÔÔ8 V
(
ÔÔV W
)
ÔÔW X
=>
ÔÔY [-
_convertParameterReplaceVisitor
ÔÔ\ {
??
ÔÔ| ~
newÔÔ Ç
(ÔÔÇ É
)ÔÔÉ Ñ
;ÔÔÑ Ö%
ParameterReplaceVisitor
 "
IGlobalConfiguration
 0
.
0 1%
ParameterReplaceVisitor
1 H
(
H I
)
I J
=>
K M&
_parameterReplaceVisitor
N f
??
g i
new
j m
(
m n
)
n o
;
o p
DefaultExpression
ÒÒ "
IGlobalConfiguration
ÒÒ *
.
ÒÒ* +

GetDefault
ÒÒ+ 5
(
ÒÒ5 6
Type
ÒÒ6 :
type
ÒÒ; ?
)
ÒÒ? @
{
ÚÚ 
if
ÛÛ 

(
ÛÛ 
	_defaults
ÛÛ 
==
ÛÛ 
null
ÛÛ 
)
ÛÛ 
{
ÙÙ 	
return
ıı 
Default
ıı 
(
ıı 
type
ıı 
)
ıı  
;
ıı  !
}
ˆˆ 	
if
˜˜ 

(
˜˜ 
!
˜˜ 
	_defaults
˜˜ 
.
˜˜ 
TryGetValue
˜˜ "
(
˜˜" #
type
˜˜# '
,
˜˜' (
out
˜˜) ,
var
˜˜- 0
defaultExpression
˜˜1 B
)
˜˜B C
)
˜˜C D
{
¯¯ 	
defaultExpression
˘˘ 
=
˘˘ 
Default
˘˘  '
(
˘˘' (
type
˘˘( ,
)
˘˘, -
;
˘˘- .
	_defaults
˙˙ 
.
˙˙ 
Add
˙˙ 
(
˙˙ 
type
˙˙ 
,
˙˙ 
defaultExpression
˙˙  1
)
˙˙1 2
;
˙˙2 3
}
˚˚ 	
return
¸¸ 
defaultExpression
¸¸  
;
¸¸  !
}
˝˝ 
Func
˛˛ 
<
˛˛ 	
TSource
˛˛	 
,
˛˛ 
TDestination
˛˛ 
,
˛˛ 
ResolutionContext
˛˛  1
,
˛˛1 2
TDestination
˛˛3 ?
>
˛˛? @"
IGlobalConfiguration
˛˛A U
.
˛˛U V
GetExecutionPlan
˛˛V f
<
˛˛f g
TSource
˛˛g n
,
˛˛n o
TDestination
˛˛p |
>
˛˛| }
(
˛˛} ~
in˛˛~ Ä

MapRequest˛˛Å ã

mapRequest˛˛å ñ
)˛˛ñ ó
=>
ˇˇ 

(
ˇˇ 
Func
ˇˇ 
<
ˇˇ 
TSource
ˇˇ 
,
ˇˇ 
TDestination
ˇˇ &
,
ˇˇ& '
ResolutionContext
ˇˇ( 9
,
ˇˇ9 :
TDestination
ˇˇ; G
>
ˇˇG H
)
ˇˇH I
GetExecutionPlan
ˇˇI Y
(
ˇˇY Z

mapRequest
ˇˇZ d
)
ˇˇd e
;
ˇˇe f
private
ÄÄ 
Delegate
ÄÄ 
GetExecutionPlan
ÄÄ %
(
ÄÄ% &
in
ÄÄ& (

MapRequest
ÄÄ) 3

mapRequest
ÄÄ4 >
)
ÄÄ> ?
=>
ÄÄ@ B
_executionPlans
ÄÄC R
.
ÄÄR S
GetOrAdd
ÄÄS [
(
ÄÄ[ \

mapRequest
ÄÄ\ f
)
ÄÄf g
;
ÄÄg h
TypeMap
ÅÅ "
IGlobalConfiguration
ÅÅ  
.
ÅÅ  !&
ResolveAssociatedTypeMap
ÅÅ! 9
(
ÅÅ9 :
TypePair
ÅÅ: B
types
ÅÅC H
)
ÅÅH I
{
ÇÇ 
var
ÉÉ 
typeMap
ÉÉ 
=
ÉÉ 
ResolveTypeMap
ÉÉ $
(
ÉÉ$ %
types
ÉÉ% *
)
ÉÉ* +
;
ÉÉ+ ,
if
ÑÑ 

(
ÑÑ 
typeMap
ÑÑ 
!=
ÑÑ 
null
ÑÑ 
)
ÑÑ 
{
ÖÖ 	
return
ÜÜ 
typeMap
ÜÜ 
;
ÜÜ 
}
áá 	
if
àà 

(
àà 

FindMapper
àà 
(
àà 
types
àà 
)
àà 
?
àà 
.
àà  
GetAssociatedTypes
àà 1
(
àà1 2
types
àà2 7
)
àà7 8
is
àà9 ;
TypePair
àà< D
newTypes
ààE M
)
ààM N
{
ââ 	
return
ää 
ResolveTypeMap
ää !
(
ää! "
newTypes
ää" *
)
ää* +
;
ää+ ,
}
ãã 	
return
åå 
null
åå 
;
åå 
}
çç 
public
éé 

static
éé (
AutoMapperMappingException
éé ,
GetMappingError
éé- <
(
éé< =
	Exception
éé= F
innerException
ééG U
,
ééU V
in
ééW Y

MapRequest
ééZ d

mapRequest
éée o
)
ééo p
=>
ééq s
new
èè 
(
èè 
$str
èè "
,
èè" #
innerException
èè$ 2
,
èè2 3

mapRequest
èè4 >
.
èè> ?
RuntimeTypes
èè? K
)
èèK L
{
èèM N
	MemberMap
èèO X
=
èèY Z

mapRequest
èè[ e
.
èèe f
	MemberMap
èèf o
}
èèp q
;
èèq r!
IReadOnlyCollection
êê 
<
êê 
TypeMap
êê 
>
êê  "
IGlobalConfiguration
êê! 5
.
êê5 6
GetAllTypeMaps
êê6 D
(
êêD E
)
êêE F
=>
êêG I
_configuredMaps
êêJ Y
.
êêY Z
Values
êêZ `
;
êê` a
TypeMap
ëë "
IGlobalConfiguration
ëë  
.
ëë  !
FindTypeMapFor
ëë! /
(
ëë/ 0
Type
ëë0 4

sourceType
ëë5 ?
,
ëë? @
Type
ëëA E
destinationType
ëëF U
)
ëëU V
=>
ëëW Y
FindTypeMapFor
ëëZ h
(
ëëh i

sourceType
ëëi s
,
ëës t
destinationTypeëëu Ñ
)ëëÑ Ö
;ëëÖ Ü
TypeMap
íí "
IGlobalConfiguration
íí  
.
íí  !
FindTypeMapFor
íí! /
<
íí/ 0
TSource
íí0 7
,
íí7 8
TDestination
íí9 E
>
ííE F
(
ííF G
)
ííG H
=>
ííI K
FindTypeMapFor
ííL Z
(
ííZ [
typeof
íí[ a
(
íía b
TSource
ííb i
)
ííi j
,
ííj k
typeof
ííl r
(
íír s
TDestination
íís 
)íí Ä
)ííÄ Å
;ííÅ Ç
TypeMap
ìì "
IGlobalConfiguration
ìì  
.
ìì  !
FindTypeMapFor
ìì! /
(
ìì/ 0
TypePair
ìì0 8
typePair
ìì9 A
)
ììA B
=>
ììC E
FindTypeMapFor
ììF T
(
ììT U
typePair
ììU ]
)
ìì] ^
;
ìì^ _
TypeMap
îî 
FindTypeMapFor
îî 
(
îî 
Type
îî 

sourceType
îî  *
,
îî* +
Type
îî, 0
destinationType
îî1 @
)
îî@ A
=>
îîB D
FindTypeMapFor
îîE S
(
îîS T
new
îîT W
(
îîW X

sourceType
îîX b
,
îîb c
destinationType
îîd s
)
îîs t
)
îît u
;
îîu v
TypeMap
ïï 
FindTypeMapFor
ïï 
(
ïï 
TypePair
ïï #
typePair
ïï$ ,
)
ïï, -
=>
ïï. 0
_configuredMaps
ïï1 @
.
ïï@ A
GetValueOrDefault
ïïA R
(
ïïR S
typePair
ïïS [
)
ïï[ \
;
ïï\ ]
TypeMap
ññ "
IGlobalConfiguration
ññ  
.
ññ  !
ResolveTypeMap
ññ! /
(
ññ/ 0
Type
ññ0 4

sourceType
ññ5 ?
,
ññ? @
Type
ññA E
destinationType
ññF U
)
ññU V
=>
ññW Y
ResolveTypeMap
ññZ h
(
ññh i
new
ññi l
(
ññl m

sourceType
ññm w
,
ññw x
destinationTypeññy à
)ññà â
)ññâ ä
;ññä ã
TypeMap
óó "
IGlobalConfiguration
óó  
.
óó  !
ResolveTypeMap
óó! /
(
óó/ 0
TypePair
óó0 8
typePair
óó9 A
)
óóA B
=>
óóC E
ResolveTypeMap
óóF T
(
óóT U
typePair
óóU ]
)
óó] ^
;
óó^ _
TypeMap
òò 
ResolveTypeMap
òò 
(
òò 
TypePair
òò #
typePair
òò$ ,
)
òò, -
{
ôô 
if
öö 

(
öö 
_resolvedMaps
öö 
.
öö 
TryGetValue
öö %
(
öö% &
typePair
öö& .
,
öö. /
out
öö0 3
TypeMap
öö4 ;
typeMap
öö< C
)
ööC D
)
ööD E
{
õõ 	
return
úú 
typeMap
úú 
;
úú 
}
ùù 	
if
ûû 

(
ûû 
_runtimeMaps
ûû 
.
ûû 
	IsDefault
ûû "
)
ûû" #
{
üü 	
typeMap
†† 
=
†† 

GetTypeMap
††  
(
††  !
typePair
††! )
)
††) *
;
††* +
_resolvedMaps
°° 
.
°° 
Add
°° 
(
°° 
typePair
°° &
,
°°& '
typeMap
°°( /
)
°°/ 0
;
°°0 1
if
¢¢ 
(
¢¢ 
typeMap
¢¢ 
!=
¢¢ 
null
¢¢ 
&&
¢¢  "
typeMap
¢¢# *
.
¢¢* +
MapExpression
¢¢+ 8
==
¢¢9 ;
null
¢¢< @
)
¢¢@ A
{
££ 
typeMap
§§ 
.
§§ 
Seal
§§ 
(
§§ 
this
§§ !
)
§§! "
;
§§" #
}
•• 
}
¶¶ 	
else
ßß 
{
®® 	
typeMap
©© 
=
©© 
_runtimeMaps
©© "
.
©©" #
GetOrAdd
©©# +
(
©©+ ,
typePair
©©, 4
)
©©4 5
;
©©5 6
if
´´ 
(
´´ 
typeMap
´´ 
!=
´´ 
null
´´ 
&&
´´  "
typeMap
´´# *
.
´´* +
MapExpression
´´+ 8
==
´´9 ;
null
´´< @
)
´´@ A
{
¨¨ 
lock
≠≠ 
(
≠≠ 
typeMap
≠≠ 
)
≠≠ 
{
ÆÆ 
typeMap
ØØ 
.
ØØ 
Seal
ØØ  
(
ØØ  !
this
ØØ! %
)
ØØ% &
;
ØØ& '
}
∞∞ 
}
±± 
}
≤≤ 	
return
≥≥ 
typeMap
≥≥ 
;
≥≥ 
}
¥¥ 
private
µµ 
TypeMap
µµ 

GetTypeMap
µµ 
(
µµ 
TypePair
µµ '
initialTypes
µµ( 4
)
µµ4 5
{
∂∂ 
var
∑∑ 
typeMap
∑∑ 
=
∑∑ )
FindClosedGenericTypeMapFor
∑∑ 1
(
∑∑1 2
initialTypes
∑∑2 >
)
∑∑> ?
;
∑∑? @
if
∏∏ 

(
∏∏ 
typeMap
∏∏ 
!=
∏∏ 
null
∏∏ 
)
∏∏ 
{
ππ 	
return
∫∫ 
typeMap
∫∫ 
;
∫∫ 
}
ªª 	
List
ºº 
<
ºº 
Type
ºº 
>
ºº 
typesInheritance
ºº #
;
ºº# $
if
ΩΩ 

(
ΩΩ 
_typesInheritance
ΩΩ 
==
ΩΩ  
null
ΩΩ! %
)
ΩΩ% &
{
ææ 	
typesInheritance
øø 
=
øø 
[
øø  
]
øø  !
;
øø! "
}
¿¿ 	
else
¡¡ 
{
¬¬ 	
_typesInheritance
√√ 
.
√√ 
Clear
√√ #
(
√√# $
)
√√$ %
;
√√% &
typesInheritance
ƒƒ 
=
ƒƒ 
_typesInheritance
ƒƒ 0
;
ƒƒ0 1
}
≈≈ 	 
GetTypeInheritance
∆∆ 
(
∆∆ 
typesInheritance
∆∆ +
,
∆∆+ ,
initialTypes
∆∆- 9
.
∆∆9 :

SourceType
∆∆: D
)
∆∆D E
;
∆∆E F
var
«« 
sourceTypesLength
«« 
=
«« 
typesInheritance
««  0
.
««0 1
Count
««1 6
;
««6 7 
GetTypeInheritance
»» 
(
»» 
typesInheritance
»» +
,
»»+ ,
initialTypes
»»- 9
.
»»9 :
DestinationType
»»: I
)
»»I J
;
»»J K
for
…… 
(
…… 
int
…… 
destinationIndex
……  
=
……! "
sourceTypesLength
……# 4
;
……4 5
destinationIndex
……6 F
<
……G H
typesInheritance
……I Y
.
……Y Z
Count
……Z _
;
……_ `
destinationIndex
……a q
++
……q s
)
……s t
{
   	
var
ÀÀ 
destinationType
ÀÀ 
=
ÀÀ  !
typesInheritance
ÀÀ" 2
[
ÀÀ2 3
destinationIndex
ÀÀ3 C
]
ÀÀC D
;
ÀÀD E
for
ÃÃ 
(
ÃÃ 
int
ÃÃ 
sourceIndex
ÃÃ 
=
ÃÃ  !
$num
ÃÃ" #
;
ÃÃ# $
sourceIndex
ÃÃ% 0
<
ÃÃ1 2
sourceTypesLength
ÃÃ3 D
;
ÃÃD E
sourceIndex
ÃÃF Q
++
ÃÃQ S
)
ÃÃS T
{
ÕÕ 
var
ŒŒ 

sourceType
ŒŒ 
=
ŒŒ  
typesInheritance
ŒŒ! 1
[
ŒŒ1 2
sourceIndex
ŒŒ2 =
]
ŒŒ= >
;
ŒŒ> ?
if
œœ 
(
œœ 

sourceType
œœ 
==
œœ !
initialTypes
œœ" .
.
œœ. /

SourceType
œœ/ 9
&&
œœ: <
destinationType
œœ= L
==
œœM O
initialTypes
œœP \
.
œœ\ ]
DestinationType
œœ] l
)
œœl m
{
–– 
continue
—— 
;
—— 
}
““ 
TypePair
”” 
types
”” 
=
””  
new
””! $
(
””$ %

sourceType
””% /
,
””/ 0
destinationType
””1 @
)
””@ A
;
””A B
if
‘‘ 
(
‘‘ 
_resolvedMaps
‘‘ !
.
‘‘! "
TryGetValue
‘‘" -
(
‘‘- .
types
‘‘. 3
,
‘‘3 4
out
‘‘5 8
typeMap
‘‘9 @
)
‘‘@ A
)
‘‘A B
{
’’ 
if
÷÷ 
(
÷÷ 
typeMap
÷÷ 
==
÷÷ !
null
÷÷" &
)
÷÷& '
{
◊◊ 
continue
ÿÿ  
;
ÿÿ  !
}
ŸŸ 
return
⁄⁄ 
typeMap
⁄⁄ "
;
⁄⁄" #
}
€€ 
typeMap
‹‹ 
=
‹‹ )
FindClosedGenericTypeMapFor
‹‹ 5
(
‹‹5 6
types
‹‹6 ;
)
‹‹; <
;
‹‹< =
if
›› 
(
›› 
typeMap
›› 
!=
›› 
null
›› #
)
››# $
{
ﬁﬁ 
return
ﬂﬂ 
typeMap
ﬂﬂ "
;
ﬂﬂ" #
}
‡‡ 
}
·· 
}
‚‚ 	
return
„„ 
null
„„ 
;
„„ 
static
‰‰ 
void
‰‰  
GetTypeInheritance
‰‰ &
(
‰‰& '
List
‰‰' +
<
‰‰+ ,
Type
‰‰, 0
>
‰‰0 1
types
‰‰2 7
,
‰‰7 8
Type
‰‰9 =
type
‰‰> B
)
‰‰B C
{
ÂÂ 	
var
ÊÊ 

interfaces
ÊÊ 
=
ÊÊ 
type
ÊÊ !
.
ÊÊ! "
GetInterfaces
ÊÊ" /
(
ÊÊ/ 0
)
ÊÊ0 1
;
ÊÊ1 2
var
ÁÁ 
	lastIndex
ÁÁ 
=
ÁÁ 

interfaces
ÁÁ &
.
ÁÁ& '
Length
ÁÁ' -
-
ÁÁ. /
$num
ÁÁ0 1
;
ÁÁ1 2
types
ËË 
.
ËË 
Add
ËË 
(
ËË 
type
ËË 
)
ËË 
;
ËË 
Type
ÈÈ 
baseType
ÈÈ 
=
ÈÈ 
type
ÈÈ  
;
ÈÈ  !
while
ÍÍ 
(
ÍÍ 
(
ÍÍ 
baseType
ÍÍ 
=
ÍÍ 
baseType
ÍÍ '
.
ÍÍ' (
BaseType
ÍÍ( 0
)
ÍÍ0 1
!=
ÍÍ2 4
null
ÍÍ5 9
)
ÍÍ9 :
{
ÎÎ 
types
ÏÏ 
.
ÏÏ 
Add
ÏÏ 
(
ÏÏ 
baseType
ÏÏ "
)
ÏÏ" #
;
ÏÏ# $
foreach
ÌÌ 
(
ÌÌ 
var
ÌÌ 
interfaceType
ÌÌ *
in
ÌÌ+ -
baseType
ÌÌ. 6
.
ÌÌ6 7
GetInterfaces
ÌÌ7 D
(
ÌÌD E
)
ÌÌE F
)
ÌÌF G
{
ÓÓ 
var
ÔÔ 
interfaceIndex
ÔÔ &
=
ÔÔ' (
Array
ÔÔ) .
.
ÔÔ. /
LastIndexOf
ÔÔ/ :
(
ÔÔ: ;

interfaces
ÔÔ; E
,
ÔÔE F
interfaceType
ÔÔG T
)
ÔÔT U
;
ÔÔU V
if
 
(
 
interfaceIndex
 &
!=
' )
	lastIndex
* 3
)
3 4
{
ÒÒ 

interfaces
ÚÚ "
[
ÚÚ" #
interfaceIndex
ÚÚ# 1
]
ÚÚ1 2
=
ÚÚ3 4

interfaces
ÚÚ5 ?
[
ÚÚ? @
	lastIndex
ÚÚ@ I
]
ÚÚI J
;
ÚÚJ K

interfaces
ÛÛ "
[
ÛÛ" #
	lastIndex
ÛÛ# ,
]
ÛÛ, -
=
ÛÛ. /
interfaceType
ÛÛ0 =
;
ÛÛ= >
}
ÙÙ 
}
ıı 
}
ˆˆ 
foreach
˜˜ 
(
˜˜ 
var
˜˜ 
interfaceType
˜˜ &
in
˜˜' )

interfaces
˜˜* 4
)
˜˜4 5
{
¯¯ 
types
˘˘ 
.
˘˘ 
Add
˘˘ 
(
˘˘ 
interfaceType
˘˘ '
)
˘˘' (
;
˘˘( )
}
˙˙ 
}
˚˚ 	
TypeMap
¸¸ )
FindClosedGenericTypeMapFor
¸¸ +
(
¸¸+ ,
TypePair
¸¸, 4
typePair
¸¸5 =
)
¸¸= >
{
˝˝ 	
if
˛˛ 
(
˛˛ 
!
˛˛ 
_hasOpenMaps
˛˛ 
||
˛˛  
!
˛˛! "
typePair
˛˛" *
.
˛˛* +&
IsConstructedGenericType
˛˛+ C
)
˛˛C D
{
ˇˇ 
return
ÄÄ 
null
ÄÄ 
;
ÄÄ 
}
ÅÅ 
return
ÇÇ "
FindClosedGenericMap
ÇÇ '
(
ÇÇ' (
typePair
ÇÇ( 0
)
ÇÇ0 1
;
ÇÇ1 2
TypeMap
ÉÉ "
FindClosedGenericMap
ÉÉ (
(
ÉÉ( )
TypePair
ÉÉ) 1
typePair
ÉÉ2 :
)
ÉÉ: ;
{
ÑÑ 
var
ÖÖ 
genericTypePair
ÖÖ #
=
ÖÖ$ %
typePair
ÖÖ& .
.
ÖÖ. /(
GetTypeDefinitionIfGeneric
ÖÖ/ I
(
ÖÖI J
)
ÖÖJ K
;
ÖÖK L
var
ÜÜ 
userMap
ÜÜ 
=
ÜÜ 
FindTypeMapFor
áá "
(
áá" #
genericTypePair
áá# 2
.
áá2 3

SourceType
áá3 =
,
áá= >
typePair
áá? G
.
ááG H
DestinationType
ááH W
)
ááW X
??
ááY [
FindTypeMapFor
àà "
(
àà" #
typePair
àà# +
.
àà+ ,

SourceType
àà, 6
,
àà6 7
genericTypePair
àà8 G
.
ààG H
DestinationType
ààH W
)
ààW X
??
ààY [
FindTypeMapFor
ââ "
(
ââ" #
genericTypePair
ââ# 2
)
ââ2 3
;
ââ3 4"
TypeMapConfiguration
ää $
genericMapConfig
ää% 5
;
ää5 6

ProfileMap
ãã 
profile
ãã "
;
ãã" #
TypeMap
åå 
	cachedMap
åå !
;
åå! "
TypePair
çç 
closedTypes
çç $
;
çç$ %
if
éé 
(
éé 
userMap
éé 
!=
éé 
null
éé #
)
éé# $
{
èè 
genericMapConfig
êê $
=
êê% &
userMap
êê' .
.
êê. /
Profile
êê/ 6
.
êê6 7
GetGenericMap
êê7 D
(
êêD E
userMap
êêE L
.
êêL M
Types
êêM R
)
êêR S
;
êêS T
profile
ëë 
=
ëë 
userMap
ëë %
.
ëë% &
Profile
ëë& -
;
ëë- .
	cachedMap
íí 
=
íí 
null
íí  $
;
íí$ %
closedTypes
ìì 
=
ìì  !
typePair
ìì" *
;
ìì* +
}
îî 
else
ïï 
{
ññ 
var
óó 
foundGenericMap
óó '
=
óó( )
_resolvedMaps
óó* 7
.
óó7 8
TryGetValue
óó8 C
(
óóC D
genericTypePair
óóD S
,
óóS T
out
óóU X
	cachedMap
óóY b
)
óób c
&&
óód f
	cachedMap
óóg p
.
óóp q
Types
óóq v
.
óóv w(
ContainsGenericParametersóów ê
;óóê ë
if
òò 
(
òò 
!
òò 
foundGenericMap
òò (
)
òò( )
{
ôô 
return
öö 
	cachedMap
öö (
;
öö( )
}
õõ 
genericMapConfig
úú $
=
úú% &
	cachedMap
úú' 0
.
úú0 1
Profile
úú1 8
.
úú8 9
GetGenericMap
úú9 F
(
úúF G
	cachedMap
úúG P
.
úúP Q
Types
úúQ V
)
úúV W
;
úúW X
profile
ùù 
=
ùù 
	cachedMap
ùù '
.
ùù' (
Profile
ùù( /
;
ùù/ 0
closedTypes
ûû 
=
ûû  !
	cachedMap
ûû" +
.
ûû+ ,
Types
ûû, 1
.
ûû1 2
CloseGenericTypes
ûû2 C
(
ûûC D
typePair
ûûD L
)
ûûL M
;
ûûM N
}
üü 
if
†† 
(
†† 
genericMapConfig
†† $
==
††% '
null
††( ,
)
††, -
{
°° 
return
¢¢ 
null
¢¢ 
;
¢¢  
}
££ 
var
§§ 
typeMap
§§ 
=
§§ 
profile
§§ %
.
§§% &(
CreateClosedGenericTypeMap
§§& @
(
§§@ A
genericMapConfig
§§A Q
,
§§Q R
closedTypes
§§S ^
,
§§^ _
this
§§` d
)
§§d e
;
§§e f
	cachedMap
•• 
?
•• 
.
•• !
CopyInheritedMapsTo
•• .
(
••. /
typeMap
••/ 6
)
••6 7
;
••7 8
return
¶¶ 
typeMap
¶¶ 
;
¶¶ 
}
ßß 
}
®® 	
}
©© 
IEnumerable
™™ 
<
™™ 
IObjectMapper
™™ 
>
™™ "
IGlobalConfiguration
™™ 3
.
™™3 4

GetMappers
™™4 >
(
™™> ?
)
™™? @
=>
™™A C
_mappers
™™D L
;
™™L M
TypeMap
´´ 
[
´´ 
]
´´ "
IGlobalConfiguration
´´ "
.
´´" #!
GetIncludedTypeMaps
´´# 6
(
´´6 7!
IReadOnlyCollection
´´7 J
<
´´J K
TypePair
´´K S
>
´´S T
includedTypes
´´U b
)
´´b c
{
¨¨ 
if
≠≠ 

(
≠≠ 
includedTypes
≠≠ 
.
≠≠ 
Count
≠≠ 
==
≠≠  "
$num
≠≠# $
)
≠≠$ %
{
ÆÆ 	
return
ØØ 
[
ØØ 
]
ØØ 
;
ØØ 
}
∞∞ 	
var
±± 
typeMaps
±± 
=
±± 
new
±± 
TypeMap
±± "
[
±±" #
includedTypes
±±# 0
.
±±0 1
Count
±±1 6
]
±±6 7
;
±±7 8
int
≤≤ 
index
≤≤ 
=
≤≤ 
$num
≤≤ 
;
≤≤ 
foreach
≥≥ 
(
≥≥ 
var
≥≥ 
pair
≥≥ 
in
≥≥ 
includedTypes
≥≥ *
)
≥≥* +
{
¥¥ 	
typeMaps
µµ 
[
µµ 
index
µµ 
]
µµ 
=
µµ  
GetIncludedTypeMap
µµ 0
(
µµ0 1
pair
µµ1 5
)
µµ5 6
;
µµ6 7
index
∂∂ 
++
∂∂ 
;
∂∂ 
}
∑∑ 	
return
∏∏ 
typeMaps
∏∏ 
;
∏∏ 
}
ππ 
TypeMap
∫∫ "
IGlobalConfiguration
∫∫  
.
∫∫  ! 
GetIncludedTypeMap
∫∫! 3
(
∫∫3 4
Type
∫∫4 8

sourceType
∫∫9 C
,
∫∫C D
Type
∫∫E I
destinationType
∫∫J Y
)
∫∫Y Z
=>
∫∫[ ] 
GetIncludedTypeMap
∫∫^ p
(
∫∫p q
new
∫∫q t
(
∫∫t u

sourceType
∫∫u 
,∫∫ Ä
destinationType∫∫Å ê
)∫∫ê ë
)∫∫ë í
;∫∫í ì
TypeMap
ªª "
IGlobalConfiguration
ªª  
.
ªª  ! 
GetIncludedTypeMap
ªª! 3
(
ªª3 4
TypePair
ªª4 <
pair
ªª= A
)
ªªA B
=>
ªªC E 
GetIncludedTypeMap
ªªF X
(
ªªX Y
pair
ªªY ]
)
ªª] ^
;
ªª^ _
TypeMap
ºº  
GetIncludedTypeMap
ºº 
(
ºº 
TypePair
ºº '
pair
ºº( ,
)
ºº, -
{
ΩΩ 
var
ææ 
typeMap
ææ 
=
ææ 
FindTypeMapFor
ææ $
(
ææ$ %
pair
ææ% )
)
ææ) *
;
ææ* +
if
øø 

(
øø 
typeMap
øø 
!=
øø 
null
øø 
)
øø 
{
¿¿ 	
return
¡¡ 
typeMap
¡¡ 
;
¡¡ 
}
¬¬ 	
else
√√ 
{
ƒƒ 	
typeMap
≈≈ 
=
≈≈ 
ResolveTypeMap
≈≈ $
(
≈≈$ %
pair
≈≈% )
)
≈≈) *
;
≈≈* +
if
«« 
(
«« 
typeMap
«« 
?
«« 
.
«« 
Types
«« 
!=
«« !
pair
««" &
)
««& '
{
»» 
throw
…… 
TypeMap
…… 
.
…… !
MissingMapException
…… 1
(
……1 2
pair
……2 6
)
……6 7
;
……7 8
}
   
return
ÀÀ 
typeMap
ÀÀ 
;
ÀÀ 
}
ÃÃ 	
}
ÕÕ 
IObjectMapper
ŒŒ "
IGlobalConfiguration
ŒŒ &
.
ŒŒ& '

FindMapper
ŒŒ' 1
(
ŒŒ1 2
TypePair
ŒŒ2 :
types
ŒŒ; @
)
ŒŒ@ A
=>
ŒŒB D

FindMapper
ŒŒE O
(
ŒŒO P
types
ŒŒP U
)
ŒŒU V
;
ŒŒV W
IObjectMapper
œœ 

FindMapper
œœ 
(
œœ 
TypePair
œœ %
types
œœ& +
)
œœ+ ,
{
–– 
foreach
—— 
(
—— 
var
—— 
mapper
—— 
in
—— 
_mappers
—— '
)
——' (
{
““ 	
if
”” 
(
”” 
mapper
”” 
.
”” 
IsMatch
”” 
(
”” 
types
”” $
)
””$ %
)
””% &
{
‘‘ 
return
’’ 
mapper
’’ 
;
’’ 
}
÷÷ 
}
◊◊ 	
return
ÿÿ 
null
ÿÿ 
;
ÿÿ 
}
ŸŸ 
void
⁄⁄ "
IGlobalConfiguration
⁄⁄	 
.
⁄⁄ 
RegisterTypeMap
⁄⁄ -
(
⁄⁄- .
TypeMap
⁄⁄. 5
typeMap
⁄⁄6 =
)
⁄⁄= >
=>
⁄⁄? A
_configuredMaps
⁄⁄B Q
[
⁄⁄Q R
typeMap
⁄⁄R Y
.
⁄⁄Y Z
Types
⁄⁄Z _
]
⁄⁄_ `
=
⁄⁄a b
typeMap
⁄⁄c j
;
⁄⁄j k
void
€€ "
IGlobalConfiguration
€€	 
.
€€ (
AssertConfigurationIsValid
€€ 8
(
€€8 9
TypeMap
€€9 @
typeMap
€€A H
)
€€H I
=>
€€J L
	Validator
€€M V
(
€€V W
)
€€W X
.
€€X Y(
AssertConfigurationIsValid
€€Y s
(
€€s t
[
€€t u
typeMap
€€u |
]
€€| }
)
€€} ~
;
€€~ 
void
‹‹ "
IGlobalConfiguration
‹‹	 
.
‹‹ (
AssertConfigurationIsValid
‹‹ 8
(
‹‹8 9
string
‹‹9 ?
profileName
‹‹@ K
)
‹‹K L
{
›› 
if
ﬁﬁ 

(
ﬁﬁ 
Array
ﬁﬁ 
.
ﬁﬁ 

TrueForAll
ﬁﬁ 
(
ﬁﬁ 
Profiles
ﬁﬁ %
,
ﬁﬁ% &
x
ﬁﬁ' (
=>
ﬁﬁ) +
x
ﬁﬁ, -
.
ﬁﬁ- .
Name
ﬁﬁ. 2
!=
ﬁﬁ3 5
profileName
ﬁﬁ6 A
)
ﬁﬁA B
)
ﬁﬁB C
{
ﬂﬂ 	
throw
‡‡ 
new
‡‡ )
ArgumentOutOfRangeException
‡‡ 1
(
‡‡1 2
nameof
‡‡2 8
(
‡‡8 9
profileName
‡‡9 D
)
‡‡D E
,
‡‡E F
$"
‡‡G I
$str
‡‡I q
{
‡‡q r
profileName
‡‡r }
}
‡‡} ~
$str‡‡~ Ä
"‡‡Ä Å
)‡‡Å Ç
;‡‡Ç É
}
·· 	
	Validator
‚‚ 
(
‚‚ 
)
‚‚ 
.
‚‚ (
AssertConfigurationIsValid
‚‚ .
(
‚‚. /
_configuredMaps
‚‚/ >
.
‚‚> ?
Values
‚‚? E
.
‚‚E F
Where
‚‚F K
(
‚‚K L
typeMap
‚‚L S
=>
‚‚T V
typeMap
‚‚W ^
.
‚‚^ _
Profile
‚‚_ f
.
‚‚f g
Name
‚‚g k
==
‚‚l n
profileName
‚‚o z
)
‚‚z {
.
‚‚{ |
ToArray‚‚| É
(‚‚É Ñ
)‚‚Ñ Ö
)‚‚Ö Ü
;‚‚Ü á
}
„„ 
void
‰‰ "
IGlobalConfiguration
‰‰	 
.
‰‰ (
AssertConfigurationIsValid
‰‰ 8
<
‰‰8 9
TProfile
‰‰9 A
>
‰‰A B
(
‰‰B C
)
‰‰C D
=>
‰‰E G
this
‰‰H L
.
‰‰L M
Internal
‰‰M U
(
‰‰U V
)
‰‰V W
.
‰‰W X(
AssertConfigurationIsValid
‰‰X r
(
‰‰r s
typeof
‰‰s y
(
‰‰y z
TProfile‰‰z Ç
)‰‰Ç É
.‰‰É Ñ
FullName‰‰Ñ å
)‰‰å ç
;‰‰ç é
void
ÂÂ "
IGlobalConfiguration
ÂÂ	 
.
ÂÂ 
RegisterAsMap
ÂÂ +
(
ÂÂ+ ,"
TypeMapConfiguration
ÂÂ, @"
typeMapConfiguration
ÂÂA U
)
ÂÂU V
=>
ÂÂW Y
_resolvedMaps
ÊÊ 
[
ÊÊ "
typeMapConfiguration
ÊÊ *
.
ÊÊ* +
Types
ÊÊ+ 0
]
ÊÊ0 1
=
ÊÊ2 3 
GetIncludedTypeMap
ÊÊ4 F
(
ÊÊF G
new
ÊÊG J
(
ÊÊJ K"
typeMapConfiguration
ÊÊK _
.
ÊÊ_ `

SourceType
ÊÊ` j
,
ÊÊj k#
typeMapConfigurationÊÊl Ä
.ÊÊÄ Å'
DestinationTypeOverrideÊÊÅ ò
)ÊÊò ô
)ÊÊô ö
;ÊÊö õ
}ÁÁ 
structËË 
	LazyValue
ËË 
<
ËË 
T
ËË 
>
ËË 
(
ËË 
Func
ËË 
<
ËË 
T
ËË 
>
ËË 
factory
ËË #
)
ËË# $
where
ËË% *
T
ËË+ ,
:
ËË- .
class
ËË/ 4
{ÈÈ 
readonly
ÍÍ 
Func
ÍÍ 
<
ÍÍ 
T
ÍÍ 
>
ÍÍ 
_factory
ÍÍ 
=
ÍÍ 
factory
ÍÍ  '
;
ÍÍ' (
T
ÎÎ 
_value
ÎÎ 
=
ÎÎ 
null
ÎÎ 
;
ÎÎ 
public
ÏÏ 

T
ÏÏ 
Value
ÏÏ 
=>
ÏÏ 
LazyInitializer
ÏÏ %
.
ÏÏ% &
EnsureInitialized
ÏÏ& 7
(
ÏÏ7 8
ref
ÏÏ8 ;
_value
ÏÏ< B
,
ÏÏB C
_factory
ÏÏD L
)
ÏÏL M
;
ÏÏM N
}ÌÌ ï-
\C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\IProfileExpression.cs
	namespace 	

AutoMapper
 
; 
public 
	interface 
IProfileExpression #
{ 
void %
DisableConstructorMapping	 "
(" #
)# $
;$ %
IMappingExpression 
< 
TSource 
, 
TDestination  ,
>, -
	CreateMap. 7
<7 8
TSource8 ?
,? @
TDestinationA M
>M N
(N O
)O P
;P Q
IMappingExpression 
< 
TSource 
, 
TDestination  ,
>, -
	CreateMap. 7
<7 8
TSource8 ?
,? @
TDestinationA M
>M N
(N O

MemberListO Y

memberListZ d
)d e
;e f!
IProjectionExpression%% 
<%% 
TSource%% !
,%%! "
TDestination%%# /
>%%/ 0
CreateProjection%%1 A
<%%A B
TSource%%B I
,%%I J
TDestination%%K W
>%%W X
(%%X Y
)%%Y Z
;%%Z [!
IProjectionExpression// 
<// 
TSource// !
,//! "
TDestination//# /
>/// 0
CreateProjection//1 A
<//A B
TSource//B I
,//I J
TDestination//K W
>//W X
(//X Y

MemberList//Y c

memberList//d n
)//n o
;//o p
IMappingExpression88 
	CreateMap88  
(88  !
Type88! %

sourceType88& 0
,880 1
Type882 6
destinationType887 F
)88F G
;88G H
IMappingExpressionBB 
	CreateMapBB  
(BB  !
TypeBB! %

sourceTypeBB& 0
,BB0 1
TypeBB2 6
destinationTypeBB7 F
,BBF G

MemberListBBH R

memberListBBS ]
)BB] ^
;BB^ _
voidGG 
ClearPrefixesGG	 
(GG 
)GG 
;GG 
voidMM 
RecognizePrefixesMM	 
(MM 
paramsMM !
stringMM" (
[MM( )
]MM) *
prefixesMM+ 3
)MM3 4
;MM4 5
voidSS 
RecognizePostfixesSS	 
(SS 
paramsSS "
stringSS# )
[SS) *
]SS* +
	postfixesSS, 5
)SS5 6
;SS6 7
voidZZ 
ReplaceMemberNameZZ	 
(ZZ 
stringZZ !
originalZZ" *
,ZZ* +
stringZZ, 2
newValueZZ3 ;
)ZZ; <
;ZZ< =
void`` (
RecognizeDestinationPrefixes``	 %
(``% &
params``& ,
string``- 3
[``3 4
]``4 5
prefixes``6 >
)``> ?
;``? @
voidff )
RecognizeDestinationPostfixesff	 &
(ff& '
paramsff' -
stringff. 4
[ff4 5
]ff5 6
	postfixesff7 @
)ff@ A
;ffA B
voidll 
AddGlobalIgnorell	 
(ll 
stringll $
propertyNameStartingWithll  8
)ll8 9
;ll9 :
boolqq 
?qq 	&
AllowNullDestinationValuesqq
 $
{qq% &
getqq' *
;qq* +
setqq, /
;qq/ 0
}qq1 2
boolvv 
?vv 	 
AllowNullCollectionsvv
 
{vv  
getvv! $
;vv$ %
setvv& )
;vv) *
}vv+ ,
INamingConvention{{ (
SourceMemberNamingConvention{{ 2
{{{3 4
get{{5 8
;{{8 9
set{{: =
;{{= >
}{{? @
INamingConvention
ÄÄ /
!DestinationMemberNamingConvention
ÄÄ 7
{
ÄÄ8 9
get
ÄÄ: =
;
ÄÄ= >
set
ÄÄ? B
;
ÄÄB C
}
ÄÄD E
Func
ÇÇ 
<
ÇÇ 	
PropertyInfo
ÇÇ	 
,
ÇÇ 
bool
ÇÇ 
>
ÇÇ 
ShouldMapProperty
ÇÇ .
{
ÇÇ/ 0
get
ÇÇ1 4
;
ÇÇ4 5
set
ÇÇ6 9
;
ÇÇ9 :
}
ÇÇ; <
Func
ÉÉ 
<
ÉÉ 	
	FieldInfo
ÉÉ	 
,
ÉÉ 
bool
ÉÉ 
>
ÉÉ 
ShouldMapField
ÉÉ (
{
ÉÉ) *
get
ÉÉ+ .
;
ÉÉ. /
set
ÉÉ0 3
;
ÉÉ3 4
}
ÉÉ5 6
Func
ÑÑ 
<
ÑÑ 	

MethodInfo
ÑÑ	 
,
ÑÑ 
bool
ÑÑ 
>
ÑÑ 
ShouldMapMethod
ÑÑ *
{
ÑÑ+ ,
get
ÑÑ- 0
;
ÑÑ0 1
set
ÑÑ2 5
;
ÑÑ5 6
}
ÑÑ7 8
Func
ÖÖ 
<
ÖÖ 	
ConstructorInfo
ÖÖ	 
,
ÖÖ 
bool
ÖÖ 
>
ÖÖ "
ShouldUseConstructor
ÖÖ  4
{
ÖÖ5 6
get
ÖÖ7 :
;
ÖÖ: ;
set
ÖÖ< ?
;
ÖÖ? @
}
ÖÖA B
string
áá 

ProfileName
áá 
{
áá 
get
áá 
;
áá 
}
áá 
void
çç +
IncludeSourceExtensionMethods
çç	 &
(
çç& '
Type
çç' +
type
çç, 0
)
çç0 1
;
çç1 2
List
íí 
<
íí 	+
ValueTransformerConfiguration
íí	 &
>
íí& '
ValueTransformers
íí( 9
{
íí: ;
get
íí< ?
;
íí? @
}
ííA B
}ìì 
publicóó 
enum
óó 

MemberList
óó 
{òò 
Destination
úú 
=
úú 
$num
úú 
,
úú 
Source
°° 

=
°° 
$num
°° 
,
°° 
None
¶¶ 
=
¶¶	 

$num
¶¶ 
}ßß ã"
[C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\INamingConvention.cs
	namespace 	

AutoMapper
 
; 
public 
	interface 
INamingConvention "
{ 
string 

[
 
] 
Split 
( 
string 
input 
)  
;  !
string		 

SeparatorCharacter		 
{		 
get		  #
;		# $
}		% &
}

 
public 
sealed 
class &
ExactMatchNamingConvention .
:/ 0
INamingConvention1 B
{ 
public 

static 
readonly &
ExactMatchNamingConvention 5
Instance6 >
=? @
newA D
(D E
)E F
;F G
public 

string 
[ 
] 
Split 
( 
string  
_! "
)" #
=>$ &
[' (
]( )
;) *
public 

string 
SeparatorCharacter $
=>% '
null( ,
;, -
} 
public 
sealed 
class &
PascalCaseNamingConvention .
:/ 0
INamingConvention1 B
{ 
public 

static 
readonly &
PascalCaseNamingConvention 5
Instance6 >
=? @
newA D
(D E
)E F
;F G
public 

string 
SeparatorCharacter $
=>% '
$str( *
;* +
public 

string 
[ 
] 
Split 
( 
string  
input! &
)& '
{ 
List 
< 
string 
> 
result 
= 
null "
;" #
int 
lower 
= 
$num 
; 
for 
( 
int 
index 
= 
$num 
; 
index  
<! "
input# (
.( )
Length) /
;/ 0
index1 6
++6 8
)8 9
{ 	
if 
( 
char 
. 
IsUpper 
( 
input "
[" #
index# (
]( )
)) *
)* +
{ 
result 
??= 
[ 
] 
; 
result 
. 
Add 
( 
input  
[  !
lower! &
..& (
index( -
]- .
). /
;/ 0
lower 
= 
index 
; 
}   
}!! 	
if"" 

("" 
result"" 
=="" 
null"" 
)"" 
{## 	
return$$ 
[$$ 
]$$ 
;$$ 
}%% 	
result&& 
.&& 
Add&& 
(&& 
input&& 
[&& 
lower&& 
..&&  
]&&  !
)&&! "
;&&" #
return'' 
['' 
..'' 
result'' 
]'' 
;'' 
}(( 
})) 
public** 
sealed** 
class** +
LowerUnderscoreNamingConvention** 3
:**4 5
INamingConvention**6 G
{++ 
public,, 

static,, 
readonly,, +
LowerUnderscoreNamingConvention,, :
Instance,,; C
=,,D E
new,,F I
(,,I J
),,J K
;,,K L
public-- 

string-- 
SeparatorCharacter-- $
=>--% '
$str--( +
;--+ ,
public.. 

string.. 
[.. 
].. 
Split.. 
(.. 
string..  
input..! &
)..& '
=>..( *
input..+ 0
...0 1
Split..1 6
(..6 7
$char..7 :
,..: ;
StringSplitOptions..< N
...N O
RemoveEmptyEntries..O a
)..a b
;..b c
}// ¢z
hC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\IMemberConfigurationExpression.cs
	namespace 	

AutoMapper
 
; 
public		 
	interface		 *
IMemberConfigurationExpression		 /
<		/ 0
TSource		0 7
,		7 8
TDestination		9 E
,		E F
TMember		G N
>		N O
:		P Q*
IProjectionMemberConfiguration		R p
<		p q
TSource		q x
,		x y
TDestination			z Ü
,
		Ü á
TMember
		à è
>
		è ê
{

 
void 
MapAtRuntime	 
( 
) 
; 
void 
MapFrom	 
< 
TValueResolver 
>  
(  !
)! "
where# (
TValueResolver) 7
:8 9
IValueResolver: H
<H I
TSourceI P
,P Q
TDestinationR ^
,^ _
TMember` g
>g h
;h i
void 
MapFrom	 
< 
TValueResolver 
,  
TSourceMember! .
>. /
(/ 0

Expression0 :
<: ;
Func; ?
<? @
TSource@ G
,G H
TSourceMemberI V
>V W
>W X
sourceMemberY e
)e f
where 
TValueResolver 
:  
IMemberValueResolver 3
<3 4
TSource4 ;
,; <
TDestination= I
,I J
TSourceMemberK X
,X Y
TMemberZ a
>a b
;b c
void%% 
MapFrom%%	 
<%% 
TValueResolver%% 
,%%  
TSourceMember%%! .
>%%. /
(%%/ 0
string%%0 6
sourceMemberName%%7 G
)%%G H
where&& 
TValueResolver&& 
:&&  
IMemberValueResolver&& 3
<&&3 4
TSource&&4 ;
,&&; <
TDestination&&= I
,&&I J
TSourceMember&&K X
,&&X Y
TMember&&Z a
>&&a b
;&&b c
void,, 
MapFrom,,	 
(,, 
IValueResolver,, 
<,,  
TSource,,  '
,,,' (
TDestination,,) 5
,,,5 6
TMember,,7 >
>,,> ?
valueResolver,,@ M
),,M N
;,,N O
void33 
MapFrom33	 
<33 
TSourceMember33 
>33 
(33   
IMemberValueResolver33  4
<334 5
TSource335 <
,33< =
TDestination33> J
,33J K
TSourceMember33L Y
,33Y Z
TMember33[ b
>33b c
valueResolver33d q
,33q r

Expression33s }
<33} ~
Func	33~ Ç
<
33Ç É
TSource
33É ä
,
33ä ã
TSourceMember
33å ô
>
33ô ö
>
33ö õ
sourceMember
33ú ®
)
33® ©
;
33© ™
void99 
MapFrom99	 
<99 
TResult99 
>99 
(99 
Func99 
<99 
TSource99 &
,99& '
TDestination99( 4
,994 5
TResult996 =
>99= >
mappingFunction99? N
)99N O
;99O P
void?? 
MapFrom??	 
<?? 
TResult?? 
>?? 
(?? 
Func?? 
<?? 
TSource?? &
,??& '
TDestination??( 4
,??4 5
TMember??6 =
,??= >
TResult??? F
>??F G
mappingFunction??H W
)??W X
;??X Y
voidEE 
MapFromEE	 
<EE 
TResultEE 
>EE 
(EE 
FuncEE 
<EE 
TSourceEE &
,EE& '
TDestinationEE( 4
,EE4 5
TMemberEE6 =
,EE= >
ResolutionContextEE? P
,EEP Q
TResultEER Y
>EEY Z
mappingFunctionEE[ j
)EEj k
;EEk l
voidJJ 
MapFromJJ	 
(JJ 
stringJJ 
sourceMembersPathJJ )
)JJ) *
;JJ* +
voidOO 
SetMappingOrderOO	 
(OO 
intOO 
mappingOrderOO )
)OO) *
;OO* +
voidSS $
DoNotUseDestinationValueSS	 !
(SS! "
)SS" #
;SS# $
voidWW 
UseDestinationValueWW	 
(WW 
)WW 
;WW 
void\\ 
	Condition\\	 
(\\ 
Func\\ 
<\\ 
TSource\\ 
,\\  
TDestination\\! -
,\\- .
TMember\\/ 6
,\\6 7
TMember\\8 ?
,\\? @
ResolutionContext\\A R
,\\R S
bool\\T X
>\\X Y
	condition\\Z c
)\\c d
;\\d e
voidaa 
	Conditionaa	 
(aa 
Funcaa 
<aa 
TSourceaa 
,aa  
TDestinationaa! -
,aa- .
TMemberaa/ 6
,aa6 7
TMemberaa8 ?
,aa? @
boolaaA E
>aaE F
	conditionaaG P
)aaP Q
;aaQ R
voidff 
	Conditionff	 
(ff 
Funcff 
<ff 
TSourceff 
,ff  
TDestinationff! -
,ff- .
TMemberff/ 6
,ff6 7
boolff8 <
>ff< =
	conditionff> G
)ffG H
;ffH I
voidkk 
	Conditionkk	 
(kk 
Funckk 
<kk 
TSourcekk 
,kk  
TDestinationkk! -
,kk- .
boolkk/ 3
>kk3 4
	conditionkk5 >
)kk> ?
;kk? @
voidpp 
	Conditionpp	 
(pp 
Funcpp 
<pp 
TSourcepp 
,pp  
boolpp! %
>pp% &
	conditionpp' 0
)pp0 1
;pp1 2
voiduu 
PreConditionuu	 
(uu 
Funcuu 
<uu 
TSourceuu "
,uu" #
booluu$ (
>uu( )
	conditionuu* 3
)uu3 4
;uu4 5
voidzz 
PreConditionzz	 
(zz 
Funczz 
<zz 
ResolutionContextzz ,
,zz, -
boolzz. 2
>zz2 3
	conditionzz4 =
)zz= >
;zz> ?
void 
PreCondition	 
( 
Func 
< 
TSource "
," #
ResolutionContext$ 5
,5 6
bool7 ;
>; <
	condition= F
)F G
;G H
void
ÑÑ 
PreCondition
ÑÑ	 
(
ÑÑ 
Func
ÑÑ 
<
ÑÑ 
TSource
ÑÑ "
,
ÑÑ" #
TDestination
ÑÑ$ 0
,
ÑÑ0 1
ResolutionContext
ÑÑ2 C
,
ÑÑC D
bool
ÑÑE I
>
ÑÑI J
	condition
ÑÑK T
)
ÑÑT U
;
ÑÑU V

MemberInfo
àà 
DestinationMember
àà  
{
àà! "
get
àà# &
;
àà& '
}
àà( )
void
íí 
ConvertUsing
íí	 
<
íí 
TValueConverter
íí %
,
íí% &
TSourceMember
íí' 4
>
íí4 5
(
íí5 6
)
íí6 7
where
íí8 =
TValueConverter
íí> M
:
ííN O
IValueConverter
ííP _
<
íí_ `
TSourceMember
íí` m
,
íím n
TMember
íío v
>
íív w
;
ííw x
void
ùù 
ConvertUsing
ùù	 
<
ùù 
TValueConverter
ùù %
,
ùù% &
TSourceMember
ùù' 4
>
ùù4 5
(
ùù5 6

Expression
ùù6 @
<
ùù@ A
Func
ùùA E
<
ùùE F
TSource
ùùF M
,
ùùM N
TSourceMember
ùùO \
>
ùù\ ]
>
ùù] ^
sourceMember
ùù_ k
)
ùùk l
where
ùùm r
TValueConverterùùs Ç
:ùùÉ Ñ
IValueConverterùùÖ î
<ùùî ï
TSourceMemberùùï ¢
,ùù¢ £
TMemberùù§ ´
>ùù´ ¨
;ùù¨ ≠
void
®® 
ConvertUsing
®®	 
<
®® 
TValueConverter
®® %
,
®®% &
TSourceMember
®®' 4
>
®®4 5
(
®®5 6
string
®®6 <
sourceMemberName
®®= M
)
®®M N
where
®®O T
TValueConverter
®®U d
:
®®e f
IValueConverter
®®g v
<
®®v w
TSourceMember®®w Ñ
,®®Ñ Ö
TMember®®Ü ç
>®®ç é
;®®é è
void
≤≤ 
ConvertUsing
≤≤	 
<
≤≤ 
TSourceMember
≤≤ #
>
≤≤# $
(
≤≤$ %
IValueConverter
≤≤% 4
<
≤≤4 5
TSourceMember
≤≤5 B
,
≤≤B C
TMember
≤≤D K
>
≤≤K L
valueConverter
≤≤M [
)
≤≤[ \
;
≤≤\ ]
void
ΩΩ 
ConvertUsing
ΩΩ	 
<
ΩΩ 
TSourceMember
ΩΩ #
>
ΩΩ# $
(
ΩΩ$ %
IValueConverter
ΩΩ% 4
<
ΩΩ4 5
TSourceMember
ΩΩ5 B
,
ΩΩB C
TMember
ΩΩD K
>
ΩΩK L
valueConverter
ΩΩM [
,
ΩΩ[ \

Expression
ΩΩ] g
<
ΩΩg h
Func
ΩΩh l
<
ΩΩl m
TSource
ΩΩm t
,
ΩΩt u
TSourceMemberΩΩv É
>ΩΩÉ Ñ
>ΩΩÑ Ö
sourceMemberΩΩÜ í
)ΩΩí ì
;ΩΩì î
void
»» 
ConvertUsing
»»	 
<
»» 
TSourceMember
»» #
>
»»# $
(
»»$ %
IValueConverter
»»% 4
<
»»4 5
TSourceMember
»»5 B
,
»»B C
TMember
»»D K
>
»»K L
valueConverter
»»M [
,
»»[ \
string
»»] c
sourceMemberName
»»d t
)
»»t u
;
»»u v
}…… 
publicÕÕ 
	interface
ÕÕ ,
IMemberConfigurationExpression
ÕÕ /
:
ÕÕ0 1,
IMemberConfigurationExpression
ÕÕ2 P
<
ÕÕP Q
object
ÕÕQ W
,
ÕÕW X
object
ÕÕY _
,
ÕÕ_ `
object
ÕÕa g
>
ÕÕg h
{ŒŒ 
void
‘‘ 
MapFrom
‘‘	 
(
‘‘ 
Type
‘‘ 
valueResolverType
‘‘ '
)
‘‘' (
;
‘‘( )
void
€€ 
MapFrom
€€	 
(
€€ 
Type
€€ 
valueResolverType
€€ '
,
€€' (
string
€€) /
sourceMemberName
€€0 @
)
€€@ A
;
€€A B
void
‚‚ 
MapFrom
‚‚	 
<
‚‚ 
TSource
‚‚ 
,
‚‚ 
TDestination
‚‚ &
,
‚‚& '
TSourceMember
‚‚( 5
,
‚‚5 6
TDestMember
‚‚7 B
>
‚‚B C
(
‚‚C D"
IMemberValueResolver
‚‚D X
<
‚‚X Y
TSource
‚‚Y `
,
‚‚` a
TDestination
‚‚b n
,
‚‚n o
TSourceMember
‚‚p }
,
‚‚} ~
TDestMember‚‚ ä
>‚‚ä ã
valueResolver‚‚å ô
,‚‚ô ö
string‚‚õ ° 
sourceMemberName‚‚¢ ≤
)‚‚≤ ≥
;‚‚≥ ¥
void
ÎÎ 
ConvertUsing
ÎÎ	 
(
ÎÎ 
Type
ÎÎ  
valueConverterType
ÎÎ -
)
ÎÎ- .
;
ÎÎ. /
void
ıı 
ConvertUsing
ıı	 
(
ıı 
Type
ıı  
valueConverterType
ıı -
,
ıı- .
string
ıı/ 5
sourceMemberName
ıı6 F
)
ııF G
;
ııG H
void
ÅÅ 
ConvertUsing
ÅÅ	 
<
ÅÅ 
TSourceMember
ÅÅ #
,
ÅÅ# $ 
TDestinationMember
ÅÅ% 7
>
ÅÅ7 8
(
ÅÅ8 9
IValueConverter
ÅÅ9 H
<
ÅÅH I
TSourceMember
ÅÅI V
,
ÅÅV W 
TDestinationMember
ÅÅX j
>
ÅÅj k
valueConverter
ÅÅl z
,
ÅÅz {
stringÅÅ| Ç 
sourceMemberNameÅÅÉ ì
)ÅÅì î
;ÅÅî ï
}ÇÇ 
publicââ 
	interface
ââ ,
IProjectionMemberConfiguration
ââ /
<
ââ/ 0
TSource
ââ0 7
,
ââ7 8
TDestination
ââ9 E
,
ââE F
TMember
ââG N
>
ââN O
{ää 
void
èè 
NullSubstitute
èè	 
(
èè 
object
èè 
nullSubstitute
èè -
)
èè- .
;
èè. /
void
ïï 
MapFrom
ïï	 
<
ïï 
TSourceMember
ïï 
>
ïï 
(
ïï  

Expression
ïï  *
<
ïï* +
Func
ïï+ /
<
ïï/ 0
TSource
ïï0 7
,
ïï7 8
TSourceMember
ïï9 F
>
ïïF G
>
ïïG H
mapExpression
ïïI V
)
ïïV W
;
ïïW X
void
ôô 
Ignore
ôô	 
(
ôô 
)
ôô 
;
ôô 
void
ùù 
	AllowNull
ùù	 
(
ùù 
)
ùù 
;
ùù 
void
°° 
DoNotAllowNull
°°	 
(
°° 
)
°° 
;
°° 
void
¶¶ 
ExplicitExpansion
¶¶	 
(
¶¶ 
bool
¶¶ 
value
¶¶  %
=
¶¶& '
true
¶¶( ,
)
¶¶, -
;
¶¶- .
void
´´ 
AddTransform
´´	 
(
´´ 

Expression
´´  
<
´´  !
Func
´´! %
<
´´% &
TMember
´´& -
,
´´- .
TMember
´´/ 6
>
´´6 7
>
´´7 8
transformer
´´9 D
)
´´D E
;
´´E F
}¨¨ 
public≤≤ 
	interface
≤≤ 
IValueConverter
≤≤  
<
≤≤  !
in
≤≤! #
TSourceMember
≤≤$ 1
,
≤≤1 2
out
≤≤3 6 
TDestinationMember
≤≤7 I
>
≤≤I J
{≥≥  
TDestinationMember
∫∫ 
Convert
∫∫ 
(
∫∫ 
TSourceMember
∫∫ ,
sourceMember
∫∫- 9
,
∫∫9 :
ResolutionContext
∫∫; L
context
∫∫M T
)
∫∫T U
;
∫∫U V
}ªª 
publicøø 
	interface
øø 
IValueResolver
øø 
<
øø  
in
øø  "
TSource
øø# *
,
øø* +
in
øø, .
TDestination
øø/ ;
,
øø; <
TDestMember
øø= H
>
øøH I
{¿¿ 
TDestMember
…… 
Resolve
…… 
(
…… 
TSource
…… 
source
……  &
,
……& '
TDestination
……( 4
destination
……5 @
,
……@ A
TDestMember
……B M

destMember
……N X
,
……X Y
ResolutionContext
……Z k
context
……l s
)
……s t
;
……t u
}   
publicœœ 
	interface
œœ "
IMemberValueResolver
œœ %
<
œœ% &
in
œœ& (
TSource
œœ) 0
,
œœ0 1
in
œœ2 4
TDestination
œœ5 A
,
œœA B
in
œœC E
TSourceMember
œœF S
,
œœS T
TDestMember
œœU `
>
œœ` a
{–– 
TDestMember
⁄⁄ 
Resolve
⁄⁄ 
(
⁄⁄ 
TSource
⁄⁄ 
source
⁄⁄  &
,
⁄⁄& '
TDestination
⁄⁄( 4
destination
⁄⁄5 @
,
⁄⁄@ A
TSourceMember
⁄⁄B O
sourceMember
⁄⁄P \
,
⁄⁄\ ]
TDestMember
⁄⁄^ i

destMember
⁄⁄j t
,
⁄⁄t u 
ResolutionContext⁄⁄v á
context⁄⁄à è
)⁄⁄è ê
;⁄⁄ê ë
}€€ …0
bC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\IMappingOperationOptions.cs
	namespace 	

AutoMapper
 
; 
public 
	interface $
IMappingOperationOptions )
{ 
Func 
< 	
Type	 
, 
object 
> 
ServiceCtor "
{# $
get% (
;( )
}* +
void "
ConstructServicesUsing	 
(  
Func  $
<$ %
Type% )
,) *
object+ 1
>1 2
constructor3 >
)> ?
;? @
object 

State 
{ 
get 
; 
set 
; 
} 
StringDictionary 
Items 
{ 
get  
;  !
}" #
void 
	BeforeMap	 
( 
Action 
< 
object  
,  !
object" (
>( )
beforeFunction* 8
)8 9
;9 :
void!! 
AfterMap!!	 
(!! 
Action!! 
<!! 
object!! 
,!!  
object!!! '
>!!' (
afterFunction!!) 6
)!!6 7
;!!7 8
}"" 
public## 
	interface## $
IMappingOperationOptions## )
<##) *
TSource##* 1
,##1 2
TDestination##3 ?
>##? @
:##A B$
IMappingOperationOptions##C [
{$$ 
void)) 
	BeforeMap))	 
()) 
Action)) 
<)) 
TSource)) !
,))! "
TDestination))# /
>))/ 0
beforeFunction))1 ?
)))? @
;))@ A
void.. 
AfterMap..	 
(.. 
Action.. 
<.. 
TSource..  
,..  !
TDestination.." .
>... /
afterFunction..0 =
)..= >
;..> ?
}// 
public00 
sealed00 
class00 #
MappingOperationOptions00 +
<00+ ,
TSource00, 3
,003 4
TDestination005 A
>00A B
(00B C
Func00C G
<00G H
Type00H L
,00L M
object00N T
>00T U
serviceCtor00V a
)00a b
:00c d$
IMappingOperationOptions00e }
<00} ~
TSource	00~ Ö
,
00Ö Ü
TDestination
00á ì
>
00ì î
{11 
public22 

Func22 
<22 
Type22 
,22 
object22 
>22 
ServiceCtor22 )
{22* +
get22, /
;22/ 0
private221 8
set229 <
;22< =
}22> ?
=22@ A
serviceCtor22B M
;22M N
public33 

StringDictionary33 
Items33 !
=>33" $
(33% &
StringDictionary33& 6
)336 7
(338 9
State339 >
??=33? B
new33C F
StringDictionary33G W
(33W X
)33X Y
)33Y Z
;33Z [
public44 

object44 
State44 
{44 
get44 
;44 
set44 "
;44" #
}44$ %
public55 

Action55 
<55 
TSource55 
,55 
TDestination55 '
>55' (
BeforeMapAction55) 8
{559 :
get55; >
;55> ?
private55@ G
set55H K
;55K L
}55M N
public66 

Action66 
<66 
TSource66 
,66 
TDestination66 '
>66' (
AfterMapAction66) 7
{668 9
get66: =
;66= >
private66? F
set66G J
;66J K
}66L M
public77 

void77 
	BeforeMap77 
(77 
Action77  
<77  !
TSource77! (
,77( )
TDestination77* 6
>776 7
beforeFunction778 F
)77F G
=>77H J
BeforeMapAction77K Z
=77[ \
beforeFunction77] k
;77k l
public88 

void88 
AfterMap88 
(88 
Action88 
<88  
TSource88  '
,88' (
TDestination88) 5
>885 6
afterFunction887 D
)88D E
=>88F H
AfterMapAction88I W
=88X Y
afterFunction88Z g
;88g h
public99 

void99 "
ConstructServicesUsing99 &
(99& '
Func99' +
<99+ ,
Type99, 0
,990 1
object992 8
>998 9
constructor99: E
)99E F
{:: 
var;; 
ctor;; 
=;; 
ServiceCtor;; 
;;; 
ServiceCtor<< 
=<< 
t<< 
=><< 
constructor<< &
(<<& '
t<<' (
)<<( )
??<<* ,
ctor<<- 1
(<<1 2
t<<2 3
)<<3 4
;<<4 5
}== 
void>> $
IMappingOperationOptions>>	 !
.>>! "
	BeforeMap>>" +
(>>+ ,
Action>>, 2
<>>2 3
object>>3 9
,>>9 :
object>>; A
>>>A B
beforeFunction>>C Q
)>>Q R
=>>>S U
BeforeMapAction>>V e
=>>f g
(>>h i
s>>i j
,>>j k
d>>l m
)>>m n
=>>>o q
beforeFunction	>>r Ä
(
>>Ä Å
s
>>Å Ç
,
>>Ç É
d
>>Ñ Ö
)
>>Ö Ü
;
>>Ü á
void?? $
IMappingOperationOptions??	 !
.??! "
AfterMap??" *
(??* +
Action??+ 1
<??1 2
object??2 8
,??8 9
object??: @
>??@ A
afterFunction??B O
)??O P
=>??Q S
AfterMapAction??T b
=??c d
(??e f
s??f g
,??g h
d??i j
)??j k
=>??l n
afterFunction??o |
(??| }
s??} ~
,??~ 
d
??Ä Å
)
??Å Ç
;
??Ç É
}@@ ⁄G
`C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\IMappingExpressionBase.cs
	namespace 	

AutoMapper
 
; 
public 
	interface %
IProjectionExpressionBase *
<* +
TSource+ 2
,2 3
TDestination4 @
,@ A
outB E
TMappingExpressionF X
>X Y
whereZ _
TMappingExpression` r
:s t&
IProjectionExpressionBase	u é
<
é è
TSource
è ñ
,
ñ ó
TDestination
ò §
,
§ • 
TMappingExpression
¶ ∏
>
∏ π
{ 
Features 
< 
IMappingFeature 
> 
Features &
{' (
get) ,
;, -
}. /
TMappingExpression 
MaxDepth 
(  
int  #
depth$ )
)) *
;* +
List 
< 	)
ValueTransformerConfiguration	 &
>& '
ValueTransformers( 9
{: ;
get< ?
;? @
}A B
TMappingExpression 
ValidateMemberList )
() *

MemberList* 4

memberList5 ?
)? @
;@ A
TMappingExpression$$ 
ConstructUsing$$ %
($$% &

Expression$$& 0
<$$0 1
Func$$1 5
<$$5 6
TSource$$6 =
,$$= >
TDestination$$? K
>$$K L
>$$L M
ctor$$N R
)$$R S
;$$S T
TMappingExpression++ 
ForCtorParam++ #
(++# $
string++$ *
ctorParamName+++ 8
,++8 9
Action++: @
<++@ A-
!ICtorParamConfigurationExpression++A b
<++b c
TSource++c j
>++j k
>++k l
paramOptions++m y
)++y z
;++z {
void00 
ConvertUsing00	 
(00 

Expression00  
<00  !
Func00! %
<00% &
TSource00& -
,00- .
TDestination00/ ;
>00; <
>00< =
mappingExpression00> O
)00O P
;00P Q
}11 
public88 
	interface88 "
IMappingExpressionBase88 '
<88' (
TSource88( /
,88/ 0
TDestination881 =
,88= >
out88? B
TMappingExpression88C U
>88U V
:88W X%
IProjectionExpressionBase88Y r
<88r s
TSource88s z
,88z {
TDestination	88| à
,
88à â 
TMappingExpression
88ä ú
>
88ú ù
where99 	
TMappingExpression99
 
:99 "
IMappingExpressionBase99 5
<995 6
TSource996 =
,99= >
TDestination99? K
,99K L
TMappingExpression99M _
>99_ `
{:: 
TMappingExpression?? !
DisableCtorValidation?? ,
(??, -
)??- .
;??. /
TMappingExpressionDD (
ConstructUsingServiceLocatorDD 3
(DD3 4
)DD4 5
;DD5 6
TMappingExpressionII 
PreserveReferencesII )
(II) *
)II* +
;II+ ,
TMappingExpressionPP 
	BeforeMapPP  
(PP  !
ActionPP! '
<PP' (
TSourcePP( /
,PP/ 0
TDestinationPP1 =
>PP= >
beforeFunctionPP? M
)PPM N
;PPN O
TMappingExpressionWW 
	BeforeMapWW  
(WW  !
ActionWW! '
<WW' (
TSourceWW( /
,WW/ 0
TDestinationWW1 =
,WW= >
ResolutionContextWW? P
>WWP Q
beforeFunctionWWR `
)WW` a
;WWa b
TMappingExpression^^ 
	BeforeMap^^  
<^^  !
TMappingAction^^! /
>^^/ 0
(^^0 1
)^^1 2
where^^3 8
TMappingAction^^9 G
:^^H I
IMappingAction^^J X
<^^X Y
TSource^^Y `
,^^` a
TDestination^^b n
>^^n o
;^^o p
TMappingExpressionee 
AfterMapee 
(ee  
Actionee  &
<ee& '
TSourceee' .
,ee. /
TDestinationee0 <
>ee< =
afterFunctionee> K
)eeK L
;eeL M
TMappingExpressionll 
AfterMapll 
(ll  
Actionll  &
<ll& '
TSourcell' .
,ll. /
TDestinationll0 <
,ll< =
ResolutionContextll> O
>llO P
afterFunctionllQ ^
)ll^ _
;ll_ `
TMappingExpressionss 
AfterMapss 
<ss  
TMappingActionss  .
>ss. /
(ss/ 0
)ss0 1
wheress2 7
TMappingActionss8 F
:ssG H
IMappingActionssI W
<ssW X
TSourcessX _
,ss_ `
TDestinationssa m
>ssm n
;ssn o
TMappingExpressionxx 
IncludeAllDerivedxx (
(xx( )
)xx) *
;xx* +
TMappingExpression 
Include 
( 
Type #
derivedSourceType$ 5
,5 6
Type7 ;"
derivedDestinationType< R
)R S
;S T 
TMappingExpression
ÜÜ 
IncludeBase
ÜÜ "
(
ÜÜ" #
Type
ÜÜ# '

sourceBase
ÜÜ( 2
,
ÜÜ2 3
Type
ÜÜ4 8
destinationBase
ÜÜ9 H
)
ÜÜH I
;
ÜÜI J 
TMappingExpression
çç 
ForSourceMember
çç &
(
çç& '
string
çç' -
sourceMemberName
çç. >
,
çç> ?
Action
çç@ F
<
ççF G2
$ISourceMemberConfigurationExpression
ççG k
>
ççk l
memberOptions
ççm z
)
ççz {
;
çç{ | 
TMappingExpression
íí 9
+IgnoreAllPropertiesWithAnInaccessibleSetter
íí B
(
ííB C
)
ííC D
;
ííD E 
TMappingExpression
óó ?
1IgnoreAllSourcePropertiesWithAnInaccessibleSetter
óó H
(
óóH I
)
óóI J
;
óóJ K 
TMappingExpression
ûû 
ConstructUsing
ûû %
(
ûû% &
Func
ûû& *
<
ûû* +
TSource
ûû+ 2
,
ûû2 3
ResolutionContext
ûû4 E
,
ûûE F
TDestination
ûûG S
>
ûûS T
ctor
ûûU Y
)
ûûY Z
;
ûûZ [
void
££ 
As
££	 
(
££ 
Type
££ 
typeOverride
££ 
)
££ 
;
££  
TMappingExpression
®® 
AsProxy
®® 
(
®® 
)
®®  
;
®®  !
void
ÆÆ 
ConvertUsing
ÆÆ	 
(
ÆÆ 
Type
ÆÆ 
typeConverterType
ÆÆ ,
)
ÆÆ, -
;
ÆÆ- .
void
¥¥ 
ConvertUsing
¥¥	 
(
¥¥ 
Func
¥¥ 
<
¥¥ 
TSource
¥¥ "
,
¥¥" #
TDestination
¥¥$ 0
,
¥¥0 1
TDestination
¥¥2 >
>
¥¥> ?
mappingFunction
¥¥@ O
)
¥¥O P
;
¥¥P Q
void
∫∫ 
ConvertUsing
∫∫	 
(
∫∫ 
Func
∫∫ 
<
∫∫ 
TSource
∫∫ "
,
∫∫" #
TDestination
∫∫$ 0
,
∫∫0 1
ResolutionContext
∫∫2 C
,
∫∫C D
TDestination
∫∫E Q
>
∫∫Q R
mappingFunction
∫∫S b
)
∫∫b c
;
∫∫c d
void
¿¿ 
ConvertUsing
¿¿	 
(
¿¿ 
ITypeConverter
¿¿ $
<
¿¿$ %
TSource
¿¿% ,
,
¿¿, -
TDestination
¿¿. :
>
¿¿: ;
	converter
¿¿< E
)
¿¿E F
;
¿¿F G
void
∆∆ 
ConvertUsing
∆∆	 
<
∆∆ 
TTypeConverter
∆∆ $
>
∆∆$ %
(
∆∆% &
)
∆∆& '
where
∆∆( -
TTypeConverter
∆∆. <
:
∆∆= >
ITypeConverter
∆∆? M
<
∆∆M N
TSource
∆∆N U
,
∆∆U V
TDestination
∆∆W c
>
∆∆c d
;
∆∆d e
}«« 
publicÕÕ 
	interface
ÕÕ 
IMappingAction
ÕÕ 
<
ÕÕ  
in
ÕÕ  "
TSource
ÕÕ# *
,
ÕÕ* +
in
ÕÕ, .
TDestination
ÕÕ/ ;
>
ÕÕ; <
{ŒŒ 
void
’’ 
Process
’’	 
(
’’ 
TSource
’’ 
source
’’ 
,
’’  
TDestination
’’! -
destination
’’. 9
,
’’9 :
ResolutionContext
’’; L
context
’’M T
)
’’T U
;
’’U V
}÷÷ 
public‹‹ 
	interface
‹‹ 
ITypeConverter
‹‹ 
<
‹‹  
in
‹‹  "
TSource
‹‹# *
,
‹‹* +
TDestination
‹‹, 8
>
‹‹8 9
{›› 
TDestination
ÂÂ 
Convert
ÂÂ 
(
ÂÂ 
TSource
ÂÂ  
source
ÂÂ! '
,
ÂÂ' (
TDestination
ÂÂ) 5
destination
ÂÂ6 A
,
ÂÂA B
ResolutionContext
ÂÂC T
context
ÂÂU \
)
ÂÂ\ ]
;
ÂÂ] ^
}ÊÊ ’B
\C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\IMappingExpression.cs
	namespace 	

AutoMapper
 
; 
public 
	interface 
IMappingExpression #
:$ %"
IMappingExpressionBase& <
<< =
object= C
,C D
objectE K
,K L
IMappingExpressionM _
>_ `
{ 
IMappingExpression 
IncludeMembers %
(% &
params& ,
string- 3
[3 4
]4 5
memberNames6 A
)A B
;B C
IMappingExpression 

ReverseMap !
(! "
)" #
;# $
void 
ForAllMembers	 
( 
Action 
< *
IMemberConfigurationExpression <
>< =
memberOptions> K
)K L
;L M
IMappingExpression 
	ForMember  
(  !
string! '
name( ,
,, -
Action. 4
<4 5*
IMemberConfigurationExpression5 S
>S T
memberOptionsU b
)b c
;c d
}   
public&& 
	interface&& 
IMappingExpression&& #
<&&# $
TSource&&$ +
,&&+ ,
TDestination&&- 9
>&&9 :
:&&; <"
IMappingExpressionBase&&= S
<&&S T
TSource&&T [
,&&[ \
TDestination&&] i
,&&i j
IMappingExpression&&k }
<&&} ~
TSource	&&~ Ö
,
&&Ö Ü
TDestination
&&á ì
>
&&ì î
>
&&î ï
,
&&ï ñ!
IProjectionExpression'' 
<'' 
TSource'' !
,''! "
TDestination''# /
,''/ 0
IMappingExpression''1 C
<''C D
TSource''D K
,''K L
TDestination''M Y
>''Y Z
>''Z [
{(( 
IMappingExpression// 
<// 
TSource// 
,// 
TDestination//  ,
>//, -
ForPath//. 5
<//5 6
TMember//6 =
>//= >
(//> ?

Expression//? I
<//I J
Func//J N
<//N O
TDestination//O [
,//[ \
TMember//] d
>//d e
>//e f
destinationMember//g x
,//x y
Action00 
<00 (
IPathConfigurationExpression00 +
<00+ ,
TSource00, 3
,003 4
TDestination005 A
,00A B
TMember00C J
>00J K
>00K L
memberOptions00M Z
)00Z [
;00[ \
IMappingExpression77 
<77 
TSource77 
,77 
TDestination77  ,
>77, -
	ForMember77. 7
<777 8
TMember778 ?
>77? @
(77@ A

Expression77A K
<77K L
Func77L P
<77P Q
TDestination77Q ]
,77] ^
TMember77_ f
>77f g
>77g h
destinationMember77i z
,77z {
Action88 
<88 *
IMemberConfigurationExpression88 -
<88- .
TSource88. 5
,885 6
TDestination887 C
,88C D
TMember88E L
>88L M
>88M N
memberOptions88O \
)88\ ]
;88] ^
IMappingExpression?? 
<?? 
TSource?? 
,?? 
TDestination??  ,
>??, -
	ForMember??. 7
(??7 8
string??8 >
name??? C
,??C D
Action@@ 
<@@ *
IMemberConfigurationExpression@@ -
<@@- .
TSource@@. 5
,@@5 6
TDestination@@7 C
,@@C D
object@@E K
>@@K L
>@@L M
memberOptions@@N [
)@@[ \
;@@\ ]
voidEE 
ForAllMembersEE	 
(EE 
ActionEE 
<EE *
IMemberConfigurationExpressionEE <
<EE< =
TSourceEE= D
,EED E
TDestinationEEF R
,EER S
objectEET Z
>EEZ [
>EE[ \
memberOptionsEE] j
)EEj k
;EEk l
IMappingExpressionLL 
<LL 
TSourceLL 
,LL 
TDestinationLL  ,
>LL, -
IncludeLL. 5
<LL5 6
TOtherSourceLL6 B
,LLB C
TOtherDestinationLLD U
>LLU V
(LLV W
)LLW X
whereLLY ^
TOtherSourceLL_ k
:LLl m
TSourceLLn u
whereLLv {
TOtherDestination	LL| ç
:
LLé è
TDestination
LLê ú
;
LLú ù
IMappingExpressionSS 
<SS 
TSourceSS 
,SS 
TDestinationSS  ,
>SS, -
IncludeBaseSS. 9
<SS9 :
TSourceBaseSS: E
,SSE F
TDestinationBaseSSG W
>SSW X
(SSX Y
)SSY Z
;SSZ [
IMappingExpressionZZ 
<ZZ 
TSourceZZ 
,ZZ 
TDestinationZZ  ,
>ZZ, -
ForSourceMemberZZ. =
(ZZ= >

ExpressionZZ> H
<ZZH I
FuncZZI M
<ZZM N
TSourceZZN U
,ZZU V
objectZZW ]
>ZZ] ^
>ZZ^ _
sourceMemberZZ` l
,ZZl m
Action[[ 
<[[ 0
$ISourceMemberConfigurationExpression[[ 3
>[[3 4
memberOptions[[5 B
)[[B C
;[[C D
IMappingExpressionaa 
<aa 
TDestinationaa #
,aa# $
TSourceaa% ,
>aa, -

ReverseMapaa. 8
(aa8 9
)aa9 :
;aa: ;
voidff 
Asff	 
<ff 
Tff 
>ff 
(ff 
)ff 
whereff 
Tff 
:ff 
TDestinationff '
;ff' (
}gg 
publichh 
	interfacehh !
IProjectionExpressionhh &
<hh& '
TSourcehh' .
,hh. /
TDestinationhh0 <
,hh< =
TMappingExpressionhh> P
>hhP Q
:hhR S%
IProjectionExpressionBasehhT m
<hhm n
TSourcehhn u
,hhu v
TDestination	hhw É
,
hhÉ Ñ 
TMappingExpression
hhÖ ó
>
hhó ò
whereii 	
TMappingExpressionii
 
:ii %
IProjectionExpressionBaseii 8
<ii8 9
TSourceii9 @
,ii@ A
TDestinationiiB N
,iiN O
TMappingExpressioniiP b
>iib c
{jj 
TMappingExpressionqq 
AddTransformqq #
<qq# $
TValueqq$ *
>qq* +
(qq+ ,

Expressionqq, 6
<qq6 7
Funcqq7 ;
<qq; <
TValueqq< B
,qqB C
TValueqqD J
>qqJ K
>qqK L
transformerqqM X
)qqX Y
;qqY Z
TMappingExpressionxx 
IncludeMembersxx %
(xx% &
paramsxx& ,

Expressionxx- 7
<xx7 8
Funcxx8 <
<xx< =
TSourcexx= D
,xxD E
objectxxF L
>xxL M
>xxM N
[xxN O
]xxO P
memberExpressionsxxQ b
)xxb c
;xxc d
}yy 
publiczz 
	interfacezz !
IProjectionExpressionzz &
<zz& '
TSourcezz' .
,zz. /
TDestinationzz0 <
>zz< =
:zz> ?!
IProjectionExpressionzz@ U
<zzU V
TSourcezzV ]
,zz] ^
TDestinationzz_ k
,zzk l"
IProjectionExpression	zzm Ç
<
zzÇ É
TSource
zzÉ ä
,
zzä ã
TDestination
zzå ò
>
zzò ô
>
zzô ö
{{{ #
IProjectionExpression
ÇÇ 
<
ÇÇ 
TSource
ÇÇ !
,
ÇÇ! "
TDestination
ÇÇ# /
>
ÇÇ/ 0
	ForMember
ÇÇ1 :
<
ÇÇ: ;
TMember
ÇÇ; B
>
ÇÇB C
(
ÇÇC D

Expression
ÇÇD N
<
ÇÇN O
Func
ÇÇO S
<
ÇÇS T
TDestination
ÇÇT `
,
ÇÇ` a
TMember
ÇÇb i
>
ÇÇi j
>
ÇÇj k
destinationMember
ÇÇl }
,
ÇÇ} ~
Action
ÉÉ 
<
ÉÉ ,
IProjectionMemberConfiguration
ÉÉ -
<
ÉÉ- .
TSource
ÉÉ. 5
,
ÉÉ5 6
TDestination
ÉÉ7 C
,
ÉÉC D
TMember
ÉÉE L
>
ÉÉL M
>
ÉÉM N
memberOptions
ÉÉO \
)
ÉÉ\ ]
;
ÉÉ] ^
}ÑÑ Ÿ@
jC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\CtorParamConfigurationExpression.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
public 
	interface -
!ICtorParamConfigurationExpression 2
{ 
void 
MapFrom	 
( 
string 
sourceMembersPath )
)) *
;* +
void 
ExplicitExpansion	 
( 
bool 
value  %
=& '
true( ,
), -
;- .
} 
public 
	interface -
!ICtorParamConfigurationExpression 2
<2 3
TSource3 :
>: ;
:< =-
!ICtorParamConfigurationExpression> _
{ 
void 
MapFrom	 
< 
TMember 
> 
( 

Expression $
<$ %
Func% )
<) *
TSource* 1
,1 2
TMember3 :
>: ;
>; <
sourceMember= I
)I J
;J K
void 
MapFrom	 
< 
TMember 
> 
( 
Func 
< 
TSource &
,& '
ResolutionContext( 9
,9 :
TMember; B
>B C
resolverD L
)L M
;M N
} 
public 
	interface '
ICtorParameterConfiguration ,
{   
string!! 

CtorParamName!! 
{!! 
get!! 
;!! 
}!!  !
void"" 
	Configure""	 
("" 
TypeMap"" 
typeMap"" "
)""" #
;""# $
}## 
[$$ 
EditorBrowsable$$ 
($$  
EditorBrowsableState$$ %
.$$% &
Never$$& +
)$$+ ,
]$$, -
public%% 
sealed%% 
class%% ,
 CtorParamConfigurationExpression%% 4
<%%4 5
TSource%%5 <
,%%< =
TDestination%%> J
>%%J K
(%%K L
string%%L R
ctorParamName%%S `
,%%` a
Type%%b f

sourceType%%g q
)%%q r
:%%s t.
!ICtorParamConfigurationExpression	%%u ñ
<
%%ñ ó
TSource
%%ó û
>
%%û ü
,
%%ü †)
ICtorParameterConfiguration
%%° º
{&& 
public'' 

string'' 
CtorParamName'' 
{''  !
get''" %
;''% &
}''' (
='') *
ctorParamName''+ 8
;''8 9
public(( 

Type(( 

SourceType(( 
{(( 
get((  
;((  !
}((" #
=(($ %

sourceType((& 0
;((0 1
private)) 
readonly)) 
List)) 
<)) 
Action))  
<))  !#
ConstructorParameterMap))! 8
>))8 9
>))9 :
_ctorParamActions)); L
=))M N
[))O P
]))P Q
;))Q R
public** 

void** 
MapFrom** 
<** 
TMember** 
>**  
(**  !

Expression**! +
<**+ ,
Func**, 0
<**0 1
TSource**1 8
,**8 9
TMember**: A
>**A B
>**B C
sourceMember**D P
)**P Q
=>**R T
_ctorParamActions++ 
.++ 
Add++ 
(++ 
cpm++ !
=>++" $
cpm++% (
.++( )
MapFrom++) 0
(++0 1
sourceMember++1 =
)++= >
)++> ?
;++? @
public,, 

void,, 
MapFrom,, 
<,, 
TMember,, 
>,,  
(,,  !
Func,,! %
<,,% &
TSource,,& -
,,,- .
ResolutionContext,,/ @
,,,@ A
TMember,,B I
>,,I J
resolver,,K S
),,S T
{-- 

Expression.. 
<.. 
Func.. 
<.. 
TSource.. 
,..  
TDestination..! -
,..- .
TMember../ 6
,..6 7
ResolutionContext..8 I
,..I J
TMember..K R
>..R S
>..S T
resolverExpression..U g
=..h i
(..j k
src..k n
,..n o
dest..p t
,..t u

destMember	..v Ä
,
..Ä Å
ctxt
..Ç Ü
)
..Ü á
=>
..à ä
resolver
..ã ì
(
..ì î
src
..î ó
,
..ó ò
ctxt
..ô ù
)
..ù û
;
..û ü
_ctorParamActions// 
.// 
Add// 
(// 
cpm// !
=>//" $
cpm//% (
.//( )
SetResolver//) 4
(//4 5
new//5 8
FuncResolver//9 E
(//E F
resolverExpression//F X
)//X Y
)//Y Z
)//Z [
;//[ \
}00 
public11 

void11 
MapFrom11 
(11 
string11 
sourceMembersPath11 0
)110 1
{22 
var33 
sourceMembers33 
=33 
ReflectionHelper33 ,
.33, -
GetMemberPath33- :
(33: ;

SourceType33; E
,33E F
sourceMembersPath33G X
)33X Y
;33Y Z
_ctorParamActions44 
.44 
Add44 
(44 
cpm44 !
=>44" $
cpm44% (
.44( )
MapFrom44) 0
(440 1
sourceMembersPath441 B
,44B C
sourceMembers44D Q
)44Q R
)44R S
;44S T
}55 
public66 

void66 
ExplicitExpansion66 !
(66! "
bool66" &
value66' ,
)66, -
=>66. 0
_ctorParamActions661 B
.66B C
Add66C F
(66F G
cpm66G J
=>66K M
cpm66N Q
.66Q R
ExplicitExpansion66R c
=66d e
value66f k
)66k l
;66l m
public77 

void77 
	Configure77 
(77 
TypeMap77 !
typeMap77" )
)77) *
{88 
var99 
ctorMap99 
=99 
typeMap99 
.99 
ConstructorMap99 ,
;99, -
if:: 

(:: 
ctorMap:: 
==:: 
null:: 
):: 
{;; 	
throw<< 
new<< ,
 AutoMapperConfigurationException<< 6
(<<6 7
$"<<7 9
$str<<9 B
{<<B C
typeMap<<C J
.<<J K
DestinationType<<K Z
.<<Z [
Name<<[ _
}<<_ `
$str<<` 
{	<< Ä
typeMap
<<Ä á
.
<<á à
DestinationType
<<à ó
.
<<ó ò
FullName
<<ò †
}
<<† °
"
<<° ¢
)
<<¢ £
;
<<£ §
}== 	
var>> 
	parameter>> 
=>> 
ctorMap>> 
[>>  
CtorParamName>>  -
]>>- .
;>>. /
if?? 

(?? 
	parameter?? 
==?? 
null?? 
)?? 
{@@ 	
throwAA 
newAA ,
 AutoMapperConfigurationExceptionAA 6
(AA6 7
$"AA7 9
{AA9 :
typeMapAA: A
.AAA B
DestinationTypeAAB Q
.AAQ R
NameAAR V
}AAV W
$str	AAW ï
{
AAï ñ
CtorParamName
AAñ £
}
AA£ §
$str
AA§ ®
{
AA® ©
typeMap
AA© ∞
.
AA∞ ±
DestinationType
AA± ¿
.
AA¿ ¡
FullName
AA¡ …
}
AA…  
$str
AA  À
{
AAÀ Ã
typeMap
AAÃ ”
.
AA” ‘
CheckRecord
AA‘ ﬂ
(
AAﬂ ‡
)
AA‡ ·
}
AA· ‚
"
AA‚ „
)
AA„ ‰
;
AA‰ Â
}BB 	
foreachCC 
(CC 
varCC 
actionCC 
inCC 
_ctorParamActionsCC 0
)CC0 1
{DD 	
actionEE 
(EE 
	parameterEE 
)EE 
;EE 
}FF 	
}GG 
}HH ˛≈
UC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Conventions.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Conventions# .
;. /
public 
	interface *
ISourceToDestinationNameMapper /
{ 

MemberInfo 
GetSourceMember 
( 
TypeDetails *
sourceTypeDetails+ <
,< =
Type> B
destTypeC K
,K L
TypeM Q
destMemberTypeR `
,` a
stringb h
nameToSearchi u
)u v
;v w
void 
Merge	 
( *
ISourceToDestinationNameMapper -
other. 3
)3 4
;4 5
} 
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
sealed 
class 
MemberConfiguration '
{		 
NameSplitMember

 
_nameSplitMember

 $
;

$ %
public 

INamingConvention "
SourceNamingConvention 3
{4 5
get6 9
;9 :
set; >
;> ?
}@ A
public 

INamingConvention '
DestinationNamingConvention 8
{9 :
get; >
;> ?
set@ C
;C D
}E F
public 

List 
< *
ISourceToDestinationNameMapper .
>. /
NameToMemberMappers0 C
{D E
getF I
;I J
}K L
=M N
[O P
]P Q
;Q R
public 

bool 
IsMatch 
( 

ProfileMap "
options# *
,* +
TypeDetails, 7
sourceTypeDetails8 I
,I J
TypeK O
destTypeP X
,X Y
TypeZ ^
destMemberType_ m
,m n
stringo u
nameToSearch	v Ç
,
Ç É
List
Ñ à
<
à â

MemberInfo
â ì
>
ì î
	resolvers
ï û
,
û ü
bool
† §
isReverseMap
• ±
)
± ≤
{ 
var 
matchingMemberInfo 
=  
GetSourceMember! 0
(0 1
sourceTypeDetails1 B
,B C
destTypeD L
,L M
destMemberTypeN \
,\ ]
nameToSearch^ j
)j k
;k l
if 

( 
matchingMemberInfo 
!= !
null" &
)& '
{ 	
	resolvers 
. 
Add 
( 
matchingMemberInfo ,
), -
;- .
return 
true 
; 
} 	
return 
nameToSearch 
. 
Length "
==# %
$num& '
||( *
_nameSplitMember+ ;
.; <
IsMatch< C
(C D
optionsD K
,K L
sourceTypeDetailsM ^
,^ _
destType` h
,h i
destMemberTypej x
,x y
nameToSearch	z Ü
,
Ü á
	resolvers
à ë
,
ë í
isReverseMap
ì ü
)
ü †
;
† °
} 
public 


MemberInfo 
GetSourceMember %
(% &
TypeDetails& 1
sourceTypeDetails2 C
,C D
TypeE I
destTypeJ R
,R S
TypeT X
destMemberTypeY g
,g h
stringi o
nameToSearchp |
)| }
{ 
var 
sourceMember 
= 
sourceTypeDetails ,
., -
	GetMember- 6
(6 7
nameToSearch7 C
)C D
;D E
if 

( 
sourceMember 
!= 
null  
)  !
{ 	
return 
sourceMember 
;  
} 	
foreach 
( 
var 
mapper 
in 
NameToMemberMappers 2
)2 3
{   	
if!! 
(!! 
(!! 
sourceMember!! 
=!! 
mapper!!  &
.!!& '
GetSourceMember!!' 6
(!!6 7
sourceTypeDetails!!7 H
,!!H I
destType!!J R
,!!R S
destMemberType!!T b
,!!b c
nameToSearch!!d p
)!!p q
)!!q r
!=!!s u
null!!v z
)!!z {
{"" 
return## 
sourceMember## #
;### $
}$$ 
}%% 	
return&& 
null&& 
;&& 
}'' 
public(( 

void(( 
Seal(( 
((( 
)(( 
{)) 
var** 
	isDefault** 
=** "
SourceNamingConvention** .
==**/ 1&
PascalCaseNamingConvention**2 L
.**L M
Instance**M U
&&**V X'
DestinationNamingConvention**Y t
==**u w'
PascalCaseNamingConvention	**x í
.
**í ì
Instance
**ì õ
;
**õ ú
_nameSplitMember++ 
=++ 
	isDefault++ $
?++% &
new++' *"
DefaultNameSplitMember+++ A
(++A B
)++B C
:++D E
new++F I&
ConventionsNameSplitMember++J d
(++d e
)++e f
;++f g
_nameSplitMember,, 
.,, 
Parent,, 
=,,  !
this,," &
;,,& '
}-- 
public.. 

void.. 
Merge.. 
(.. 
MemberConfiguration.. )
other..* /
)../ 0
{// 
var00 
initialCount00 
=00 
NameToMemberMappers00 .
.00. /
Count00/ 4
;004 5
for11 
(11 
int11 
index11 
=11 
$num11 
;11 
index11 !
<11" #
other11$ )
.11) *
NameToMemberMappers11* =
.11= >
Count11> C
;11C D
index11E J
++11J L
)11L M
{22 	
var33 
otherMapper33 
=33 
other33 #
.33# $
NameToMemberMappers33$ 7
[337 8
index338 =
]33= >
;33> ?
if44 
(44 
index44 
<44 
initialCount44 $
)44$ %
{55 
var66 
nameToMemberMapper66 &
=66' (
NameToMemberMappers66) <
[66< =
index66= B
]66B C
;66C D
if77 
(77 
nameToMemberMapper77 &
.77& '
GetType77' .
(77. /
)77/ 0
==771 3
otherMapper774 ?
.77? @
GetType77@ G
(77G H
)77H I
)77I J
{88 
nameToMemberMapper99 &
.99& '
Merge99' ,
(99, -
otherMapper99- 8
)998 9
;999 :
continue:: 
;:: 
};; 
}<< 
NameToMemberMappers== 
.==  
Add==  #
(==# $
otherMapper==$ /
)==/ 0
;==0 1
}>> 	"
SourceNamingConvention?? 
??=?? "
other??# (
.??( )"
SourceNamingConvention??) ?
;??? @'
DestinationNamingConvention@@ #
??=@@$ '
other@@( -
.@@- .'
DestinationNamingConvention@@. I
;@@I J
}AA 
}BB 
publicCC 
sealedCC 
classCC 
PrePostfixNameCC "
:CC# $*
ISourceToDestinationNameMapperCC% C
{DD 
publicEE 

ListEE 
<EE 
stringEE 
>EE 
DestinationPrefixesEE +
{EE, -
getEE. 1
;EE1 2
}EE3 4
=EE5 6
[EE7 8
]EE8 9
;EE9 :
publicFF 

ListFF 
<FF 
stringFF 
>FF  
DestinationPostfixesFF ,
{FF- .
getFF/ 2
;FF2 3
}FF4 5
=FF6 7
[FF8 9
]FF9 :
;FF: ;
publicGG 


MemberInfoGG 
GetSourceMemberGG %
(GG% &
TypeDetailsGG& 1
sourceTypeDetailsGG2 C
,GGC D
TypeGGE I
destTypeGGJ R
,GGR S
TypeGGT X
destMemberTypeGGY g
,GGg h
stringGGi o
nameToSearchGGp |
)GG| }
{HH 

MemberInfoII 
memberII 
;II 
foreachJJ 
(JJ 
varJJ 
possibleSourceNameJJ '
inJJ( *
TypeDetailsJJ+ 6
.JJ6 7
PossibleNamesJJ7 D
(JJD E
nameToSearchJJE Q
,JJQ R
DestinationPrefixesJJS f
,JJf g 
DestinationPostfixesJJh |
)JJ| }
)JJ} ~
{KK 	
ifLL 
(LL 
(LL 
memberLL 
=LL 
sourceTypeDetailsLL +
.LL+ ,
	GetMemberLL, 5
(LL5 6
possibleSourceNameLL6 H
)LLH I
)LLI J
!=LLK M
nullLLN R
)LLR S
{MM 
returnNN 
memberNN 
;NN 
}OO 
}PP 	
returnQQ 
nullQQ 
;QQ 
}RR 
publicSS 

voidSS 
MergeSS 
(SS *
ISourceToDestinationNameMapperSS 4
otherSS5 :
)SS: ;
{TT 
varUU 

typedOtherUU 
=UU 
(UU 
PrePostfixNameUU (
)UU( )
otherUU) .
;UU. /
DestinationPrefixesVV 
.VV 
TryAddVV "
(VV" #

typedOtherVV# -
.VV- .
DestinationPrefixesVV. A
)VVA B
;VVB C 
DestinationPostfixesWW 
.WW 
TryAddWW #
(WW# $

typedOtherWW$ .
.WW. / 
DestinationPostfixesWW/ C
)WWC D
;WWD E
}XX 
}YY 
publicZZ 
sealedZZ 
classZZ 
ReplaceNameZZ 
:ZZ  !*
ISourceToDestinationNameMapperZZ" @
{[[ 
public\\ 

List\\ 
<\\ 
MemberNameReplacer\\ "
>\\" #
MemberNameReplacers\\$ 7
{\\8 9
get\\: =
;\\= >
}\\? @
=\\A B
[\\C D
]\\D E
;\\E F
public]] 


MemberInfo]] 
GetSourceMember]] %
(]]% &
TypeDetails]]& 1
sourceTypeDetails]]2 C
,]]C D
Type]]E I
destType]]J R
,]]R S
Type]]T X
destMemberType]]Y g
,]]g h
string]]i o
nameToSearch]]p |
)]]| }
{^^ 
var__ 
possibleSourceNames__ 
=__  !
PossibleNames__" /
(__/ 0
nameToSearch__0 <
)__< =
;__= >
if`` 

(`` 
possibleSourceNames`` 
.``  
Count``  %
==``& (
$num``) *
)``* +
{aa 	
returnbb 
nullbb 
;bb 
}cc 	
vardd 
possibleDestNamesdd 
=dd 
Arraydd  %
.dd% &

ConvertAlldd& 0
(dd0 1
sourceTypeDetailsdd1 B
.ddB C
ReadAccessorsddC P
,ddP Q
middR T
=>ddU W
(ddX Y
middY [
,dd[ \
	possiblesdd] f
:ddg h
PossibleNamesddi v
(ddv w
middw y
.ddy z
Nameddz ~
)dd~ 
)	dd Ä
)
ddÄ Å
;
ddÅ Ç
foreachee 
(ee 
varee 

sourceNameee 
inee  "
possibleSourceNamesee# 6
)ee6 7
{ff 	
foreachgg 
(gg 
vargg 
(gg 
migg 
,gg 
	possiblesgg '
)gg' (
ingg) +
possibleDestNamesgg, =
)gg= >
{hh 
ifii 
(ii 
	possiblesii 
.ii 
Containsii &
(ii& '

sourceNameii' 1
,ii1 2
StringComparerii3 A
.iiA B
OrdinalIgnoreCaseiiB S
)iiS T
)iiT U
{jj 
returnkk 
mikk 
;kk 
}ll 
}mm 
}nn 	
returnoo 
nulloo 
;oo 
}pp 
publicqq 

voidqq 
Mergeqq 
(qq *
ISourceToDestinationNameMapperqq 4
otherqq5 :
)qq: ;
=>qq< >
MemberNameReplacersqq? R
.qqR S
TryAddqqS Y
(qqY Z
(qqZ [
(qq[ \
ReplaceNameqq\ g
)qqg h
otherqqh m
)qqm n
.qqn o 
MemberNameReplacers	qqo Ç
)
qqÇ É
;
qqÉ Ñ
privaterr 
Listrr 
<rr 
stringrr 
>rr 
PossibleNamesrr &
(rr& '
stringrr' -
nameToSearchrr. :
)rr: ;
=>rr< >
[rr? @
..rr@ B
MemberNameReplacersrrB U
.rrU V
SelectrrV \
(rr\ ]
rrr] ^
=>rr_ a
nameToSearchrrb n
.rrn o
Replacerro v
(rrv w
rrrw x
.rrx y
OriginalValue	rry Ü
,
rrÜ á
r
rrà â
.
rrâ ä
NewValue
rrä í
)
rrí ì
)
rrì î
,
rrî ï
MemberNameReplacersss 
.ss 
	Aggregatess %
(ss% &
nameToSearchss& 2
,ss2 3
(ss4 5
sss5 6
,ss6 7
rss8 9
)ss9 :
=>ss; =
sss> ?
.ss? @
Replacess@ G
(ssG H
rssH I
.ssI J
OriginalValuessJ W
,ssW X
rssY Z
.ssZ [
NewValuess[ c
)ssc d
)ssd e
,sse f
nameToSearchssg s
]sss t
;sst u
}tt 
[uu 
EditorBrowsableuu 
(uu  
EditorBrowsableStateuu %
.uu% &
Neveruu& +
)uu+ ,
]uu, -
publicvv 
readonlyvv 
recordvv 
structvv 
MemberNameReplacervv 0
(vv0 1
stringvv1 7
OriginalValuevv8 E
,vvE F
stringvvG M
NewValuevvN V
)vvV W
;vvW X
[ww 
EditorBrowsableww 
(ww  
EditorBrowsableStateww %
.ww% &
Neverww& +
)ww+ ,
]ww, -
publicxx 
abstractxx 
classxx 
NameSplitMemberxx %
{yy 
publiczz 

MemberConfigurationzz 
Parentzz %
{zz& '
getzz( +
;zz+ ,
setzz- 0
;zz0 1
}zz2 3
public{{ 

abstract{{ 
bool{{ 
IsMatch{{  
({{  !

ProfileMap{{! +
options{{, 3
,{{3 4
TypeDetails{{5 @

sourceType{{A K
,{{K L
Type{{M Q
destType{{R Z
,{{Z [
Type{{\ `
destMemberType{{a o
,{{o p
string{{q w
nameToSearch	{{x Ñ
,
{{Ñ Ö
List
{{Ü ä
<
{{ä ã

MemberInfo
{{ã ï
>
{{ï ñ
	resolvers
{{ó †
,
{{† °
bool
{{¢ ¶
isReverseMap
{{ß ≥
)
{{≥ ¥
;
{{¥ µ
}|| 
[}} 
EditorBrowsable}} 
(}}  
EditorBrowsableState}} %
.}}% &
Never}}& +
)}}+ ,
]}}, -
public~~ 
sealed~~ 
class~~ "
DefaultNameSplitMember~~ *
:~~+ ,
NameSplitMember~~- <
{ 
public
ÄÄ 

sealed
ÄÄ 
override
ÄÄ 
bool
ÄÄ 
IsMatch
ÄÄ  '
(
ÄÄ' (

ProfileMap
ÄÄ( 2
options
ÄÄ3 :
,
ÄÄ: ;
TypeDetails
ÄÄ< G

sourceType
ÄÄH R
,
ÄÄR S
Type
ÄÄT X
destType
ÄÄY a
,
ÄÄa b
Type
ÄÄc g
destMemberType
ÄÄh v
,
ÄÄv w
string
ÄÄx ~
nameToSearchÄÄ ã
,ÄÄã å
ListÄÄç ë
<ÄÄë í

MemberInfoÄÄí ú
>ÄÄú ù
	resolversÄÄû ß
,ÄÄß ®
boolÄÄ© ≠
isReverseMapÄÄÆ ∫
)ÄÄ∫ ª
{
ÅÅ 

MemberInfo
ÇÇ  
matchingMemberInfo
ÇÇ %
=
ÇÇ& '
null
ÇÇ( ,
;
ÇÇ, -
int
ÉÉ 
index
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
for
ÑÑ 
(
ÑÑ 
;
ÑÑ 
index
ÑÑ 
<
ÑÑ 
nameToSearch
ÑÑ #
.
ÑÑ# $
Length
ÑÑ$ *
;
ÑÑ* +
index
ÑÑ, 1
++
ÑÑ1 3
)
ÑÑ3 4
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ 
char
ÜÜ 
.
ÜÜ 
IsUpper
ÜÜ 
(
ÜÜ 
nameToSearch
ÜÜ )
[
ÜÜ) *
index
ÜÜ* /
]
ÜÜ/ 0
)
ÜÜ0 1
&&
ÜÜ2 4
Found
ÜÜ5 :
(
ÜÜ: ;
)
ÜÜ; <
)
ÜÜ< =
{
áá 
return
àà 
true
àà 
;
àà 
}
ââ 
}
ää 	
return
ãã  
matchingMemberInfo
ãã !
!=
ãã" $
null
ãã% )
&&
ãã* ,
Found
ãã- 2
(
ãã2 3
)
ãã3 4
;
ãã4 5
bool
åå 
Found
åå 
(
åå 
)
åå 
{
çç 	
var
éé 
first
éé 
=
éé 
nameToSearch
éé $
[
éé$ %
..
éé% '
index
éé' ,
]
éé, -
;
éé- . 
matchingMemberInfo
èè 
=
èè  
Parent
èè! '
.
èè' (
GetSourceMember
èè( 7
(
èè7 8

sourceType
èè8 B
,
èèB C
destType
èèD L
,
èèL M
destMemberType
èèN \
,
èè\ ]
first
èè^ c
)
èèc d
;
èèd e
if
êê 
(
êê  
matchingMemberInfo
êê "
==
êê# %
null
êê& *
)
êê* +
{
ëë 
return
íí 
false
íí 
;
íí 
}
ìì 
	resolvers
îî 
.
îî 
Add
îî 
(
îî  
matchingMemberInfo
îî ,
)
îî, -
;
îî- .
var
ïï 
second
ïï 
=
ïï 
nameToSearch
ïï %
[
ïï% &
index
ïï& +
..
ïï+ -
]
ïï- .
;
ïï. /
var
ññ 
details
ññ 
=
ññ 
options
ññ !
.
ññ! "
CreateTypeDetails
ññ" 3
(
ññ3 4 
matchingMemberInfo
ññ4 F
.
ññF G
GetMemberType
ññG T
(
ññT U
)
ññU V
)
ññV W
;
ññW X
if
óó 
(
óó 
Parent
óó 
.
óó 
IsMatch
óó 
(
óó 
options
óó &
,
óó& '
details
óó( /
,
óó/ 0
destType
óó1 9
,
óó9 :
destMemberType
óó; I
,
óóI J
second
óóK Q
,
óóQ R
	resolvers
óóS \
,
óó\ ]
isReverseMap
óó^ j
)
óój k
)
óók l
{
òò 
return
ôô 
true
ôô 
;
ôô 
}
öö 
	resolvers
õõ 
.
õõ 
RemoveAt
õõ 
(
õõ 
	resolvers
õõ (
.
õõ( )
Count
õõ) .
-
õõ/ 0
$num
õõ1 2
)
õõ2 3
;
õõ3 4
return
úú 
false
úú 
;
úú 
}
ùù 	
}
ûû 
}üü 
[†† 
EditorBrowsable
†† 
(
†† "
EditorBrowsableState
†† %
.
††% &
Never
††& +
)
††+ ,
]
††, -
public°° 
sealed
°° 
class
°° (
ConventionsNameSplitMember
°° .
:
°°/ 0
NameSplitMember
°°1 @
{¢¢ 
public
££ 

sealed
££ 
override
££ 
bool
££ 
IsMatch
££  '
(
££' (

ProfileMap
££( 2
options
££3 :
,
££: ;
TypeDetails
££< G

sourceType
££H R
,
££R S
Type
££T X
destType
££Y a
,
££a b
Type
££c g
destMemberType
££h v
,
££v w
string
££x ~
nameToSearch££ ã
,££ã å
List££ç ë
<££ë í

MemberInfo££í ú
>££ú ù
	resolvers££û ß
,££ß ®
bool££© ≠
isReverseMap££Æ ∫
)££∫ ª
{
§§ 
var
•• )
destinationNamingConvention
•• '
=
••( )
isReverseMap
••* 6
?
••7 8
Parent
••9 ?
.
••? @$
SourceNamingConvention
••@ V
:
••W X
Parent
••Y _
.
••_ `)
DestinationNamingConvention
••` {
;
••{ |
var
¶¶ 
matches
¶¶ 
=
¶¶ )
destinationNamingConvention
¶¶ 1
.
¶¶1 2
Split
¶¶2 7
(
¶¶7 8
nameToSearch
¶¶8 D
)
¶¶D E
;
¶¶E F
var
ßß 
length
ßß 
=
ßß 
matches
ßß 
.
ßß 
Length
ßß #
;
ßß# $
if
®® 

(
®® 
length
®® 
<
®® 
$num
®® 
)
®® 
{
©© 	
return
™™ 
false
™™ 
;
™™ 
}
´´ 	
var
¨¨ $
sourceNamingConvention
¨¨ "
=
¨¨# $
isReverseMap
¨¨% 1
?
¨¨2 3
Parent
¨¨4 :
.
¨¨: ;)
DestinationNamingConvention
¨¨; V
:
¨¨W X
Parent
¨¨Y _
.
¨¨_ `$
SourceNamingConvention
¨¨` v
;
¨¨v w
var
≠≠ 
	separator
≠≠ 
=
≠≠ $
sourceNamingConvention
≠≠ .
.
≠≠. / 
SeparatorCharacter
≠≠/ A
;
≠≠A B
for
ÆÆ 
(
ÆÆ 
var
ÆÆ 
index
ÆÆ 
=
ÆÆ 
$num
ÆÆ 
;
ÆÆ 
index
ÆÆ !
<=
ÆÆ" $
length
ÆÆ% +
;
ÆÆ+ ,
index
ÆÆ- 2
++
ÆÆ2 4
)
ÆÆ4 5
{
ØØ 	
var
∞∞ 
first
∞∞ 
=
∞∞ 
string
∞∞ 
.
∞∞ 
Join
∞∞ #
(
∞∞# $
	separator
∞∞$ -
,
∞∞- .
matches
∞∞/ 6
,
∞∞6 7
$num
∞∞8 9
,
∞∞9 :
index
∞∞; @
)
∞∞@ A
;
∞∞A B
var
±±  
matchingMemberInfo
±± "
=
±±# $
Parent
±±% +
.
±±+ ,
GetSourceMember
±±, ;
(
±±; <

sourceType
±±< F
,
±±F G
destType
±±H P
,
±±P Q
destMemberType
±±R `
,
±±` a
first
±±b g
)
±±g h
;
±±h i
if
≤≤ 
(
≤≤  
matchingMemberInfo
≤≤ "
!=
≤≤# %
null
≤≤& *
)
≤≤* +
{
≥≥ 
	resolvers
¥¥ 
.
¥¥ 
Add
¥¥ 
(
¥¥  
matchingMemberInfo
¥¥ 0
)
¥¥0 1
;
¥¥1 2
var
µµ 
second
µµ 
=
µµ 
string
µµ #
.
µµ# $
Join
µµ$ (
(
µµ( )
	separator
µµ) 2
,
µµ2 3
matches
µµ4 ;
,
µµ; <
index
µµ= B
,
µµB C
length
µµD J
-
µµK L
index
µµM R
)
µµR S
;
µµS T
var
∂∂ 
details
∂∂ 
=
∂∂ 
options
∂∂ %
.
∂∂% &
CreateTypeDetails
∂∂& 7
(
∂∂7 8 
matchingMemberInfo
∂∂8 J
.
∂∂J K
GetMemberType
∂∂K X
(
∂∂X Y
)
∂∂Y Z
)
∂∂Z [
;
∂∂[ \
if
∑∑ 
(
∑∑ 
Parent
∑∑ 
.
∑∑ 
IsMatch
∑∑ "
(
∑∑" #
options
∑∑# *
,
∑∑* +
details
∑∑, 3
,
∑∑3 4
destType
∑∑5 =
,
∑∑= >
destMemberType
∑∑? M
,
∑∑M N
second
∑∑O U
,
∑∑U V
	resolvers
∑∑W `
,
∑∑` a
isReverseMap
∑∑b n
)
∑∑n o
)
∑∑o p
{
∏∏ 
return
ππ 
true
ππ 
;
ππ  
}
∫∫ 
	resolvers
ªª 
.
ªª 
RemoveAt
ªª "
(
ªª" #
	resolvers
ªª# ,
.
ªª, -
Count
ªª- 2
-
ªª3 4
$num
ªª5 6
)
ªª6 7
;
ªª7 8
}
ºº 
}
ΩΩ 	
return
ææ 
false
ææ 
;
ææ 
}
øø 
}¿¿ ıa
`C:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\ConfigurationValidator.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
public 
class "
ConfigurationValidator #
(# $ 
IGlobalConfiguration$ 8
config9 ?
)? @
{ *
IGlobalConfigurationExpression "

Expression# -
=>. 0
(1 2
(2 3
MapperConfiguration3 F
)F G
configG M
)M N
.N O#
ConfigurationExpressionO f
;f g
public 

void 0
$AssertConfigurationExpressionIsValid 4
(4 5
TypeMap5 <
[< =
]= >
typeMaps? G
)G H
{ 
var		 #
duplicateTypeMapConfigs		 #
=		$ %

Expression		& 0
.		0 1
Profiles		1 9
.		9 :
Append		: @
(		@ A
(		A B
Profile		B I
)		I J

Expression		J T
)		T U
.

 

SelectMany

 
(

 
p

 
=>

 
p

 
.

 
TypeMapConfigs

 -
,

- .
(

/ 0
profile

0 7
,

7 8
typeMap

9 @
)

@ A
=>

B D
(

E F
profile

F M
,

M N
typeMap

O V
)

V W
)

W X
. 
GroupBy 
( 
x 
=> 
x 
. 
typeMap #
.# $
Types$ )
)) *
. 
Where 
( 
g 
=> 
g 
. 
Count 
(  
)  !
>" #
$num$ %
)% &
. 
Select 
( 
g 
=> 
( 
TypePair "
:" #
g$ %
.% &
Key& )
,) *
ProfileNames+ 7
:7 8
g9 :
.: ;
Select; A
(A B
tmcB E
=>F H
tmcI L
.L M
profileM T
.T U
ProfileNameU `
)` a
.a b
ToArrayb i
(i j
)j k
)k l
)l m
. 
Select 
( 
g 
=> 
new 2
&DuplicateTypeMapConfigurationException C
.C D
TypeMapConfigErrorsD W
(W X
gX Y
.Y Z
TypePairZ b
,b c
gd e
.e f
ProfileNamesf r
)r s
)s t
. 
ToArray 
( 
) 
; 
if 

( #
duplicateTypeMapConfigs #
.# $
Length$ *
!=+ -
$num. /
)/ 0
{ 	
throw 
new 2
&DuplicateTypeMapConfigurationException <
(< =#
duplicateTypeMapConfigs= T
)T U
;U V
} 	&
AssertConfigurationIsValid "
(" #
typeMaps# +
)+ ,
;, -
} 
public 

void &
AssertConfigurationIsValid *
(* +
TypeMap+ 2
[2 3
]3 4
typeMaps5 =
)= >
{ 
List 
< 
	Exception 
> 
configExceptions (
=) *
[+ ,
], -
;- .
var 
badTypeMaps 
= 
( 
from 
typeMap 
in 
typeMaps %
where 
typeMap 
. 
ShouldCheckForValid .
let !
unmappedPropertyNames &
=' (
typeMap) 0
.0 1$
GetUnmappedPropertyNames1 I
(I J
)J K
let 
canConstruct 
= 
typeMap  '
.' ( 
PassesCtorValidation( <
where !
unmappedPropertyNames (
.( )
Length) /
>0 1
$num2 3
||4 6
!7 8
canConstruct8 D
select 
new ,
 AutoMapperConfigurationException 8
.8 9
TypeMapConfigErrors9 L
(L M
typeMapM T
,T U!
unmappedPropertyNamesV k
,k l
canConstructm y
)y z
)z {
.{ |
ToArray	| É
(
É Ñ
)
Ñ Ö
;
Ö Ü
if   

(   
badTypeMaps   
.   
Length   
>    
$num  ! "
)  " #
{!! 	
configExceptions"" 
."" 
Add""  
(""  !
new""! $,
 AutoMapperConfigurationException""% E
(""E F
badTypeMaps""F Q
)""Q R
)""R S
;""S T
}## 	
HashSet$$ 
<$$ 
TypeMap$$ 
>$$ 
typeMapsChecked$$ (
=$$) *
[$$+ ,
]$$, -
;$$- .
foreach%% 
(%% 
var%% 
typeMap%% 
in%% 
typeMaps%%  (
)%%( )
{&& 	
DryRunTypeMap'' 
('' 
typeMap'' !
.''! "
Types''" '
,''' (
typeMap'') 0
,''0 1
null''2 6
)''6 7
;''7 8
}(( 	
if)) 

()) 
configExceptions)) 
.)) 
Count)) "
>))# $
$num))% &
)))& '
{** 	
throw++ 
new++ 
AggregateException++ (
(++( )
configExceptions++) 9
)++9 :
;++: ;
},, 	
if-- 

(-- 
configExceptions-- 
.-- 
Count-- "
>--# $
$num--% &
)--& '
{.. 	
throw// 
configExceptions// "
[//" #
$num//# $
]//$ %
;//% &
}00 	
void11 
DryRunTypeMap11 
(11 
TypePair11 #
types11$ )
,11) *
TypeMap11+ 2
typeMap113 :
,11: ;
	MemberMap11< E
	memberMap11F O
)11O P
{22 	
if33 
(33 
typeMap33 
==33 
null33 
)33  
{44 
if55 
(55 
types55 
.55 %
ContainsGenericParameters55 3
)553 4
{66 
return77 
;77 
}88 
typeMap99 
=99 
config99  
.99  !
ResolveTypeMap99! /
(99/ 0
types990 5
)995 6
;996 7
}:: 
if;; 
(;; 
typeMap;; 
!=;; 
null;; 
);;  
{<< 
if== 
(== 
typeMapsChecked== #
.==# $
Add==$ '
(==' (
typeMap==( /
)==/ 0
&&==1 3
Validate==4 <
(==< =
new=== @
(==@ A
types==A F
,==F G
	memberMap==H Q
,==Q R
configExceptions==S c
,==c d
typeMap==e l
)==l m
)==m n
&&==o q
typeMap==r y
.==y z 
ShouldCheckForValid	==z ç
)
==ç é
{>> 
CheckPropertyMaps?? %
(??% &
typeMap??& -
)??- .
;??. /
}@@ 
}AA 
elseBB 
{CC 
varDD 
mapperToUseDD 
=DD  !
configDD" (
.DD( )

FindMapperDD) 3
(DD3 4
typesDD4 9
)DD9 :
;DD: ;
ifEE 
(EE 
mapperToUseEE 
==EE  "
nullEE# '
)EE' (
{FF 
configExceptionsGG $
.GG$ %
AddGG% (
(GG( )
newGG) ,,
 AutoMapperConfigurationExceptionGG- M
(GGM N
	memberMapGGN W
.GGW X
TypeMapGGX _
.GG_ `
TypesGG` e
)GGe f
{GGg h
	MemberMapGGi r
=GGs t
	memberMapGGu ~
}	GG Ä
)
GGÄ Å
;
GGÅ Ç
returnHH 
;HH 
}II 
ifJJ 
(JJ 
ValidateJJ 
(JJ 
newJJ  
(JJ  !
typesJJ! &
,JJ& '
	memberMapJJ( 1
,JJ1 2
configExceptionsJJ3 C
,JJC D
ObjectMapperJJE Q
:JJQ R
mapperToUseJJS ^
)JJ^ _
)JJ_ `
&&JJa c
mapperToUseJJd o
.JJo p
GetAssociatedTypes	JJp Ç
(
JJÇ É
types
JJÉ à
)
JJà â
is
JJä å
TypePair
JJç ï
newTypes
JJñ û
&&
JJü °
newTypesKK 
!=KK 
typesKK  %
)KK% &
{LL 
DryRunTypeMapMM !
(MM! "
newTypesMM" *
,MM* +
nullMM, 0
,MM0 1
	memberMapMM2 ;
)MM; <
;MM< =
}NN 
}OO 
}PP 	
voidQQ 
CheckPropertyMapsQQ 
(QQ 
TypeMapQQ &
typeMapQQ' .
)QQ. /
{RR 	
foreachSS 
(SS 
varSS 
	memberMapSS "
inSS# %
typeMapSS& -
.SS- .

MemberMapsSS. 8
)SS8 9
{TT 
ifUU 
(UU 
	memberMapUU 
.UU 
IgnoredUU %
||UU& (
(UU) *
	memberMapUU* 3
isUU4 6
PropertyMapUU7 B
&&UUC E
typeMapUUF M
.UUM N'
ConstructorParameterMatchesUUN i
(UUi j
	memberMapUUj s
.UUs t
DestinationName	UUt É
)
UUÉ Ñ
)
UUÑ Ö
)
UUÖ Ü
{VV 
continueWW 
;WW 
}XX 
varYY 

sourceTypeYY 
=YY  
	memberMapYY! *
.YY* +

SourceTypeYY+ 5
;YY5 6
if[[ 
([[ 

sourceType[[ 
.[[ 
IsGenericParameter[[ 1
||[[2 4

sourceType[[5 ?
==[[@ B
typeof[[C I
([[I J
object[[J P
)[[P Q
)[[Q R
{\\ 
continue]] 
;]] 
}^^ 
DryRunTypeMap__ 
(__ 
new__ !
(__! "

sourceType__" ,
,__, -
	memberMap__. 7
.__7 8
DestinationType__8 G
)__G H
,__H I
null__J N
,__N O
	memberMap__P Y
)__Y Z
;__Z [
}`` 
}aa 	
boolbb 
Validatebb 
(bb 
ValidationContextbb '
contextbb( /
)bb/ 0
{cc 	
trydd 
{ee 
foreachff 
(ff 
varff 
	validatorff &
inff' )

Expressionff* 4
.ff4 5

Validatorsff5 ?
)ff? @
{gg 
	validatorhh 
(hh 
contexthh %
)hh% &
;hh& '
}ii 
}jj 
catchkk 
(kk 
	Exceptionkk 
ekk 
)kk 
{ll 
configExceptionsmm  
.mm  !
Addmm! $
(mm$ %
emm% &
)mm& '
;mm' (
returnnn 
falsenn 
;nn 
}oo 
returnpp 
truepp 
;pp 
}qq 	
}rr 
}ss 
publictt 
readonlytt 
recordtt 
structtt 
ValidationContexttt /
(tt/ 0
TypePairtt0 8
Typestt9 >
,tt> ?
	MemberMaptt@ I
	MemberMapttJ S
,ttS T
ListttU Y
<ttY Z
	ExceptionttZ c
>ttc d

Exceptionstte o
,tto p
TypeMapttq x
TypeMap	tty Ä
=
ttÅ Ç
null
ttÉ á
,
ttá à
IObjectMapper
ttâ ñ
ObjectMapper
ttó £
=
tt§ •
null
tt¶ ™
)
tt™ ´
;
tt´ ¨Â
lC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\ValueResolverAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[

 
AttributeUsage

 
(

 
AttributeTargets

  
.

  !
Field

! &
|

' (
AttributeTargets

) 9
.

9 :
Property

: B
)

B C
]

C D
public 
sealed 
class "
ValueResolverAttribute *
(* +
Type+ /
type0 4
)4 5
:6 7
	Attribute8 A
,A B(
IMemberConfigurationProviderC _
{ 
public 

Type 
Type 
{ 
get 
; 
} 
= 
type  $
;$ %
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ 
var !
sourceMemberAttribute !
=" #)
memberConfigurationExpression$ A
.A B
DestinationMemberB S
.S T
GetCustomAttributeT f
<f g!
SourceMemberAttributeg |
>| }
(} ~
)~ 
;	 Ä
if 

( !
sourceMemberAttribute !
!=" $
null% )
)) *
{ 	)
memberConfigurationExpression )
.) *
MapFrom* 1
(1 2
Type2 6
,6 7!
sourceMemberAttribute8 M
.M N
NameN R
)R S
;S T
} 	
else 
{ 	)
memberConfigurationExpression )
.) *
MapFrom* 1
(1 2
Type2 6
)6 7
;7 8
} 	
} 
} Ò
mC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\ValueConverterAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[

 
AttributeUsage

 
(

 
AttributeTargets

  
.

  !
Field

! &
|

' (
AttributeTargets

) 9
.

9 :
Property

: B
)

B C
]

C D
public 
sealed 
class #
ValueConverterAttribute +
(+ ,
Type, 0
type1 5
)5 6
:7 8
	Attribute9 B
,B C(
IMemberConfigurationProviderD `
{ 
public 

Type 
Type 
{ 
get 
; 
} 
= 
type  $
;$ %
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ 
var !
sourceMemberAttribute !
=" #)
memberConfigurationExpression$ A
.A B
DestinationMemberB S
.S T
GetCustomAttributeT f
<f g!
SourceMemberAttributeg |
>| }
(} ~
)~ 
;	 Ä
if 

( !
sourceMemberAttribute !
!=" $
null% )
)) *
{ 	)
memberConfigurationExpression )
.) *
ConvertUsing* 6
(6 7
Type7 ;
,; <!
sourceMemberAttribute= R
.R S
NameS W
)W X
;X Y
} 	
else 
{ 	)
memberConfigurationExpression )
.) *
ConvertUsing* 6
(6 7
Type7 ;
); <
;< =
} 	
} 
} °
oC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\UseExistingValueAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[		 
AttributeUsage		 
(		 
AttributeTargets		  
.		  !
Field		! &
|		' (
AttributeTargets		) 9
.		9 :
Property		: B
)		B C
]		C D
public

 
sealed

 
class

 %
UseExistingValueAttribute

 -
:

. /
	Attribute

0 9
,

9 :(
IMemberConfigurationProvider

; W
{ 
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ )
memberConfigurationExpression %
.% &
UseDestinationValue& 9
(9 :
): ;
;; <
} 
} 
kC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\SourceMemberAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[		 
AttributeUsage		 
(		 
AttributeTargets		  
.		  !
Field		! &
|		' (
AttributeTargets		) 9
.		9 :
Property		: B
)		B C
]		C D
public

 
sealed

 
class

 !
SourceMemberAttribute

 )
(

) *
string

* 0
name

1 5
)

5 6
:

7 8
	Attribute

9 B
,

B C(
IMemberConfigurationProvider

D `
{ 
public 

string 
Name 
{ 
get 
; 
} 
=  !
name" &
;& '
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ 
var 
destinationMember 
= )
memberConfigurationExpression  =
.= >
DestinationMember> O
;O P
if 

( 
destinationMember 
. 
Has !
<! "#
ValueConverterAttribute" 9
>9 :
(: ;
); <
||= ?
destinationMember@ Q
.Q R
HasR U
<U V"
ValueResolverAttributeV l
>l m
(m n
)n o
)o p
{ 	
return 
; 
} 	)
memberConfigurationExpression %
.% &
MapFrom& -
(- .
Name. 2
)2 3
;3 4
} 
} ö

mC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\NullSubstituteAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[		 
AttributeUsage		 
(		 
AttributeTargets		  
.		  !
Field		! &
|		' (
AttributeTargets		) 9
.		9 :
Property		: B
)		B C
]		C D
public

 
sealed

 
class

 #
NullSubstituteAttribute

 +
(

+ ,
object

, 2
value

3 8
)

8 9
:

: ;
	Attribute

< E
,

E F(
IMemberConfigurationProvider

G c
{ 
public 

object 
Value 
{ 
get 
; 
}  
=! "
value# (
;( )
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ )
memberConfigurationExpression %
.% &
NullSubstitute& 4
(4 5
Value5 :
): ;
;; <
} 
} ë

kC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\MappingOrderAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[		 
AttributeUsage		 
(		 
AttributeTargets		  
.		  !
Field		! &
|		' (
AttributeTargets		) 9
.		9 :
Property		: B
)		B C
]		C D
public

 
sealed

 
class

 !
MappingOrderAttribute

 )
(

) *
int

* -
value

. 3
)

3 4
:

5 6
	Attribute

7 @
,

@ A(
IMemberConfigurationProvider

B ^
{ 
public 

int 
Value 
{ 
get 
; 
} 
= 
value  %
;% &
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ )
memberConfigurationExpression %
.% &
SetMappingOrder& 5
(5 6
Value6 ;
); <
;< =
} 
} í
kC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\MapAtRuntimeAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[

 
AttributeUsage

 
(

 
AttributeTargets

  
.

  !
Field

! &
|

' (
AttributeTargets

) 9
.

9 :
Property

: B
)

B C
]

C D
public 
sealed 
class !
MapAtRuntimeAttribute )
:* +
	Attribute, 5
,5 6(
IMemberConfigurationProvider7 S
{ 
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ )
memberConfigurationExpression %
.% &
MapAtRuntime& 2
(2 3
)3 4
;4 5
} 
} ˝
rC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\IMemberConfigurationProvider.cs
	namespace 	

AutoMapper
 
. 
Configuration "
;" #
public 
	interface (
IMemberConfigurationProvider -
{ 
void 
ApplyConfiguration	 
( *
IMemberConfigurationExpression :)
memberConfigurationExpression; X
)X Y
;Y Z
} Ä
eC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\IgnoreAttribute.cs
	namespace 	

AutoMapper
 
. 
Configuration "
." #
Annotations# .
;. /
[		 
AttributeUsage		 
(		 
AttributeTargets		  
.		  !
Field		! &
|		' (
AttributeTargets		) 9
.		9 :
Property		: B
)		B C
]		C D
public

 
sealed

 
class

 
IgnoreAttribute

 #
:

$ %
	Attribute

& /
,

/ 0(
IMemberConfigurationProvider

1 M
{ 
public 

void 
ApplyConfiguration "
(" #*
IMemberConfigurationExpression# A)
memberConfigurationExpressionB _
)_ `
{ )
memberConfigurationExpression %
.% &
Ignore& ,
(, -
)- .
;. /
} 
} Ç"
fC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\Configuration\Annotations\AutoMapAttribute.cs
	namespace 	

AutoMapper
 
; 
[ 
AttributeUsage 
( 
AttributeTargets  
.  !
Class! &
|' (
AttributeTargets) 9
.9 :
	Interface: C
|D E
AttributeTargetsF V
.V W
StructW ]
,] ^
AllowMultiple_ l
=m n
trueo s
)s t
]t u
public 
sealed 
class 
AutoMapAttribute $
($ %
Type% )

sourceType* 4
)4 5
:6 7
	Attribute8 A
{		 
public

 

Type

 

SourceType

 
{

 
get

  
;

  !
}

" #
=

$ %

sourceType

& 0
;

0 1
public 

bool 

ReverseMap 
{ 
get  
;  !
set" %
;% &
}' (
public 

bool (
ConstructUsingServiceLocator ,
{- .
get/ 2
;2 3
set4 7
;7 8
}9 :
public 

int 
MaxDepth 
{ 
get 
; 
set "
;" #
}$ %
public 

bool 
PreserveReferences "
{# $
get% (
;( )
set* -
;- .
}/ 0
public 

bool !
DisableCtorValidation %
{& '
get( +
;+ ,
set- 0
;0 1
}2 3
public$$ 

bool$$ 
IncludeAllDerived$$ !
{$$" #
get$$$ '
;$$' (
set$$) ,
;$$, -
}$$. /
public)) 

Type)) 
TypeConverter)) 
{)) 
get))  #
;))# $
set))% (
;))( )
}))* +
public.. 

bool.. 
AsProxy.. 
{.. 
get.. 
;.. 
set.. "
;.." #
}..$ %
public00 

void00 
ApplyConfiguration00 "
(00" #
IMappingExpression00# 5
mappingExpression006 G
)00G H
{11 
if22 

(22 

ReverseMap22 
)22 
{33 	
mappingExpression44 
.44 

ReverseMap44 (
(44( )
)44) *
;44* +
}55 	
if77 

(77 (
ConstructUsingServiceLocator77 (
)77( )
{88 	
mappingExpression99 
.99 (
ConstructUsingServiceLocator99 :
(99: ;
)99; <
;99< =
}:: 	
if<< 

(<< 
MaxDepth<< 
><< 
$num<< 
)<< 
{== 	
mappingExpression>> 
.>> 
MaxDepth>> &
(>>& '
MaxDepth>>' /
)>>/ 0
;>>0 1
}?? 	
ifAA 

(AA 
PreserveReferencesAA 
)AA 
{BB 	
mappingExpressionCC 
.CC 
PreserveReferencesCC 0
(CC0 1
)CC1 2
;CC2 3
}DD 	
ifFF 

(FF !
DisableCtorValidationFF !
)FF! "
{GG 	
mappingExpressionHH 
.HH !
DisableCtorValidationHH 3
(HH3 4
)HH4 5
;HH5 6
}II 	
ifKK 

(KK 
IncludeAllDerivedKK 
)KK 
{LL 	
mappingExpressionMM 
.MM 
IncludeAllDerivedMM /
(MM/ 0
)MM0 1
;MM1 2
}NN 	
ifPP 

(PP 
TypeConverterPP 
!=PP 
nullPP !
)PP! "
{QQ 	
mappingExpressionRR 
.RR 
ConvertUsingRR *
(RR* +
TypeConverterRR+ 8
)RR8 9
;RR9 :
}SS 	
ifUU 

(UU 
AsProxyUU 
)UU 
{VV 	
mappingExpressionWW 
.WW 
AsProxyWW %
(WW% &
)WW& '
;WW' (
}XX 	
}YY 
}ZZ ®ù
VC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\AutoMapperMappingException.cs
	namespace 	

AutoMapper
 
; 
public 
class &
AutoMapperMappingException '
:( )
	Exception* 3
{		 
private

 
readonly

 
string

 
_message

 $
;

$ %
public 
&
AutoMapperMappingException %
(% &
)& '
{ 
} 
public 
&
AutoMapperMappingException %
(% &
string& ,
message- 4
)4 5
: 	
base
 
( 
message 
) 
=> 
_message #
=$ %
message& -
;- .
public 
&
AutoMapperMappingException %
(% &
string& ,
message- 4
,4 5
	Exception6 ?
innerException@ N
)N O
: 	
base
 
( 
message 
, 
innerException &
)& '
=>( *
_message+ 3
=4 5
message6 =
;= >
public 
&
AutoMapperMappingException %
(% &
string& ,
message- 4
,4 5
	Exception6 ?
innerException@ N
,N O
TypePairP X
typesY ^
)^ _
: 	
this
 
( 
message 
, 
innerException &
)& '
=>( *
Types+ 0
=1 2
types3 8
;8 9
public 
&
AutoMapperMappingException %
(% &
string& ,
message- 4
,4 5
	Exception6 ?
innerException@ N
,N O
TypeMapP W
typeMapX _
)_ `
: 	
this
 
( 
message 
, 
innerException &
,& '
typeMap( /
./ 0
Types0 5
)5 6
=>7 9
TypeMap: A
=B C
typeMapD K
;K L
public 
&
AutoMapperMappingException %
(% &
string& ,
message- 4
,4 5
	Exception6 ?
innerException@ N
,N O
	MemberMapP Y
	memberMapZ c
)c d
: 	
this
 
( 
message 
, 
innerException &
,& '
	memberMap( 1
.1 2
TypeMap2 9
)9 :
=>; =
	MemberMap> G
=H I
	memberMapJ S
;S T
public 

TypePair 
? 
Types 
{ 
get  
;  !
set" %
;% &
}' (
public   

TypeMap   
TypeMap   
{   
get    
;    !
set  " %
;  % &
}  ' (
public!! 

	MemberMap!! 
	MemberMap!! 
{!!  
get!!! $
;!!$ %
set!!& )
;!!) *
}!!+ ,
public## 

override## 
string## 
Message## "
{$$ 
get%% 
{&& 	
var'' 
message'' 
='' 
_message'' "
;''" #
var(( 
newLine(( 
=(( 
Environment(( %
.((% &
NewLine((& -
;((- .
if)) 
()) 
Types)) 
.)) 
HasValue)) 
&&)) !
Types))" '
.))' (
Value))( -
.))- .

SourceType)). 8
!=))9 ;
null))< @
&&))A C
Types))D I
.))I J
Value))J O
.))O P
DestinationType))P _
!=))` b
null))c g
)))g h
{** 
message++ 
=++ 
message++ !
+++" #
newLine++$ +
+++, -
newLine++. 5
+++6 7
$str++8 H
;++H I
message,, 
+=,, 
newLine,, "
+,,# $
$",,% '
{,,' (
Types,,( -
.,,- .
Value,,. 3
.,,3 4

SourceType,,4 >
.,,> ?
Name,,? C
},,C D
$str,,D H
{,,H I
Types,,I N
.,,N O
Value,,O T
.,,T U
DestinationType,,U d
.,,d e
Name,,e i
},,i j
",,j k
;,,k l
message-- 
+=-- 
newLine-- "
+--# $
$"--% '
{--' (
Types--( -
.--- .
Value--. 3
.--3 4

SourceType--4 >
.--> ?
FullName--? G
}--G H
$str--H L
{--L M
Types--M R
.--R S
Value--S X
.--X Y
DestinationType--Y h
.--h i
FullName--i q
}--q r
"--r s
;--s t
}.. 
if// 
(// 
TypeMap// 
!=// 
null// 
)//  
{00 
message11 
=11 
message11 !
+11" #
newLine11$ +
+11, -
newLine11. 5
+116 7
$str118 Q
;11Q R
message22 
+=22 
newLine22 "
+22# $
$"22% '
{22' (
TypeMap22( /
.22/ 0

SourceType220 :
.22: ;
Name22; ?
}22? @
$str22@ D
{22D E
TypeMap22E L
.22L M
DestinationType22M \
.22\ ]
Name22] a
}22a b
"22b c
;22c d
message33 
+=33 
newLine33 "
+33# $
$"33% '
{33' (
TypeMap33( /
.33/ 0

SourceType330 :
.33: ;
FullName33; C
}33C D
$str33D H
{33H I
TypeMap33I P
.33P Q
DestinationType33Q `
.33` a
FullName33a i
}33i j
"33j k
;33k l
}44 
if55 
(55 
	MemberMap55 
!=55 
null55 !
)55! "
{66 
message77 
=77 
message77 !
+77" #
newLine77$ +
+77, -
newLine77. 5
+776 7
$str778 M
;77M N
message88 
+=88 
newLine88 "
+88# $
$"88% '
{88' (
	MemberMap88( 1
}881 2
"882 3
+884 5
newLine886 =
;88= >
}99 
return;; 
message;; 
;;; 
}<< 	
}== 
}KK 
publicLL 
classLL 2
&DuplicateTypeMapConfigurationExceptionLL 3
(LL3 42
&DuplicateTypeMapConfigurationExceptionLL4 Z
.LLZ [
TypeMapConfigErrorsLL[ n
[LLn o
]LLo p
errorsLLq w
)LLw x
:LLy z
	Exception	LL{ Ñ
{MM 
publicNN 

TypeMapConfigErrorsNN 
[NN 
]NN  
ErrorsNN! '
{NN( )
getNN* -
;NN- .
}NN/ 0
=NN1 2
errorsNN3 9
;NN9 :
publicOO 

overrideOO 
stringOO 
MessageOO "
{OO# $
getOO% (
;OO( )
}OO* +
=OO, -
	GetErrorsOO. 7
(OO7 8
errorsOO8 >
)OO> ?
;OO? @
staticPP 

stringPP 
	GetErrorsPP 
(PP 
TypeMapConfigErrorsPP /
[PP/ 0
]PP0 1
errorsPP2 8
)PP8 9
{QQ 
StringBuilderRR 
builderRR 
=RR 
newRR  #
(RR# $
)RR$ %
;RR% &
builderSS 
.SS 

AppendLineSS 
(SS 
$strSS 7
)SS7 8
;SS8 9
foreachTT 
(TT 
varTT 
errorTT 
inTT 
errorsTT #
)TT# $
{UU 	
builderVV 
.VV 

AppendLineVV 
(VV 
$"VV !
{VV! "
errorVV" '
.VV' (
TypesVV( -
.VV- .

SourceTypeVV. 8
.VV8 9
FullNameVV9 A
}VVA B
$strVVB F
{VVF G
errorVVG L
.VVL M
TypesVVM R
.VVR S
DestinationTypeVVS b
.VVb c
FullNameVVc k
}VVk l
$str	VVl Å
"
VVÅ Ç
)
VVÇ É
;
VVÉ Ñ
builderWW 
.WW 

AppendLineWW 
(WW 
stringWW %
.WW% &
JoinWW& *
(WW* +
EnvironmentWW+ 6
.WW6 7
NewLineWW7 >
,WW> ?
errorWW@ E
.WWE F
ProfileNamesWWF R
)WWR S
)WWS T
;WWT U
}XX 	
builderYY 
.YY 

AppendLineYY 
(YY 
$str	YY ä
)
YYä ã
;
YYã å
returnZZ 
builderZZ 
.ZZ 
ToStringZZ 
(ZZ  
)ZZ  !
;ZZ! "
}[[ 
public\\ 

readonly\\ 
record\\ 
struct\\ !
TypeMapConfigErrors\\" 5
(\\5 6
TypePair\\6 >
Types\\? D
,\\D E
string\\F L
[\\L M
]\\M N
ProfileNames\\O [
)\\[ \
;\\\ ]
}]] 
public^^ 
class^^ ,
 AutoMapperConfigurationException^^ -
:^^. /
	Exception^^0 9
{__ 
public`` 

TypeMapConfigErrors`` 
[`` 
]``  
Errors``! '
{``( )
get``* -
;``- .
}``/ 0
publicaa 

TypePairaa 
?aa 
Typesaa 
{aa 
getaa  
;aa  !
}aa" #
publicbb 

	MemberMapbb 
	MemberMapbb 
{bb  
getbb! $
;bb$ %
setbb& )
;bb) *
}bb+ ,
publicdd 

readonlydd 
recorddd 
structdd !
TypeMapConfigErrorsdd" 5
(dd5 6
TypeMapdd6 =
TypeMapdd> E
,ddE F
stringddG M
[ddM N
]ddN O!
UnmappedPropertyNamesddP e
,dde f
boolddg k
CanConstructddl x
)ddx y
;ddy z
publicff 
,
 AutoMapperConfigurationExceptionff +
(ff+ ,
stringff, 2
messageff3 :
)ff: ;
:gg 	
basegg
 
(gg 
messagegg 
)gg 
{hh 
}ii 
publickk 
,
 AutoMapperConfigurationExceptionkk +
(kk+ ,
stringkk, 2
messagekk3 :
,kk: ;
	Exceptionkk< E
innerkkF K
)kkK L
:ll 	
basell
 
(ll 
messagell 
,ll 
innerll 
)ll 
{mm 
}nn 
publicpp 
,
 AutoMapperConfigurationExceptionpp +
(pp+ ,
TypeMapConfigErrorspp, ?
[pp? @
]pp@ A
errorsppB H
)ppH I
=>ppJ L
ErrorsppM S
=ppT U
errorsppV \
;pp\ ]
publicrr 
,
 AutoMapperConfigurationExceptionrr +
(rr+ ,
TypePairrr, 4
typesrr5 :
)rr: ;
=>rr< >
Typesrr? D
=rrE F
typesrrG L
;rrL M
publictt 

overridett 
stringtt 
Messagett "
{uu 
getvv 
{ww 	
ifxx 
(xx 
Typesxx 
.xx 
HasValuexx 
)xx 
{yy 
varzz 
messagezz 
=zz 
string{{ 
.{{ 
Format{{ !
({{! "
$str	|| µ
,
||µ ∂
Types}} 
.}} 
Value}} #
.}}# $
DestinationType}}$ 3
.}}3 4
FullName}}4 <
,}}< =
Types}}> C
.}}C D
Value}}D I
.}}I J
DestinationType}}J Y
.}}Y Z
FullName}}Z b
,}}b c
	MemberMap~~ !
)~~! "
;~~" #
message
ÄÄ 
+=
ÄÄ 
$str
ÄÄ '
;
ÄÄ' (
	Exception
ÇÇ 
exToUse
ÇÇ !
=
ÇÇ" #
this
ÇÇ$ (
;
ÇÇ( )
while
ÉÉ 
(
ÉÉ 
exToUse
ÉÉ 
!=
ÉÉ !
null
ÉÉ" &
)
ÉÉ& '
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
exToUse
ÖÖ 
is
ÖÖ  ".
 AutoMapperConfigurationException
ÖÖ# C
	configExc
ÖÖD M
)
ÖÖM N
{
ÜÜ 
message
áá 
+=
áá  "
	configExc
áá# ,
.
áá, -
	MemberMap
áá- 6
==
áá7 9
null
áá: >
?
àà 
$"
àà 
$str
àà 4
{
àà4 5
	configExc
àà5 >
.
àà> ?
Types
àà? D
.
ààD E
Value
ààE J
.
ààJ K

SourceType
ààK U
.
ààU V
FullName
ààV ^
}
àà^ _
$str
àà_ c
{
ààc d
	configExc
ààd m
.
ààm n
Types
ààn s
.
ààs t
Value
ààt y
.
àày z
DestinationTypeààz â
.ààâ ä
FullNameààä í
}ààí ì
"ààì î
:
ââ 
$"
ââ 
$str
ââ 4
{
ââ4 5
	configExc
ââ5 >
.
ââ> ?
	MemberMap
ââ? H
}
ââH I
$str
ââI O
{
ââO P
	configExc
ââP Y
.
ââY Z
Types
ââZ _
.
ââ_ `
Value
ââ` e
.
ââe f

SourceType
ââf p
.
ââp q
FullName
ââq y
}
âây z
$str
ââz ~
{
ââ~ 
	configExcââ à
.ââà â
Typesâââ é
.ââé è
Valueââè î
.ââî ï
DestinationTypeââï §
.ââ§ •
FullNameââ• ≠
}ââ≠ Æ
"ââÆ Ø
;ââØ ∞
}
ää 
exToUse
åå 
=
åå 
exToUse
åå %
.
åå% &
InnerException
åå& 4
;
åå4 5
}
çç 
return
èè 
message
èè 
+
èè  
$str
èè! %
+
èè& '
base
èè( ,
.
èè, -
Message
èè- 4
;
èè4 5
}
êê 
if
ëë 
(
ëë 
Errors
ëë 
!=
ëë 
null
ëë 
)
ëë 
{
íí 
StringBuilder
ìì 
message
ìì %
=
ìì& '
new
ìì( +
(
ìì+ ,
$strîî ∑
)îî∑ ∏
;îî∏ π
foreach
ññ 
(
ññ 
var
ññ 
error
ññ "
in
ññ# %
Errors
ññ& ,
)
ññ, -
{
óó 
var
òò 
len
òò 
=
òò 
error
òò #
.
òò# $
TypeMap
òò$ +
.
òò+ ,

SourceType
òò, 6
.
òò6 7
FullName
òò7 ?
.
òò? @
Length
òò@ F
+
òòG H
error
ôô #
.
ôô# $
TypeMap
ôô$ +
.
ôô+ ,
DestinationType
ôô, ;
.
ôô; <
FullName
ôô< D
.
ôôD E
Length
ôôE K
+
ôôL M
$num
ôôN O
;
ôôO P
message
õõ 
.
õõ 

AppendLine
õõ &
(
õõ& '
new
õõ' *
(
õõ* +
$char
õõ+ .
,
õõ. /
len
õõ0 3
)
õõ3 4
)
õõ4 5
;
õõ5 6
message
úú 
.
úú 

AppendLine
úú &
(
úú& '
error
úú' ,
.
úú, -
TypeMap
úú- 4
.
úú4 5

SourceType
úú5 ?
.
úú? @
Name
úú@ D
+
úúE F
$str
úúG M
+
úúN O
error
úúP U
.
úúU V
TypeMap
úúV ]
.
úú] ^
DestinationType
úú^ m
.
úúm n
Name
úún r
+
úús t
$str
ùù' +
+
ùù, -
error
ûû' ,
.
ûû, -
TypeMap
ûû- 4
.
ûû4 5"
ConfiguredMemberList
ûû5 I
+
ûûJ K
$str
ûûL [
)
ûû[ \
;
ûû\ ]
message
üü 
.
üü 

AppendLine
üü &
(
üü& '
error
üü' ,
.
üü, -
TypeMap
üü- 4
.
üü4 5

SourceType
üü5 ?
.
üü? @
FullName
üü@ H
+
üüI J
$str
üüK Q
+
üüR S
error
††' ,
.
††, -
TypeMap
††- 4
.
††4 5
DestinationType
††5 D
.
††D E
FullName
††E M
+
††N O
$str
††P T
+
††U V
error
°°' ,
.
°°, -
TypeMap
°°- 4
.
°°4 5"
ConfiguredMemberList
°°5 I
+
°°J K
$str
°°L [
)
°°[ \
;
°°\ ]
message
¢¢ 
.
¢¢ 

AppendLine
¢¢ &
(
¢¢& '
)
¢¢' (
;
¢¢( )
if
§§ 
(
§§ 
error
§§ 
.
§§ #
UnmappedPropertyNames
§§ 3
.
§§3 4
Any
§§4 7
(
§§7 8
)
§§8 9
)
§§9 :
{
•• 
message
¶¶ 
.
¶¶  

AppendLine
¶¶  *
(
¶¶* +
$str
¶¶+ A
)
¶¶A B
;
¶¶B C
foreach
ßß 
(
ßß  !
var
ßß! $
name
ßß% )
in
ßß* ,
error
ßß- 2
.
ßß2 3#
UnmappedPropertyNames
ßß3 H
)
ßßH I
{
®® 
message
©© #
.
©©# $

AppendLine
©©$ .
(
©©. /
name
©©/ 3
)
©©3 4
;
©©4 5
}
™™ 
}
´´ 
if
¨¨ 
(
¨¨ 
!
¨¨ 
error
¨¨ 
.
¨¨ 
CanConstruct
¨¨ +
)
¨¨+ ,
{
≠≠ 
message
ÆÆ 
.
ÆÆ  

AppendLine
ÆÆ  *
(
ÆÆ* +
$"
ÆÆ+ -
$str
ÆÆ- F
{
ÆÆF G
error
ÆÆG L
.
ÆÆL M
TypeMap
ÆÆM T
.
ÆÆT U
CheckRecord
ÆÆU `
(
ÆÆ` a
)
ÆÆa b
}
ÆÆb c
"
ÆÆc d
)
ÆÆd e
;
ÆÆe f
}
ØØ 
}
∞∞ 
return
±± 
message
±± 
.
±± 
ToString
±± '
(
±±' (
)
±±( )
;
±±) *
}
≤≤ 
return
≥≥ 
base
≥≥ 
.
≥≥ 
Message
≥≥ 
;
≥≥  
}
¥¥ 	
}
µµ 
public
∑∑ 

override
∑∑ 
string
∑∑ 

StackTrace
∑∑ %
{
∏∏ 
get
ππ 
{
∫∫ 	
if
ªª 
(
ªª 
Errors
ªª 
!=
ªª 
null
ªª 
)
ªª 
return
ºº 
string
ºº 
.
ºº 
Join
ºº "
(
ºº" #
Environment
ºº# .
.
ºº. /
NewLine
ºº/ 6
,
ºº6 7
base
ΩΩ 
.
ΩΩ 

StackTrace
ΩΩ #
.
ææ 
Split
ææ 
(
ææ 
[
ææ  
Environment
ææ  +
.
ææ+ ,
NewLine
ææ, 3
]
ææ3 4
,
ææ4 5 
StringSplitOptions
ææ6 H
.
ææH I
None
ææI M
)
ææM N
.
øø 
Where
øø 
(
øø 
str
øø "
=>
øø# %
!
øø& '
str
øø' *
.
øø* +
	TrimStart
øø+ 4
(
øø4 5
)
øø5 6
.
øø6 7

StartsWith
øø7 A
(
øøA B
$str
øøB R
)
øøR S
)
øøS T
.
¿¿ 
ToArray
¿¿  
(
¿¿  !
)
¿¿! "
)
¿¿" #
;
¿¿# $
return
¬¬ 
base
¬¬ 
.
¬¬ 

StackTrace
¬¬ "
;
¬¬" #
}
√√ 	
}
ƒƒ 
}≈≈ ﬁ
HC:\Users\Tesla Laptops\Desktop\AutoMapper\src\AutoMapper\AssemblyInfo.cs
[ 
assembly 	
:	 

CLSCompliant 
( 
true 
) 
] 
[ 
assembly 	
:	 


ComVisible 
( 
false 
) 
] 
[ 
assembly 	
:	 
$
NeutralResourcesLanguage #
(# $
$str$ (
)( )
]) *
	namespace 	
System
 
. 
Runtime 
. 
CompilerServices )
;) *
static

 
class

 
IsExternalInit

 
{

 
}

 